#
# cvs:affy/sdk/Makefile ---
#
# $Id: Makefile,v 1.150 2009-10-28 00:08:27 harley Exp $
#

# QUICKSTART:
#
# Run "./configure --help" to see the options you can set;
# then run "./configure ; make"
#
# This build system is intended for use on unix-like systems
# which have make-3.80 (or later).  Prior versions have
# problems with "$(call)".  "./configure" will check for this.

# DISCUSSION:
#
# Sorry, but automake and friends were just too much to work
# with.  Using a perl script and a "normal" recursive make
# appeared more tractable.

# VARIABLE and TARGET NAMES:
#
# Variables which start with "sdk_" are intended for the
# user to set.  Variables which start with "m2_" should be
# internal to the makefiles.  Variables and targets which
# start with an underscore should reference stuff in the
# current directory only.  Targets without the leading
# underscore are recursive.

# Variables of note are:
#  sdk_subdirs       = directories to descend into
#                      (defaults to directories with a Makefile)
#  sdk_exe           = programs to build
#                      (list of programs to generate default build rules for.)
#  sdk_cppunit_exe   = cppunit programs
#  sdk_cpp_ignore    = *.cpp which should be left alone
#
#  sdk_cpp_cflags    = flags for compiling  C++ code 
#                      (Add the '-I' or '-L' on paths)
#  sdk_cpp_lflags    = flags for linking
#
#  sdk_c_cflags      = flags for compiling C code
#                      (Add the '-I' or '-L' on paths)

# DIRECTORIES:
#
# To make sure the output goes to the correct places, use these
# variables instead of a hard coded path.
#
# sdk_output         =
# sdk_output_bin     =

# MAKEFILE LAYOUT:
#
# To keep the sub-makefiles small, repeated text is kept in
# "Makefile.defs".  "Makefile.post" is included near the end.
# A typical makefile should look like "util/Makefile".
# That makefile is commented for use as an example.  (The others arent)

# SEQUENCING:
#
# Each phase of the build has a makefile target.  (Targets
# which start with an underscore are "local" targets. They
# wont recurse and are generally for internal use.) Each of
# these sequencing target has a variable of the same
# name. Append what needs to be completed on this phase to
# the end of the variable.

# For example: the target "_build_exe" builds executables in
# the current directory.  The variable "_build_exe" should
# have the list of executables to be built. Append to it
# with: "_build_exe+=${sdk_output_bin}/foo"

#
# The build process runs in stages:
#
# ./configure to set the output and install paths.  The
# output paths will default.  The install paths will not.
# (You can still run programs from the output dir.)
#
# When "make" is run it will attempt to build all the
# targets in the current directory first and then recurses
# to the subdirectories.

# CHANGES:
# Changes from the old system:
#  * "./configure --prefix=/path ; make ; make install" works.  (or it will!)
#  * "make -j N" works in the directory
#  * automatic deps from gcc
#  * Droping of the "two build" opt and dbg

### programs
# define some vars for programs we use.
# this allows us to set the full path should we need it.


# Included files
#
# Makefile
#    This file includes "Makefile.defs"
# Makefile.defs
#    contains defaults and definitions which will be used
#    for later expansion by "$(call)".
#    It also includes "Makefile.config" and "Makefile.site".
# Makefile.config
#    Contain a short list of vars. (as generated by "./configure")
# Makefile.site
#    an optional file for use by other sites.
#    it will not be updated or replaced by us.

# This should always be set before including the defs file.
sdk_root:=.
include ${sdk_root}/Makefile.defs

# The external libs should have the following interface:
#   * "MODULE"       = builds and installs the lib if it isnt installed
#   * "MODILE_build" = always builds and installs into "sdk_output_top"
#   * "MODILE_clean" = removes the files from sdk_output_top

##########
## SQLite
.PHONY: sqlite sqlite_build sqlite_clean

sqlite: ${sdk_output_lib}/lib${sqlite_libname}.a

sqlite_env:=CC=gcc \
 CFLAGS='${sdk_c_cflags} ${sdk_arch_flags}' \
 CXXFLAGS='${sdk_c_cflags} ${sdk_arch_flags}' \
 LDFLAGS='${sdk_osx_lflags} ${sdk_arch_flags}'

${sdk_output_lib}/lib${sqlite_libname}.a:
	${MAKE} sqlite_build

sqlite_build: sqlite_build_1 sqlite_install | ${sdk_output_lib} ${sdk_output_share_include}

sqlite_build_1:
	cd ${sqlite_top} && ( \
		rm *.o; \
		${sqlite_env} make libsqlite3.a)

sqlite_install:
	cp ${sqlite_top}/libsqlite3.a ${sdk_output_lib}/lib${sqlite_libname}.a
	cp ${sqlite_top}/sqlite3.h ${sdk_output_share_include}/sqlite3.h

sqlite_clean:
	$(call do_rm,${sdk_output_lib}/lib${sqlite_libname}.a ${sdk_output_share_include}/sqlite3.h)

# In this top level build phase we want to require "newmat" to be built
# right at the start.
# But dont build it if it is prebuilt.
ifeq ($(call is_prebuilt_lib,newmat),)
  _build+=newmat
endif
ifeq ($(call is_prebuilt_lib,asqlite),)
  _build+=sqlite
endif
ifeq ($(call is_prebuilt_lib,z),)
  _build+=zlib
endif
ifeq ($(call is_prebuilt_lib,pcre),)
  _build+=pcre
endif
ifeq ($(call is_prebuilt_lib,hdf5),)
  _build+=hdf5
endif
ifeq ($(call is_prebuilt_lib,xerces-c),)
  _build+=xerces
endif
#
_build+=pywavelets

clean_external: newmat_clean sqlite_clean zlib_clean pcre_clean hdf5_clean xerces_clean pywavelets_clean

# We list these subdirs in the order we want the descended into.
# Some of the later ones depend on the early ones.
# (Otherwise they would be done in alphabetic order.)
# If there is a prebuilt libaffycalvin.a, skip the calvin_files directory.
sdk_subdirs:=\
  $(if $(call is_prebuilt_lib,affyutil),,util) \
  stats \
  $(if $(call is_prebuilt_lib,affyfile),,file) \
  file5 \
  $(if $(call is_prebuilt_lib,affycalvin),,calvin_files) \
  portability normalization algorithm dabg plier rma rawq \
  exp_report mas5-stat mas5 dm label chipstream \
  broadutil birdseed-dev birdseed-v1 midas canary \
  dmet copynumber translation rtest dbtools \
  $(wildcard gtools) \
  $(wildcard bboard) $(wildcard calvinlite)

jhg:
#	@echo "is_prebuilt_lib(affycalvin)  =" $(call is_prebuilt_lib,affycalvin)
#	@echo "find_lib_path_for(affycalvin)=" $(call find_lib_path_for,affycalvin)
	@echo "is_prebuilt_lib(affyfile)=" $(call is_prebuilt_lib,affyfile)
	@echo "sdk_subdirs=" ${sdk_subdirs}

# We also build the these three libraries
# _build+=_build_libaffyutil _build_libaffyfile _build_libaffycalvin

# What gets removed.
clean_lib_files:=$(foreach l,${sdk_depend_paths},${l} ${l}.pre-ranlib)

clean_lib:
	$(call do_rm,${clean_lib_files},'# No libs')

### top level install actions
ifdef install_prefix

# add the dirs to the list of things to make when installing.
_install+=${install_dirs}
# add the libraries
_install+=${install_lib_names:%=${install_exec_lib}/lib%.a}

### sigh -- how to do this?
#install_exec_lib}/lib
#$(foreach L,${install_lib_names},\
#  ${install_exec_lib}/lib%a: $(call find_lib_path_for,${X})
#${install_lib_names:%=${install_exec_lib}/lib%.a}: ${install_exec_lib}/lib%.a: # xxx #$(call find_lib_path_for,$*)
#	install -m 444 $< $@

${install_exec_lib}/libaffycalvin.a: $(call find_lib_path_for,affycalvin)
	install -m 444 $< $@
${install_exec_lib}/libaffysdk.a: $(call find_lib_path_for,affysdk)
	install -m 444 $< $@
${install_exec_lib}/libaffyutil.a: $(call find_lib_path_for,affyutil)
	install -m 444 $< $@
${install_exec_lib}/libnewmat.a: $(call find_lib_path_for,newmat)
	install -m 444 $< $@
${install_exec_lib}/libaffyfile.a: $(call find_lib_path_for,affyfile)
	install -m 444 $< $@
${install_exec_lib}/libaffyfile5.a: $(call find_lib_path_for,affyfile5)
	install -m 444 $< $@

# Add the documentation to the list install targets
.PHONY: install_docs
_install+=install_docs
install_docs:
	-mkdir -p ${install_doc}
	-${CP} -r apt/doc/* ${install_doc}

endif

##########

### Newmat
.PHONY: newmat newmat_build newmat_libclean newmat_clean

libnewmat_a:=${sdk_output_lib}/libnewmat.a

newmat: ${libnewmat_a}

# how to make a local copy of newmat.a
${libnewmat_a}: | ${sdk_output_lib}
	${MAKE} newmat_build

newmat_build:
	cd ${newmat_top} && \
	( \
	  rm -f *.o libnewmat.a ; \
	  CXXFLAGS='${sdk_c_cflags} ${sdk_arch_flags} -fPIC' ${MAKE} -f nm_gnu.mak libnewmat.a \
	)
	cp ${newmat_top}/libnewmat.a.pre-ranlib ${libnewmat_a}.pre-ranlib
	cp ${libnewmat_a}.pre-ranlib ${libnewmat_a}
	ranlib ${libnewmat_a}
	cp ${newmat_top}/*.h ${sdk_output_share_include}

newmat_h:=newmat.h newmatio.h newmatrc.h newmatap.h newmatnl.h newmatrm.h

newmat_clean:
	$(call do_rm,${libnewmat_a} ${libnewmat_a}.pre-ranlib)
	$(call do_rm,${newmat_h:%=${sdk_output_share_include}/%})
#	$(call do_rm,${newmat_top}/*.o ${newmat_top}/libnewmat.a ${newmat_top}/libnewmat.a.pre-ranlib,)

newmat_debug:
	@echo "newmat_top       = " ${newmat_top}
	@echo "newmat_lib_path  = " '${newmat_lib_path}'

##########

.PHONY: hdf5 hdf5_build hdf5_clean hdf5_debug

#
hdf5_src_lib_paths:=\
  ./hl/src/.libs/libhdf5_hl.a \
  ./src/.libs/libhdf5.a \

#
hdf5_libs:=$(notdir ${hdf5_src_lib_paths})
hdf5_prefix_libs:=${hdf5_libs:%=${hdf5_prefix_lib}/%}

hdf5_env:=CC=gcc \
 CFLAGS='${sdk_c_cflags} ${sdk_arch_flags}' \
 CXXFLAGS='${sdk_c_cflags} ${sdk_arch_flags}' \
 LDFLAGS='${sdk_osx_lflags} ${sdk_arch_flags}'

hdf5: ${hdf5_prefix_libs}

${hdf5_prefix_libs}:
	${MAKE} hdf5_build

# note that we need the "${PWD}" as we need an absolute path for configure.
# @todo this needs more work for a shared install.
# @todo change hdf_output_lib to hdf_lib_path
hdf5_build: | ${hdf5_prefix_bin} ${hdf5_prefix_lib} ${hdf5_prefix_include}
	echo "" # method one: install 
	cd ${hdf5_src} && \
	( make distclean ; true ) && \
	${hdf5_env} ./configure --prefix=${hdf5_prefix} \
	  --disable-dependency-tracking \
	  --bindir=${hdf5_prefix_bin} \
	  --libdir=${hdf5_prefix_lib} \
	  --includedir=${hdf5_prefix_include} \
	  --with-zlib=${zlib_prefix_include},${zlib_prefix_lib} \
	  --disable-cxx \
	  --disable-stream-vfd \
	  --with-pic \
	  --disable-shared && \
	${hdf5_env} make && \
	${hdf5_env} make install

hdf5_clean:
	$(call do_rm,${sdk_output_lib}/libhdf5* ${sdk_output_include}/H5*.h)
# $(call do_rm,${hdf5_output_lib}/libhdf5* ${hdf5_output_include}/H5*.h)

hdf5_debug:
	@echo "hdf5_top           = ${hdf5_top}"
	@echo "hdf5_src           = ${hdf5_src}"
	@echo "hdf5_src_lib_paths = ${hdf5_src_lib_paths}"
	@echo "hdf5_libs          = ${hdf5_libs}"
	@echo "hdf5_output_libs   = ${hdf5_output_libs}"
	@echo "sdk_output_include = ${sdk_output_include}"

##########

.PHONY: pcre pcre_build pcre_clean

#
pcre_libs:=libpcre.a
pcre_prefix_libs:=${pcre_libs:%=${pcre_prefix_lib}/%}

pcre_env:=CC=gcc \
 CFLAGS='${sdk_c_cflags} ${sdk_arch_flags}' \
 CXXFLAGS='${sdk_c_cflags} ${sdk_arch_flags}' \
 LDFLAGS='${sdk_osx_lflags} ${sdk_arch_flags}'

pcre: ${pcre_prefix_libs}

# note that we need the "${PWD}" as we need an absolute path for configure.
# @todo this needs more work for a shared install.
# @todo change hdf_output_lib to hdf_lib_path
${pcre_prefix_libs}: | ${pcre_prefix_lib} ${pcre_prefix_include}
	${MAKE} pcre_build

pcre_build:
	echo "" # method one: install 
	cd ${pcre_src} && \
	(make clean ; true ) && \
	${pcre_env} ./configure --prefix=${pcre_prefix} \
          --enable-newline-is-any \
	  --disable-dependency-tracking \
	  --disable-shared \
	  --bindir=${pcre_prefix_bin} \
	  --libdir=${pcre_prefix_lib} \
	  --with-pic \
	  --includedir=${pcre_prefix_include} && \
	${pcre_env} make && \
	${pcre_env} make install && \
	cp config.h affy-pcre.h ${pcre_prefix_include}

pcre_clean:
	$(call do_rm,${pcre_prefix_lib}/libpcre* ${pcre_prefix_include}/pcre*.h)

pcre_debug:
	@echo "pcre_top              = ${pcre_top}"
	@echo "pcre_src              = ${pcre_src}"
	@echo "pcre_prefix           = ${pcre_prefix}"
	@echo "pcre_prefix_bin       = ${pcre_prefix_bin}"
	@echo "pcre_prefix_lib       = ${pcre_prefix_lib}"
	@echo "pcre_prefix_include   = ${pcre_prefix_include}"
	@echo "pcre_libs             = ${pcre_libs}"

##########

pywavelets_libs:=libpywavelets.a
pywavelets_prefix_libs:=${pywavelets_libs:%=${sdk_output_lib}/%}

PYWAVELETS_SRC:=${sdk_root}/../external/pywavelets

pywavelets: ${pywavelets_prefix_libs}

${pywavelets_prefix_libs}:
	cd ${PYWAVELETS_SRC} && make && make apt-install

pywavelets_clean:
	-rm ${pywavelets_prefix_libs}

##########

XERCES_SRC:=${sdk_root}/../external/xerces

XERCES_RUNCONFIG_ARGS:=

# ifeq ($(findstring powerpc-apple-tiger,${CPUCOMSYS}),powerpc-apple-tiger)
#  XERCES_RUNCONFIG_ARGS:=-pmacosx -b32 -n fileonly
# endif
# ifeq ($(findstring i386-apple-tiger,${CPUCOMSYS}),i386-apple-tiger)
#  XERCES_RUNCONFIG_ARGS:=-pmacosx -b32 -n fileonly
# endif
# ifeq ($(findstring sparc-sun-solaris,${CPUCOMSYS}),sparc-sun-solaris)
#  XERCES_RUNCONFIG_ARGS:=-psolaris -b64 -n fileonly
# endif
# ifeq ($(findstring amd64-pc-linux,${CPUCOMSYS}),amd64-pc-linux)
#  XERCES_RUNCONFIG_ARGS:=-plinux -b64 -n fileonly
# endif
# ifeq ($(findstring i386-intel-linux,${CPUCOMSYS}),i386-intel-linux)
#  XERCES_RUNCONFIG_ARGS:=-plinux -b32 -n fileonly
# endif
# ifeq (${XERCES_RUNCONFIG_ARGS},)
#   $(warning cant build xerces on ${CPUCOMSYS})
# endif

XERCES_RUNCONFIG_ARGS+=\
 --prefix=${xerces_prefix} \
 --bindir=${xerces_prefix_bin} \
 --libdir=${xerces_prefix_lib} \
 --includedir=${xerces_prefix_include} \
 --disable-dependency-tracking \
 --disable-shared \
 --disable-threads \
 --enable-msgloader-inmemory \
 --enable-transcoder-iconv \
 --disable-network \
 --with-pic

# the include files are generated and are not portable.
# dont put them in share/include.

xerces_libs:=libxerces-c.a
xerces_prefix_libs:=${xerces_libs:%=${xerces_prefix_lib}/%}
xerces_env:=CFLAGS='${sdk_c_cflags} ${sdk_arch_flags} -fPIC' \
	  CXXFLAGS='${sdk_c_cflags} ${sdk_arch_flags} -fPIC' \
	  LDFLAGS='${sdk_arch_flags}'

.PHONY: xerces_config xerces_build xerces_make xerces_install xerces_clean xerces

xerces: ${xerces_prefix_libs}

${xerces_prefix_libs}:
	${MAKE} xerces_build

xerces_build: | ${xerces_prefix_bin} ${xerces_prefix_lib}
	cd ${XERCES_SRC} && \
	( make distclean ; true ) && \
	${xerces_env} ./configure ${XERCES_RUNCONFIG_ARGS} && \
	${xerces_env} VERBOSE=1 make && \
	${xerces_env} make install \

xerces_clean:
	$(call do_rm,${xerces_prefix_libs})
	$(call do_rm,${sdk_output}/include/xercesc/*/*)

# dont clean the xerces dir, clean our dir of xerces.
# cd ${XERCES_SRC}/src/xercesc && XERCESCROOT=$$PWD make clean

##########

zlib_prefix_libs:=${zlib_prefix_lib}/libz.a
zlib_env:=CC=gcc \
 CFLAGS='${sdk_c_cflags} ${sdk_arch_flags} -fPIC' \
 CXXFLAGS='${sdk_c_cflags} ${sdk_arch_flags} -fPIC' \
 LDFLAGS='${sdk_osx_lflags} ${sdk_arch_flags}'

#
.PHONY: zlib zlib_build zlib_clean zlib_debug

zlib: ${zlib_prefix_libs}

${zlib_prefix_libs}:
	${MAKE} zlib_build

zlib_build: | ${zlib_prefix_lib} ${zlib_prefix_include}
	cd ${zlib_top} && \
	( make clean ; true ) && \
	${zlib_env} ./configure --prefix=${zlib_prefix} \
	  --libdir=${zlib_prefix_lib} \
	  --includedir=${zlib_prefix_include} && \
	${zlib_env} make && \
	${zlib_env} make install

zlib_clean:
	$(call do_rm,${zlib_prefix_lib}/libz.a ${zlib_prefix_include}/zlib.h)

zlib_debug:
	@echo "zlib_top         = ${zlib_top}"
	@echo "zlib_src         = ${zlib_src}"
	@echo "zlib_prefix_libs = ${zlib_prefix_libs}"

##########

include ${sdk_makefile_post}

##########
#
# Documentation.
#

## To update the docs
## - make
## - make dox
## - make check_doc

# Build doxygen documentation
#
dox:
	cd dox && ${MAKE}
.PHONY: dox 

# copy documents to web
#
DOX_WEB_DIR:=/nfs/bioinformatics/apt/nightly-build/full-src/sdk/dox/html/ 
dox_web_install:
	cd dox && ${MAKE} dox_web_install
.PHONY: dox_web_install

# Check docs for broken links (look in ./apt/doc-status/index.html)
#
check_doc:
	 cd dox && ${MAKE} check_doc
.PHONY: check_doc


# Clean dox generated files and files used in documentation process
#
clean_doc:
	cd dox && ${MAKE} clean_doc


## Target to build binary release
##
##
.PHONY: binary
binary::
	-rm -rf ${DIST_PATH_BIN}
	-mkdir -p ${DIST_PATH_BIN}/bin
	-mkdir -p ${DIST_PATH_BIN}/doc/dox-html
# @todo: what is "-r" for OSX?
	-${CP} ${sdk_output_bin}/apt-* ${DIST_PATH_BIN}/bin/
	# get doc files from last nfs nightly if don't exist
	if [ ! -d dox/html ]; then rsync -arv ${DOX_WEB_DIR} dox/html/; fi
	if [ ! -d apt/doc ]; then (cd ./dox && ./doc-files.sh); fi
	${CP} -r ${sdk_root}/apt/doc/* ${DIST_PATH_BIN}/doc/dox-html/
	${CP} ${sdk_root}/license/gnu-lgpl-license.txt ${DIST_PATH_BIN}
	${CP} ${sdk_root}/license/gnu-gpl-license.txt ${DIST_PATH_BIN}
	${CP} ${sdk_root}/license/gnu-lgpl-license.rtf ${DIST_PATH_BIN}
	${CP} ${sdk_root}/license/gnu-gpl-license.rtf ${DIST_PATH_BIN}
	cd ${APT_REL_PATH} && \
	  zip -r $(DIST_NAME_BIN).zip $(DIST_NAME_BIN) > $(DIST_NAME_BIN).zip.out

.PHONY: output_tarball
output_tarball::
	zip -r $(DIST_NAME_BIN).output.zip output > $(DIST_NAME_BIN).output.zip.out

clean_lib: clean_libnewmat clean_libaffy

clean_libnewmat:
	rm ${sdk_output_lib}/libnewmat.a
clean_libaffy:
	rm ${sdk_output_lib}/libaffy{util,sdk,file,calvin}{.a,.a-pre-ranlib}

