////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005 Affymetrix, Inc.
//
// This program is free software; you can redistribute it and/or modify 
// it under the terms of the GNU General Public License (version 2) as 
// published by the Free Software Foundation.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of 
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License 
// along with this program;if not, write to the 
// 
// Free Software Foundation, Inc., 
// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
////////////////////////////////////////////////////////////////

/**
 * @file   GenoUtility.h
 * @author Earl Hubbell
 * @date   Aug 2 2006
 *
 * Fix up utility routines for genotypes
* common transformations, etc.
 */

#ifndef GenoUtility_H
#define GenoUtility_H

//
#include "chipstream/BioTypes.h"
#include "chipstream/ClusterZ.h"
#include "chipstream/ProbeSet.h"
//
#include "calvin_files/fusion/src/FusionCELData.h"
#include "stats/stats.h"
//
#include "newmat.h"
//
#include <cfloat>
#include <cstring>
#include <string>
#include <vector>
//

bool probesetMeanStd(affymetrix_fusion_io::FusionCELData *cel, 
                     const ProbeSet *ps, 
                     float &mean, float &std);

bool probesetStd(affymetrix_fusion_io::FusionCELData *cel, 
                 const ProbeSet *ps, 
                 float &std);

bool probesetMean(affymetrix_fusion_io::FusionCELData *cel, 
                  const ProbeSet *ps, 
                  float &mean);


/**
 * Calculate the natural log ratio for two probeset signal
 *
 *@para signalA -- e.x. signal channel 
 *@para signalB -- e.x. background channel
 *
 */
double logRatio(double sigA, double sigB);

/** 
 * Open and read a target distribution from a text file. Must have a column
 * called 'intensities' with distribution quantiles sorted from highest to 
 * lowest.
 * 
 * @param fileName - text file containing column of quantiles.
 * @para sketch - vector that stores the sketch.
 */

void  loadTargetSketchFromFile(const char *fileName, std::vector<float> &sketch);


/** 
 * Read in the precomputed genotypes from a tab delimited file. Must
 * be a column for each Celfile with same header name as celfile and an row
 * for every snp to be analyzed. There can be extra columns and order of columns
 * is not important as the resulting order will be the same as the colNames
 * vector. Steal from GenoSeedTxt. 
 * @param fileName - text file containing the known genotype calls
 * @para colNames - the name of samples. 
 * @para knownCalls -- the map that store knownCalls infomation for each SNP.
 */
void loadSNPHints(std::string fileName, 
		  std::vector<std::string> &colNames,
		  std::map<std::string, std::vector<affx::GType> > &knownCalls); 
 

enum Transformation {
    MvA, ///< Minus Vs Average
    RvT, ///< R vs Theta
    CES, ///< Contrast Extremes Stretch (nee  south san francisco).
    CCS  ///< Contrast Centers Stretch (nee alternative south san francisco).
  };

/** the engine that transforms the data */
void valueForTransformation(double aVal, double bVal, enum Transformation trans, double K, double &xVal, double &yVal);
enum Transformation transformationForString(const std::string &s);

  /**
   * Convert a transformation enum to string representation
   * @param t - tranformation enum value.
   * @return - text description of enumeration.
   */
std::string stringForTransformation(enum Transformation t);

/**
 * Return the calumn names for the values generated by a given transformation
 * @param t - tranformation enum value.
 * @return - a pair of column names
 */
std::pair<std::string,std::string> columnNamesForTransformation(enum Transformation t);

/** transforms a vector of data */
void GenoUtility_transformData(std::vector<double> &aVals,
                               std::vector<double> &bVals,
                               Transformation m_Transform, 
                               double m_K);

/**
 * Contrast Centers Stretch. In 2007 this is the current favorite for
 * algorithms, scales values between -1 and 1.
 * \f$ X = asinh(K * (A-B)/(A+B)) / asinh(K) \f$ <br>
 * \f$ Y = log_2(A + B) \f$ <br>
 *
 * @param a - Value (usually summarized intensity) from A allele.
 * @param b - Value (usually summarized intensity) from B allele.
 */
void ContrastCentersStretch(double K, double a, double b, double &x, double &y);

/** 
 * Contrast Extremes Stretch. 
 * \f$ X = sinh(K * (A-B)/(A+B)) / sinh(K) \f$ <br> 
 * \f$ Y = log_2(A + B) \f$ <br> 
 * 
 * @param K -
 * @param a - Value (usually summarized intensity) from A allele.
 * @param b - Value (usually summarized intensity) from B allele.
 * @param x -
 * @param y -
 */
void ContrastExtremesStretch(double K, double a, double b, double &x, double &y);

/** 
 * Calculate the median PM values for the A and B alleles given data
 * in cel file.
 * 
 * @param cel - Cel file of data.
 * @param ps - ProbeSet for determining A and B alleles.
 * @param Amedian - Filled in with median PM A value.
 * @param Bmedian - Filled in with median PM B value.
 * 
 * @return 
 */
bool alleleMedians(affymetrix_fusion_io::FusionCELData *cel, 
                   const ProbeSet *ps, 
                   float &Amedian, float &Bmedian);

bool probesetMinMax(affymetrix_fusion_io::FusionCELData *cel, 
		  const ProbeSet *ps, 
		  float &Min, float &Max);


#endif /* GenoUtility.h */
