////////////////////////////////////////////////////////////////
//
// Copyright (C) 2005 Affymetrix, Inc.
//
// This program is free software; you can redistribute it and/or modify 
// it under the terms of the GNU General Public License (version 2) as 
// published by the Free Software Foundation.
// 
// This program is distributed in the hope that it will be useful, 
// but WITHOUT ANY WARRANTY; without even the implied warranty of 
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License 
// along with this program;if not, write to the 
// 
// Free Software Foundation, Inc., 
// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
////////////////////////////////////////////////////////////////

/**
 * @file   GenoUtility.cpp
 * @author Earl Hubbell
 * @date   Aug 2 2006
 *
 */

//
#include "chipstream/GenoUtility.h"
//
#include "chipstream/QuantMethodFactory.h"
//
#include "file/TsvFile/TsvFile.h"
#include "util/Convert.h"
#include "util/Fs.h"
#include "util/Util.h"
#include "util/Verbose.h"

using namespace affx;

/**
 * This is the engine that takes data and transforms it into clustering spaces
 *
 * @param aVal - a allele probe summary
 * @param bVal - b allele probe summary
 * @param trans - transformation of data
 * @param K - stretching parameter
 * @param xVal - output difference of a vs b, transformed
 * @param yVal - output total amount of stuff, transformed
 */
void valueForTransformation(double aVal, double bVal, enum Transformation trans,
                                         double K, double &xVal, double &yVal) {
  double c = 0.001;
  double denom = 0;
  switch (trans) {
  case MvA: // Minus vs Average
    if(aVal == 0) aVal = c;
    if(bVal == 0) bVal = c;
	//note: reversed to be consistent
	// xVal always contains comparison between alleles
    yVal = (log2(bVal) + log2(aVal)) / 2;
    xVal = log2(aVal) - log2(bVal);
    break;
  case RvT: // R vs Theta (polar)
    // Check to make sure we're not got to take log of 0
    denom = bVal;
    if(bVal == 0) bVal = c;
	// center "Theta" at zero
    xVal = atan(aVal/ denom)-0.7853982;
    yVal = log( sqrt((aVal * aVal) + (bVal * bVal) + c) );
    break;
  case  CES:
    ContrastExtremesStretch(K, aVal, bVal, xVal, yVal);
    break;
  case CCS:
    ContrastCentersStretch(K, aVal, bVal, xVal, yVal);
    break;
  default:
    Err::errAbort("GenoUtility: valueforTransformation Don't recognize transformation type: " + ToStr(trans));
  }
}

/**
 * Convert a (text insensitive) text repesentation of a transformation into
 * the enumration.
 * @param s - string specifying transformation.
 * @return - Enumeration version of transformation.
 */
enum Transformation transformationForString(const std::string& str) {
  std::string lowerS = Util::downcaseString(str);

  if(lowerS == "mva")
    return MvA;
  else if(lowerS == "rvt")
    return RvT;
  else if(lowerS == "ssf" || lowerS == "ces")
    return CES;
  else if(lowerS == "assf" || lowerS == "ccs")
    return CCS;
  else
    Err::errAbort("GenoUtility::transformationForString() - Don't recognize transformation: " + str);
  return MvA;
}

/**
 * Convert a transformation enum to string representation
 * @param t - tranformation enum value.
 * @return - text description of enumeration.
 */
std::string stringForTransformation(enum Transformation t) {
  switch(t) {
  case MvA :
    return "MvA";
    break;
  case RvT :
    return "RvT";
    break;
  case CES :
    return "CES";
    break;
  case CCS:
    return "CCS";
    break;
  default:
    Err::errAbort("GenoUtility::stringForTransformation() - Don't recognize type: " + ToStr(t));
  }
  Err::errAbort("GenoUtility::stringForTransformation() - Should never reach this point.");
  return "";
}

/**
 * Return the calumn names for the values generated by a given transformation
 * @param t - tranformation enum value.
 * @return - a pair of column names
 */
std::pair<std::string,std::string> columnNamesForTransformation(enum Transformation t) {
  switch(t) {
  case MvA :
    return std::pair<std::string,std::string>("Log Ratio","Strength");
    break;
  case RvT :
    return std::pair<std::string,std::string>("R","Theta");
    break;
  case CES :
    return std::pair<std::string,std::string>("Contrast","Strength");
    break;
  case CCS:
    return std::pair<std::string,std::string>("Contrast","Strength");
    break;
  default:
    Err::errAbort("GenoUtility::columnNamesForTransformation() - Don't recognize type: " + ToStr(t));
  }
  Err::errAbort("GenoUtility::columnNamesForTransformation() - Should never reach this point.");
  return std::pair<std::string,std::string>("","");
}

/** transform the data vector */
void GenoUtility_transformData(std::vector<double> &aVals,
                               std::vector<double> &bVals,
                               Transformation m_Transform,
                               double m_K)
{
    assert(aVals.size() == bVals.size());
    double x = 0, y = 0;
    for(unsigned int i = 0; i < aVals.size(); i++) {
      valueForTransformation(aVals[i], bVals[i], m_Transform, m_K, x, y);
      aVals[i] = x;
      bVals[i] = y;
    }
  }

/**
 * Contrast Centers Stretch. In 2007 this is the current favorite for
 * algorithms, scales values between -1 and 1.
 * \f$ X = asinh(K * (A-B)/(A+B)) / asinh(K) \f$ <br>
 * \f$ Y = log_2(A + B) \f$ <br>
 *
 * @param K -
 * @param a - Value (usually summarized intensity) from A allele.
 * @param b - Value (usually summarized intensity) from B allele.
 * @param x -
 * @param y -
 */
void ContrastCentersStretch(double K, double a, double b, double &x, double &y) {
  double denom = 0;
  double r = 0.0;
  denom = b + a;
  if(denom == 0) {
    Err::errAbort("GenoUtility::ContrastCentersStretch() - Can't have zero sum signal.");
  }
  r = K * (a - b)/denom;
  r = log(r + sqrt(r*r+1));
  x = r / log(K + sqrt(K*K+1));
  y = log2(denom);
}

/**
 * Contrast Extremes Stretch.
 * \f$ X = sinh(K * (A-B)/(A+B)) / sinh(K) \f$ <br>
 * \f$ Y = log_2(A + B) \f$ <br>
 *
 * @param K -
 * @param a - Value (usually summarized intensity) from A allele.
 * @param b - Value (usually summarized intensity) from B allele.
 * @param x -
 * @param y -
 */
void ContrastExtremesStretch(double K, double a, double b, double &x, double &y) {
  double denom = 0;
  denom = b + a;
  if(denom == 0) {
    Err::errAbort("GenoUtility::ContrastExtremesStretch() - Can't have zero sum signal.");
  }
  x = sinh( K * (a - b)/denom) / sinh(K);
  y = log2(denom);
}

/**
 * Calculate the median PM values for the A and B alleles given data
 * in cel file.
 *
 * @param cel - Cel file of data.
 * @param ps - ProbeSet for determining A and B alleles.
 * @param Amedian - Filled in with median PM A value.
 * @param Bmedian - Filled in with median PM B value.
 *
 * @return
 */
bool alleleMedians(affymetrix_fusion_io::FusionCELData *cel, const ProbeSet *ps,
                                      float &Amedian, float &Bmedian) {
  vector<float> AValues, BValues;
  /* Genotype probe sets can have either 2 or 4 groups, for each
     type the even (0,2) are A alleles and odd (1,3) are B allele.s */
  if(ps->numGroups != 2 && ps->numGroups != 4) {
    return false;
  }

  if (ps->psType != ProbeSet::GenoType)
      return false;

  int groupOffset = 0; // atoms are stored in blocks for each allele, keep track of which block we're in.
  for(unsigned int groupIx = 0; groupIx < ps->numGroups; groupIx++) {
	/* Probe belongs to the A allele, put atoms in that probeset. */
	if(groupIx == ProbeSet::Aforward || groupIx == ProbeSet::Areverse) {
	  for(unsigned int atomIx = groupOffset; atomIx < ps->atomsPerGroup[groupIx] + groupOffset; atomIx++) {
        Atom *A = ps->atoms[atomIx];
        for(int probeIx = 0; probeIx < A->probes.size(); probeIx++) {
            Probe *p = A->probes[probeIx];
            if(Probe::isPm(*p)) {
                float intensity = cel->GetIntensity(p->id);
                AValues.push_back(intensity);
            }
        }
	  }
	}
	/* Probe belongs to the B allele, put atoms in that probeset. */
	else if(groupIx == ProbeSet::Bforward || groupIx == ProbeSet::Breverse) {
	  for(unsigned int atomIx = groupOffset; atomIx < ps->atomsPerGroup[groupIx] + groupOffset; atomIx++) {
        Atom *A = ps->atoms[atomIx];
        for(int probeIx = 0; probeIx < A->probes.size(); probeIx++) {
            Probe *p = A->probes[probeIx];
            if(Probe::isPm(*p)) {
                float intensity = cel->GetIntensity(p->id);
                BValues.push_back(intensity);
            }
        }
	  }
	}
	/* Uh-oh, if it doesn't belong to A and it doesn't belong to B we're going to complain. */
	else {
	  return false;
	}
	groupOffset += ps->atomsPerGroup[groupIx];
  }

  if(AValues.empty() || BValues.empty())
      return false;

  Amedian = median_in_place(AValues.begin(), AValues.end());
  Bmedian = median_in_place(BValues.begin(), BValues.end());
  return true;
}

/* mimic Eric's code */
bool probesetMean(affymetrix_fusion_io::FusionCELData *cel, const ProbeSet *ps, 
		  float &mean) {
  vector<float> Values;
  /* Genotype probe sets can have either 2 or 4 groups, for each
     type the even (0,2) are A alleles and odd (1,3) are B allele.s */
  //if(ps->numGroups != 2 && ps->numGroups != 4) {
  //  return false;
  //}
  
  //Verbose::out(4, "there are "+ ToStr(ps->numGroups) + " groups");
  Err::check(ps->numGroups == 1, 
	     "alleleMinMax() - Thought for Falcon, there should just be 1 group.");
  int atomsPer = ps->atoms.size();
  //Verbose::out(4, "atoms per group is "+ ToStr(atomsPer));
  /* Each block will have atomsPer atoms in there. */
  for(int atomIx = 0; atomIx < atomsPer; atomIx++) {
    Atom *A = ps->atoms[atomIx];
    for(int probeIx = 0; probeIx < A->probes.size(); probeIx++) {
      Probe *p = A->probes[probeIx];
      if(Probe::isPm(*p)) {
	float intensity = cel->GetIntensity(p->id);
	Values.push_back(intensity);
      }
    }
    
  }
  
  if(Values.empty()) 
    Err::errAbort("alleleMinMax() - Empty value vectors in probeset: " + ToStr(ps->name));
   mean = average(Values.begin(), Values.end());
  
  return true;
}


bool probesetStd(affymetrix_fusion_io::FusionCELData *cel, const ProbeSet *ps, 
		  float &std) {
  vector<float> Values;
  /* Genotype probe sets can have either 2 or 4 groups, for each
     type the even (0,2) are A alleles and odd (1,3) are B allele.s */
  //if(ps->numGroups != 2 && ps->numGroups != 4) {
  //  return false;
  //}
  
  //Verbose::out(4, "there are "+ ToStr(ps->numGroups) + " groups");
  Err::check(ps->numGroups == 1, 
	     "alleleMinMax() - Thought for Falcon, there should just be 1 group.");
  int atomsPer = ps->atoms.size();
  for(int atomIx = 0; atomIx < atomsPer; atomIx++) {
    Atom *A = ps->atoms[atomIx];
    for(int probeIx = 0; probeIx < A->probes.size(); probeIx++) {
      Probe *p = A->probes[probeIx];
      if(Probe::isPm(*p)) {
	float intensity = cel->GetIntensity(p->id);
	Values.push_back(intensity);
      }
    }
    
  }
  
  if(Values.empty()) 
    Err::errAbort("alleleMinMax() - Empty value vectors in probeset: " + ToStr(ps->name));
   std = unbiased_stddev(Values.begin(), Values.end());
  return true;
}


bool probesetMeanStd(affymetrix_fusion_io::FusionCELData *cel, const ProbeSet *ps, 
		     float &mean, float &std) {
  vector<float> Values;
  /* Genotype probe sets can have either 2 or 4 groups, for each
     type the even (0,2) are A alleles and odd (1,3) are B allele.s */
  //if(ps->numGroups != 2 && ps->numGroups != 4) {
  //  return false;
  //}
  
  //Verbose::out(4, "there are "+ ToStr(ps->numGroups) + " groups");
  Err::check(ps->numGroups == 1, 
	     "alleleMinMax() - Thought for Falcon, there should just be 1 group.");
  int atomsPer = ps->atoms.size();
  for(int atomIx = 0; atomIx < atomsPer; atomIx++) {
    Atom *A = ps->atoms[atomIx];
    for(int probeIx = 0; probeIx < A->probes.size(); probeIx++) {
      Probe *p = A->probes[probeIx];
      if(Probe::isPm(*p)) {
	float intensity = cel->GetIntensity(p->id);
	Values.push_back(intensity);
      }
    }
    
  }
  
  if(Values.empty()) 
    Err::errAbort("alleleMinMax() - Empty value vectors in probeset: " + ToStr(ps->name));
  std = unbiased_stddev(Values.begin(), Values.end());
  mean = average(Values.begin(), Values.end());
  return true;
}




/**
 * Calculate the natural log ratio for two probeset signal
 *
 *@para signalA -- e.x. signal channel 
 *@para signalB -- e.x. background channel
 *
 */
double logRatio(double sigA, double sigB){
  sigB = sigB <=0? 1 : sigB;
  return(log(sigA/sigB));
}


/** 
 * Open and read a target distribution from a text file. Must have a column
 * called 'intensities' with distribution quantiles sorted from highest to 
 * lowest.
 * 
 * @param fileName - text file containing column of quantiles.
 * @para sketch - vector that stores the sketch.
 */

void  loadTargetSketchFromFile(const char *fileName, std::vector<float> &sketch) {
  TsvFile tsv;
  double intensity;
  // file ok
  int rc = tsv.open(fileName);
  assert(rc==TSV_OK);
  //
  tsv.bind(0,"intensities",&intensity);
  assert(tsv.cname2cidx(0,"intensities")>=0);

  sketch.clear();
  while (tsv.nextLevel(0)==TSV_OK) {
    sketch.push_back(intensity);
  }
  tsv.close();
}


/** 
 * Read in the precomputed genotypes from a tab delimited file. Must
 * be a column for each Celfile with same header name as celfile and an row
 * for every snp to be analyzed. There can be extra columns and order of columns
 * is not important as the resulting order will be the same as the colNames
 * vector. Steal from GenoSeedTxt. 
 * @param fileName - text file containing the known genotype calls
 * @para colNames - the name of samples. 
 * @para knownCalls -- the map that store knownCalls infomation for each SNP.
 */
void loadSNPHints(std::string fileName, 
 		  std::vector<std::string> &colNames,
		  std::map<std::string,std::vector<affx::GType> > &knownCalls) {
  affx::TsvFile tsv;
  vector<GType> calls(colNames.size());
  vector<int> intCalls(colNames.size());
  vector<uint32_t> hetChrxCalls(colNames.size(), 0);
  vector<uint32_t> hetChrxPossibleCalls(colNames.size(), 0);
  vector<uint32_t> madeCalls(colNames.size(), 0);
  vector<uint32_t> possibleCalls(colNames.size(), 0);
  
  string probeset;

  /* Expecting one column for the id and one for each cel file. */
  tsv.bind(0,"probeset_id", &probeset, TSV_BIND_REQUIRED);
  for(uint32_t i = 0; i < colNames.size(); i++) {
    string s = Fs::basename(colNames[i]);
    tsv.bind(0, s.c_str(), &intCalls[i], TSV_BIND_REQUIRED);
  }

  Verbose::out(1, "Reading in hints genotypes from " + ToStr(fileName));

  if(tsv.open(fileName) != TSV_OK) {
    Err::errAbort("Couldn't open file: " + ToStr(fileName) + " to read.");
  }

  knownCalls.clear();

  while(tsv.nextLevel(0) == TSV_OK) {
    if(knownCalls.find(probeset) != knownCalls.end()) {
      Err::errAbort("Found probeset: " + probeset + " specified multiple times in file: " + ToStr(fileName));
    }
    
    /* convert to char as tsv doesn't bind char. */
    for(uint32_t i = 0; i < intCalls.size(); i++) {
      // this converts -1 to NN, 0 to AA, 1 to AB, 2 to BB
      calls[i] = GType_from_int(intCalls[i]);
    }
    knownCalls[probeset] = calls; // contain no calls for a SNP.
  }
  tsv.close();
}


bool probesetMinMax(affymetrix_fusion_io::FusionCELData *cel, const ProbeSet *ps, 
		  float &Min, float &Max) {
  Min = -1;
  Max = -1;
  vector<float> Values;
  /* Genotype probe sets can have either 2 or 4 groups, for each
     type the even (0,2) are A alleles and odd (1,3) are B allele.s */
  //if(ps->numGroups != 2 && ps->numGroups != 4) {
  //  return false;
  //}
  
  //Verbose::out(4, "there are "+ ToStr(ps->numGroups) + " groups");
  Err::check(ps->numGroups == 1, 
	     "alleleMinMax() - Thought for Falcon, there should just be 1 group.");
  //for(int psIx = 0; psIx < ps->numGroups - 1; psIx ++) {
    //Err::check(ps->atomsPerGroup[psIx] == ps->atomsPerGroup[psIx+1], 
    //"alleleMinMax() - Thought groups were symmetrical.");
  int atomsPer = ps->atoms.size();
  //Verbose::out(4, "atoms per group is "+ ToStr(atomsPer));
  /* Each block will have atomsPer atoms in there. */
  for(int atomIx = 0; atomIx < atomsPer; atomIx++) {
    Atom *A = ps->atoms[atomIx];
    for(int probeIx = 0; probeIx < A->probes.size(); probeIx++) {
      Probe *p = A->probes[probeIx];
      if(Probe::isPm(*p)) {
	float intensity = cel->GetIntensity(p->id);
	Values.push_back(intensity);
	if (Min == -1 && Max == -1){
	  Min = intensity;
	  Max = intensity;
	}
	else{
	  if (intensity > Max) Max = intensity;
	  if (intensity < Min) Min = intensity;
	}
      }
    }
    
  }
  
  //}
  if(Values.empty()) 
    Err::errAbort("alleleMinMax() - Empty value vectors in probeset: " + ToStr(ps->name));
  //float median = median_in_place(Values.begin(), Values.end());
  
  return true;
}
