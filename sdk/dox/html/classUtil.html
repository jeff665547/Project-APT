<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: Util Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>Util Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Util" -->
<p><a class="el" href="classUtil.html" title="Util.">Util</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Util_8h_source.html">Util.h</a>&gt;</code></p>

<p><a href="classUtil-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtil_1_1ltstr.html">ltstr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison object for use in map for char *.  <a href="structUtil_1_1ltstr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtil_1_1ltstring.html">ltstring</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>StaticMem</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a3f73433908596efd3e64a02706a6e75a">downcaseString_inplace</a> (std::string &amp;str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the string all lowercase.  <a href="#a3f73433908596efd3e64a02706a6e75a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#ab73e26f5a353284899216123a494e3bf">downcaseString</a> (const std::string &amp;str_orig)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy and downcase a 8bit string. ///.  <a href="#ab73e26f5a353284899216123a494e3bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a8125745828794db4e98a63862a1daf0f">upcaseString_inplace</a> (std::string &amp;str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the string all uppercase.  <a href="#a8125745828794db4e98a63862a1daf0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a7c0b8f3bada1532e2939e3f57388360d">upcaseString</a> (const std::string &amp;str_orig)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy and upcase a 8bit string. ///.  <a href="#a7c0b8f3bada1532e2939e3f57388360d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#accf4f30492f3726aac3197a37b3f77cc">getTimeStamp</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a timestamp string.  <a href="#accf4f30492f3726aac3197a37b3f77cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1eefe5a6e76298c2df9dd6d07a36a1a7"></a><!-- doxytag: member="Util::round" ref="a1eefe5a6e76298c2df9dd6d07a36a1a7" args="(double x)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a1eefe5a6e76298c2df9dd6d07a36a1a7">round</a> (double x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Some older compilers (solaris) don't have a round function. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a508b7aff9569ed929945d0d37eca384e">cloneString</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a copy of a string.  <a href="#a508b7aff9569ed929945d0d37eca384e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#ab074b74806364312a75e60933cd6d3e7">stringEndsWith</a> (const std::string &amp;str, const std::string &amp;end)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does the string end with the other string?  <a href="#ab074b74806364312a75e60933cd6d3e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a3f9b6bdba823e1f1162ffb6c3202f1d3">endsWithStr</a> (const std::string &amp;str, const std::string &amp;ending)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check to see if STR ends with ENDING. ///.  <a href="#a3f9b6bdba823e1f1162ffb6c3202f1d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a38e0b2532b9cc8b070efb0f472f42c35">endsWithStr</a> (const std::string &amp;str, const std::string &amp;ending, int posFromEnd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if STR ends with ENDING ignoring the last POSFROMEND chars. /// Basicly the POSFROMEND acts as a wildcard "." at the end of the string. ///.  <a href="#a38e0b2532b9cc8b070efb0f472f42c35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a21a08a463a4b0b321b58979b0404e017">chompLastIfSep</a> (std::string &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chop off the last character if it is a path separator.  <a href="#a21a08a463a4b0b321b58979b0404e017"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a1cc2d9cdd9ce481d8d9f8d0737a4292f">chopSuffix</a> (const std::string &amp;s, char d= '.')</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chop the last suffix (as defined by '.  <a href="#a1cc2d9cdd9ce481d8d9f8d0737a4292f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#ac0aefd5694432916da36f4f2cfe8bd76">chopString</a> (const std::string &amp;s, const char delim, std::vector&lt; std::string &gt; &amp;words)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chop up a string into a vector of words.  <a href="#ac0aefd5694432916da36f4f2cfe8bd76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a297d2016086e9127f513c77e48f98169">chopString</a> (const std::string &amp;s, const char *delims, std::vector&lt; std::string &gt; &amp;words)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chop up a string into a vector of words.  <a href="#a297d2016086e9127f513c77e48f98169"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#aa912567f9cdde6941ba305f4278b5828">trimString</a> (std::string &amp;s, const char *whitespace=&quot; \r\n\t&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cut off any preceding and trailing white space.  <a href="#aa912567f9cdde6941ba305f4278b5828"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#ae9d62d301c938a9185d03ade3cf4a757">changeEnd</a> (std::string &amp;str, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the end of a string ///.  <a href="#ae9d62d301c938a9185d03ade3cf4a757"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#acda0844fbd5d927f78b8736975eab66a">changeEnd</a> (std::vector&lt; std::string &gt; &amp;str_vec, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the endings of a vector of strings. ///.  <a href="#acda0844fbd5d927f78b8736975eab66a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a0d2126d2d7027b17fdcba5f94e18567e">sameString</a> (const std::string &amp;s1, const std::string &amp;s2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check to see if two strings are the same.  <a href="#a0d2126d2d7027b17fdcba5f94e18567e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a81d133cd77d241447c255476d65c690f">matrixDifferences</a> (const std::string &amp;targetFile, const std::string &amp;queryFile, int colSkip, int rowSkip, double epsilon, bool printMismatch, bool matchRows, double fraction=0.0, int printMismatchMax=-1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check each entry in two matrices to see if they are the same.  <a href="#a81d133cd77d241447c255476d65c690f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#af48d8be413de4e28b620e58e9f1d5ec1">subChar</a> (std::string &amp;s, char from, char to)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace the from character with the to character for all instances in string supplied.  <a href="#af48d8be413de4e28b620e58e9f1d5ec1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a4f3f450e9baf79936a220deba4716f9d">replaceString</a> (std::string &amp;s, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replace the from string with the to string for all instances in string supplied.  <a href="#a4f3f450e9baf79936a220deba4716f9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab3925e1057c93124acb24fd2217eaec"></a><!-- doxytag: member="Util::breakByString" ref="aab3925e1057c93124acb24fd2217eaec" args="(const std::string &amp;s, const std::string &amp;delim, std::vector&lt; std::string &gt; &amp;words)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>breakByString</b> (const std::string &amp;s, const std::string &amp;delim, std::vector&lt; std::string &gt; &amp;words)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b07bb4e2d37ff95f9e3917308eac68f"></a><!-- doxytag: member="Util::removeChar" ref="a9b07bb4e2d37ff95f9e3917308eac68f" args="(std::string &amp;s, char character)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>removeChar</b> (std::string &amp;s, char character)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7deea35598bb4438637b912d8eb2be3"></a><!-- doxytag: member="Util::is32Bit" ref="ac7deea35598bb4438637b912d8eb2be3" args="()" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>is32Bit</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a425642d78784387daa25abdca75ecd17">schrageRandom</a> (int32_t *ix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schrage's algorithm for generating random numbers in 32 bits.  <a href="#a425642d78784387daa25abdca75ecd17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb942f6f677a0f31de6ba8e2ef77f951"></a><!-- doxytag: member="Util::asMB" ref="acb942f6f677a0f31de6ba8e2ef77f951" args="(uint64_t x)" -->
static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>asMB</b> (uint64_t x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#abd09dcbcbe5d0dc6714bf008005fe0b7">memInfo</a> (uint64_t &amp;free, uint64_t &amp;total, uint64_t &amp;swapAvail, uint64_t &amp;memAvail, bool cap32bit=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the free and total amount of memory in bytes on this machine.  <a href="#abd09dcbcbe5d0dc6714bf008005fe0b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a210269ffd3328426b3598fbb7eb3893b"></a><!-- doxytag: member="Util::getMemFreeAtStart" ref="a210269ffd3328426b3598fbb7eb3893b" args="()" -->
static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getMemFreeAtStart</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac88243cf7300b17d7ed4a8853ef84b15"></a><!-- doxytag: member="Util::getMemFreeAtBlock" ref="ac88243cf7300b17d7ed4a8853ef84b15" args="()" -->
static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getMemFreeAtBlock</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0babcf1f4d1afa0fc46975782b0bda94"></a><!-- doxytag: member="Util::pushMemFreeAtStart" ref="a0babcf1f4d1afa0fc46975782b0bda94" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>pushMemFreeAtStart</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9acb101ef69d9b05f53f6eb7f411ab14"></a><!-- doxytag: member="Util::popMemFreeAtStart" ref="a9acb101ef69d9b05f53f6eb7f411ab14" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>popMemFreeAtStart</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a772cd3b6f20be1e6082a800bb38d5e08">nextWhiteSpace</a> (const char *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to the next character that is white space or NULL if none found.  <a href="#a772cd3b6f20be1e6082a800bb38d5e08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a19c53e9ca0edb65d4a32717b509ba857">printStringWidth</a> (std::ostream &amp;out, const std::string &amp;str, int prefix, int currentPos, int maxWidth=70)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classPrint.html">Print</a> a string wrapping at max width from the current position.  <a href="#a19c53e9ca0edb65d4a32717b509ba857"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtil.html#a66b3f27deb315aab108936d0830c6991">isFinite</a> (double x)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for different version of isnan() on different systems.  <a href="#a66b3f27deb315aab108936d0830c6991"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc184e95d822fc945c375557c5411d07"></a><!-- doxytag: member="Util::PrintTextClassTitle" ref="abc184e95d822fc945c375557c5411d07" args="(const std::string &amp;className)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PrintTextClassTitle</b> (const std::string &amp;className)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1ac43f8bd1cf5636c2febb310d92df8"></a><!-- doxytag: member="Util::PrintTextFunctionTitle" ref="ae1ac43f8bd1cf5636c2febb310d92df8" args="(const std::string &amp;className, const std::string &amp;functionName)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PrintTextFunctionTitle</b> (const std::string &amp;className, const std::string &amp;functionName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6448a37e6cea364722de61e8bdd3c47"></a><!-- doxytag: member="Util::addPrefixSuffix" ref="ac6448a37e6cea364722de61e8bdd3c47" args="(std::vector&lt; std::string &gt; middle, const std::string &amp;prefix, const std::string &amp;suffix)" -->
static std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>addPrefixSuffix</b> (std::vector&lt; std::string &gt; middle, const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68ea8e5614fff3a4763d22e05ca888e9"></a><!-- doxytag: member="Util::addPrefixSuffix" ref="a68ea8e5614fff3a4763d22e05ca888e9" args="(const char *middle[], const std::string &amp;prefix, const std::string &amp;suffix)" -->
static std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>addPrefixSuffix</b> (const char *middle[], const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a879b092ca9a44862b095d51a59a5d2b9"></a><!-- doxytag: member="Util::addPrefixSuffix" ref="a879b092ca9a44862b095d51a59a5d2b9" args="(const char *middle[], int size, const std::string &amp;prefix, const std::string &amp;suffix)" -->
static std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>addPrefixSuffix</b> (const char *middle[], int size, const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac08761abc8cec842124fdf6134d12cef"></a><!-- doxytag: member="Util::listToVector" ref="ac08761abc8cec842124fdf6134d12cef" args="(const char *in[], int size)" -->
static std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>listToVector</b> (const char *in[], int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a909e5f3fdc1b56be8d5f4b9ce59e9f33"></a><!-- doxytag: member="Util::listToVector" ref="a909e5f3fdc1b56be8d5f4b9ce59e9f33" args="(const char *in[])" -->
static std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>listToVector</b> (const char *in[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ab70741c21394edb5d780f3454bad95"></a><!-- doxytag: member="Util::addPrefixSuffix" ref="a5ab70741c21394edb5d780f3454bad95" args="(const char *middle[], const std::string &amp;prefix)" -->
static std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>addPrefixSuffix</b> (const char *middle[], const std::string &amp;prefix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a189158b112beb10593f5e803392d3ec6"></a><!-- doxytag: member="Util::addPrefixSuffix" ref="a189158b112beb10593f5e803392d3ec6" args="(std::string middle[], const std::string &amp;prefix, const std::string &amp;suffix)" -->
static std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>addPrefixSuffix</b> (std::string middle[], const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99e3e4d9cfc6788b7cf21926622ed569"></a><!-- doxytag: member="Util::addPrefixSuffix" ref="a99e3e4d9cfc6788b7cf21926622ed569" args="(std::string middle[], int size, const std::string &amp;prefix, const std::string &amp;suffix)" -->
static std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>addPrefixSuffix</b> (std::string middle[], int size, const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38f4ce1cba7450ec56b5d96fb11b75b9"></a><!-- doxytag: member="Util::listToVector" ref="a38f4ce1cba7450ec56b5d96fb11b75b9" args="(std::string in[])" -->
static std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>listToVector</b> (std::string in[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a057e6e01e2d034431548368ea2a82580"></a><!-- doxytag: member="Util::listToVector" ref="a057e6e01e2d034431548368ea2a82580" args="(std::string in[], int size)" -->
static std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>listToVector</b> (std::string in[], int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c7bcb4dafd24bc9c9aff2744f10d692"></a><!-- doxytag: member="Util::joinVectorString" ref="a1c7bcb4dafd24bc9c9aff2744f10d692" args="(std::vector&lt; std::string &gt; toJoin, const std::string &amp;sep)" -->
static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>joinVectorString</b> (std::vector&lt; std::string &gt; toJoin, const std::string &amp;sep)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c862e88eab3bbb0610702da59af1775"></a><!-- doxytag: member="Util::escapeString" ref="a4c862e88eab3bbb0610702da59af1775" args="(const std::string &amp;s, char c, char escape='\\')" -->
static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>escapeString</b> (const std::string &amp;s, char c, char escape='\\')</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29805eaef3cf6927099814b699afa6dc"></a><!-- doxytag: member="Util::deEscapeString" ref="a29805eaef3cf6927099814b699afa6dc" args="(std::string &amp;s, char escape='\\')" -->
static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>deEscapeString</b> (std::string &amp;s, char escape='\\')</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c17631ec24ea786f63ec0599ccea3bb"></a><!-- doxytag: member="Util::toWString" ref="a1c17631ec24ea786f63ec0599ccea3bb" args="(const std::string &amp;src)" -->
static std::wstring&nbsp;</td><td class="memItemRight" valign="bottom"><b>toWString</b> (const std::string &amp;src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6372407731162e097168d74f44a94cc2"></a><!-- doxytag: member="Util::toString" ref="a6372407731162e097168d74f44a94cc2" args="(const std::wstring &amp;src)" -->
static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>toString</b> (const std::wstring &amp;src)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classUtil.html" title="Util.">Util</a>. </p>
<p>Utility functions for memory, etc. </p>

<p>Definition at line <a class="el" href="Util_8h_source.html#l00099">99</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae9d62d301c938a9185d03ade3cf4a757"></a><!-- doxytag: member="Util::changeEnd" ref="ae9d62d301c938a9185d03ade3cf4a757" args="(std::string &amp;str, const std::string &amp;from, const std::string &amp;to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::changeEnd </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the end of a string ///. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>string to change /// </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>string to change from /// </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>string to change to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00872">872</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>Referenced by <a class="el" href="Util_8cpp_source.html#l00879">changeEnd()</a>, and <a class="el" href="SpecialSnps_8cpp_source.html#l00036">readCopyNumberFile()</a>.</p>

</div>
</div>
<a class="anchor" id="acda0844fbd5d927f78b8736975eab66a"></a><!-- doxytag: member="Util::changeEnd" ref="acda0844fbd5d927f78b8736975eab66a" args="(std::vector&lt; std::string &gt; &amp;str_vec, const std::string &amp;from, const std::string &amp;to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::changeEnd </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the endings of a vector of strings. ///. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str_vec</em>&nbsp;</td><td>vector to change /// </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>string to change from /// </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>string to change to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00879">879</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>References <a class="el" href="Util_8cpp_source.html#l00872">changeEnd()</a>.</p>

</div>
</div>
<a class="anchor" id="a21a08a463a4b0b321b58979b0404e017"></a><!-- doxytag: member="Util::chompLastIfSep" ref="a21a08a463a4b0b321b58979b0404e017" args="(std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::chompLastIfSep </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Chop off the last character if it is a path separator. </p>
<p>windows stat() can't handle having it there. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- string to have '/' or '\' chopped off if last. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00192">192</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>References <a class="el" href="Fs_8cpp_source.html#l00264">Fs::osPathSep()</a>.</p>

<p>Referenced by <a class="el" href="multiChannelExample_8cpp_source.html#l00176">fillInOptions()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0aefd5694432916da36f4f2cfe8bd76"></a><!-- doxytag: member="Util::chopString" ref="ac0aefd5694432916da36f4f2cfe8bd76" args="(const std::string &amp;s, const char delim, std::vector&lt; std::string &gt; &amp;words)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::chopString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>words</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Chop up a string into a vector of words. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- string of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>- delimiter to split on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>words</em>&nbsp;</td><td>- vector to put words into, will be cleared then filled.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- string of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>- delimiter to split on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>words</em>&nbsp;</td><td>- vector to put words into, will be cleared then filled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000316">Todo:</a></b></dt><dd>shouldnt this be "split"? </dd></dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00258">258</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>Referenced by <a class="el" href="QuantBRLMM_8cpp_source.html#l00655">QuantBRLMM::clusterModelFromStrings()</a>, <a class="el" href="QuantBRLMM_8cpp_source.html#l00605">QuantBRLMM::clusterPriorFromStrings()</a>, <a class="el" href="AnalysisStreamFactory_8cpp_source.html#l00118">AnalysisStreamFactory::constructAnalysisStream()</a>, <a class="el" href="AnalysisStreamFactory_8cpp_source.html#l00261">AnalysisStreamFactory::constructExpressionAnalysisStages()</a>, <a class="el" href="AnalysisStreamFactory_8cpp_source.html#l00184">AnalysisStreamFactory::constructExpressionAnalysisStream()</a>, <a class="el" href="AnalysisStreamFactory_8cpp_source.html#l00340">AnalysisStreamFactory::constructGTypeAnalysisStream()</a>, <a class="el" href="Fs_8cpp_source.html#l01472">Fs::findLibFile()</a>, <a class="el" href="MetaProbeset_8cpp_source.html#l00068">MetaProbeset::readMetaProbesetList()</a>, <a class="el" href="QCProbesetOptions_8cpp_source.html#l00052">QCProbesetOptions::readQCCFile()</a>, <a class="el" href="Convert_8cpp_source.html#l00486">Convert::strToDoubleVec()</a>, <a class="el" href="Convert_8cpp_source.html#l00474">Convert::strToIntVec()</a>, and <a class="el" href="Convert_8cpp_source.html#l00549">Convert::strToStrVec()</a>.</p>

</div>
</div>
<a class="anchor" id="a297d2016086e9127f513c77e48f98169"></a><!-- doxytag: member="Util::chopString" ref="a297d2016086e9127f513c77e48f98169" args="(const std::string &amp;s, const char *delims, std::vector&lt; std::string &gt; &amp;words)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::chopString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>words</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Chop up a string into a vector of words. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- string of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delims</em>&nbsp;</td><td>- delimiters to split on. The split will occur at any character</p>
<ul>
<li>among those present in the string. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>words</em>&nbsp;</td><td>- vector to put words into, will be cleared then filled. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00281">281</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1cc2d9cdd9ce481d8d9f8d0737a4292f"></a><!-- doxytag: member="Util::chopSuffix" ref="a1cc2d9cdd9ce481d8d9f8d0737a4292f" args="(const std::string &amp;s, char d= '.')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::chopSuffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>d</em> = <code>'.'</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Chop the last suffix (as defined by '. </p>
<p>') from a string </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-</em>&nbsp;</td><td>string to chop </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-</em>&nbsp;</td><td>delimiter, default '.' </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00203">203</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a508b7aff9569ed929945d0d37eca384e"></a><!-- doxytag: member="Util::cloneString" ref="a508b7aff9569ed929945d0d37eca384e" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * Util::cloneString </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a copy of a string. </p>
<p>Free this with delete [] (or freezArray()) when done. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- c-string to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>char * newly allocated c-string. </dd></dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00122">122</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>Referenced by <a class="el" href="ProbeListFactory_8cpp_source.html#l01010">ProbeListFactory::asProbeSet()</a>, <a class="el" href="multiChannelExample_8cpp_source.html#l00268">callGenotypes()</a>, <a class="el" href="AnalysisStreamExpression_8cpp_source.html#l00173">AnalysisStreamExpression::doAnalysis()</a>, <a class="el" href="QuantGTypeMethod_8cpp_source.html#l00158">QuantGTypeMethod::fillInAlleleProbeSets()</a>, <a class="el" href="MultiChannelHomHiLoCelListener_8cpp_source.html#l00492">MultiChannelHomHiLoCelListener::fillInAlleleProbeSets()</a>, <a class="el" href="apt-cel-extract_8cpp_source.html#l00162">fillInOptions()</a>, <a class="el" href="EngineUtil_8cpp_source.html#l00461">EngineUtil::makePSetNameSubset()</a>, <a class="el" href="AnalysisStreamExpression_8cpp_source.html#l00322">AnalysisStreamExpression::makeSelectProbesetGroup()</a>, <a class="el" href="TableFile_8cpp_source.html#l00106">TableFile::open()</a>, <a class="el" href="ChipLayout_8cpp_source.html#l00718">ChipLayout::openSpf_v3()</a>, <a class="el" href="ChipLayout_8cpp_source.html#l00907">ChipLayout::openSpf_v4()</a>, <a class="el" href="ProbeSet_8h_source.html#l00621">ProbeSetGroup::ProbeSetGroup()</a>, <a class="el" href="MetaProbeset_8cpp_source.html#l00068">MetaProbeset::readMetaProbesetList()</a>, <a class="el" href="ChipLayout_8cpp_source.html#l02226">ChipLayout::readProbeListCdfFileKillList()</a>, <a class="el" href="ChipLayout_8cpp_source.html#l01294">ChipLayout::readProbeListPgfFileKillList()</a>, <a class="el" href="MetaProbeset_8cpp_source.html#l00051">MetaProbeset::readProbesetSubset()</a>, and <a class="el" href="QuantLabelZMulti_8cpp_source.html#l00371">QuantLabelZMulti::SetUpProbeSet()</a>.</p>

</div>
</div>
<a class="anchor" id="ab73e26f5a353284899216123a494e3bf"></a><!-- doxytag: member="Util::downcaseString" ref="ab73e26f5a353284899216123a494e3bf" args="(const std::string &amp;str_orig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Util::downcaseString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str_orig</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy and downcase a 8bit string. ///. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str_orig</em>&nbsp;</td><td>/// </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="Util_8h_source.html#l00114">114</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="EngineUtil_8cpp_source.html#l00205">EngineUtil::checkChipTypeOk()</a>, <a class="el" href="QCAnalysisOptions_8cpp_source.html#l00774">QCAnalysisOptions::readQCAFile()</a>, <a class="el" href="QuantBRLMM_8cpp_source.html#l01452">QuantBRLMM::transformationForString()</a>, and <a class="el" href="GenoUtility_8cpp_source.html#l00090">transformationForString()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f73433908596efd3e64a02706a6e75a"></a><!-- doxytag: member="Util::downcaseString_inplace" ref="a3f73433908596efd3e64a02706a6e75a" args="(std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Util::downcaseString_inplace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make the string all lowercase. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- string to be modified </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8h_source.html#l00106">106</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3f9b6bdba823e1f1162ffb6c3202f1d3"></a><!-- doxytag: member="Util::endsWithStr" ref="a3f9b6bdba823e1f1162ffb6c3202f1d3" args="(const std::string &amp;str, const std::string &amp;ending)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::endsWithStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>ending</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check to see if STR ends with ENDING. ///. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>/// </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ending</em>&nbsp;</td><td>/// </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it does. </dd></dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00182">182</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>Referenced by <a class="el" href="QCProbesetOptions_8cpp_source.html#l00052">QCProbesetOptions::readQCCFile()</a>.</p>

</div>
</div>
<a class="anchor" id="a38e0b2532b9cc8b070efb0f472f42c35"></a><!-- doxytag: member="Util::endsWithStr" ref="a38e0b2532b9cc8b070efb0f472f42c35" args="(const std::string &amp;str, const std::string &amp;ending, int posFromEnd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::endsWithStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>ending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>posFromEnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see if STR ends with ENDING ignoring the last POSFROMEND chars. /// Basicly the POSFROMEND acts as a wildcard "." at the end of the string. ///. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>/// </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ending</em>&nbsp;</td><td>/// </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>posFromEnd</em>&nbsp;</td><td>number /// </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it does </dd></dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00173">173</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="accf4f30492f3726aac3197a37b3f77cc"></a><!-- doxytag: member="Util::getTimeStamp" ref="accf4f30492f3726aac3197a37b3f77cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Util::getTimeStamp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a timestamp string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>- pointer to statically allocated buffer with time. </dd></dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00861">861</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>References <a class="el" href="Err_8h_source.html#l00054">APT_ERR_ASSERT</a>, and <a class="el" href="Util_8h_source.html#l00239">trimString()</a>.</p>

<p>Referenced by <a class="el" href="CNFamilialReporterFamilial_8cpp_source.html#l00230">CNFamilialReporterFamilial::addStandardHeader()</a>, <a class="el" href="MidasConfigureRun_8cpp_source.html#l00417">midasConfigureRun::configure()</a>, <a class="el" href="apt-cel-extract_8cpp_source.html#l00162">fillInOptions()</a>, <a class="el" href="dmet-translation-test_8cpp_source.html#l00493">main()</a>, <a class="el" href="MarkerExperimentReport_8cpp_source.html#l00493">MarkerExperimentReport::open()</a>, <a class="el" href="BaseEngine_8cpp_source.html#l00288">BaseEngine::run()</a>, <a class="el" href="CNReporterCnchp_8cpp_source.html#l00078">CNReporterCnchp::run()</a>, and <a class="el" href="TranslationEngine_8cpp_source.html#l00266">TranslationEngine::runImp()</a>.</p>

</div>
</div>
<a class="anchor" id="a66b3f27deb315aab108936d0830c6991"></a><!-- doxytag: member="Util::isFinite" ref="a66b3f27deb315aab108936d0830c6991" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::isFinite </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for different version of isnan() on different systems. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>- number to be checked for NaN or INF </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- true if x is finite (-INF &lt; x &amp;&amp; x &lt; +INF &amp;&amp; x != nan), false otherwise </dd></dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00851">851</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>Referenced by <a class="el" href="CNAnalysisMethodAllelicDifference_8cpp_source.html#l00116">CNAnalysisMethodAllelicDifference::calculateAllelicDifferences()</a>, <a class="el" href="CNCytoEngine_8cpp_source.html#l02024">CNCytoEngine::calculateGenders()</a>, <a class="el" href="RegressionCheck_8h_source.html#l00118">RegressionCheck::checkFloat()</a>, <a class="el" href="Util_8cpp_source.html#l00315">matrixDifferences()</a>, <a class="el" href="SketchQuantNormTran_8cpp_source.html#l00155">SketchQuantNormTran::newChipSuppliedTargetSketch()</a>, <a class="el" href="QuantMethodGTypeChipSummary_8h_source.html#l00136">QuantMethodGTypeChipSummary::report()</a>, and <a class="el" href="SketchQuantNormTran_8cpp_source.html#l00271">SketchQuantNormTran::transform()</a>.</p>

</div>
</div>
<a class="anchor" id="a81d133cd77d241447c255476d65c690f"></a><!-- doxytag: member="Util::matrixDifferences" ref="a81d133cd77d241447c255476d65c690f" args="(const std::string &amp;targetFile, const std::string &amp;queryFile, int colSkip, int rowSkip, double epsilon, bool printMismatch, bool matchRows, double fraction=0.0, int printMismatchMax=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Util::matrixDifferences </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>targetFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>queryFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>colSkip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rowSkip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>printMismatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>matchRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fraction</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>printMismatchMax</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check each entry in two matrices to see if they are the same. </p>
<p>If doing 'match-rows' we will attempt to find the matching row by the row name.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>targetFile</em>&nbsp;</td><td>- File to read target matrix from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queryFile</em>&nbsp;</td><td>- File to read the query matrix from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colSkip</em>&nbsp;</td><td>- How many of initial columns to ignore (i.e. row names) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowSkip</em>&nbsp;</td><td>- How many of initial rows to ignore (i.e. column header) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>- What is the tolerance of difference. i.e. if q[i][j] - t[i][j] &gt;= epsilon then there is a difference. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>printMismatch</em>&nbsp;</td><td>- Should we print out the cases where difference is &gt;= epsilon </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>matchRows</em>&nbsp;</td><td>- Should we try to match the rows based on the row identifiers. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fraction</em>&nbsp;</td><td>- Maximum fractional difference considered equivalent (default: not used). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>printMismatchMax</em>&nbsp;</td><td>- Maximum number of mismatches to print (default: no limit).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- Number of differences &gt;= epsilon found.</dd></dl>
<p>If doing 'match-rows' we will attempt to find the matching row by the row name.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>targetFile</em>&nbsp;</td><td>- File to read target matrix from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queryFile</em>&nbsp;</td><td>- File to read the query matrix from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colSkip</em>&nbsp;</td><td>- How many of initial columns to ignore (i.e. row names) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowSkip</em>&nbsp;</td><td>- How many of initial rows to ignore (i.e. column header) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>epsilon</em>&nbsp;</td><td>- What is the tolerance of difference. i.e. if q[i][j] - t[i][j] &gt;= epsilon then there is a difference. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>printMismatch</em>&nbsp;</td><td>- Should we print out the cases where difference is &gt;= epsilon </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>matchRows</em>&nbsp;</td><td>- Should we try to match the rows based on the row identifiers. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fraction</em>&nbsp;</td><td>- What fractional difference is tolerated, test for value equivalence (not used by default). i.e. if q[i][j] - t[i][j] &lt; fraction*max( |q[i][j]|, |t[i][j]| )</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- Number of differences &gt;= epsilon found. </dd></dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00315">315</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>References <a class="el" href="TableFile_8cpp_source.html#l00249">TableFile::columnFromFile()</a>, <a class="el" href="Err_8cpp_source.html#l00068">Err::errAbort()</a>, <a class="el" href="Util_8cpp_source.html#l00851">isFinite()</a>, <a class="el" href="RowFile_8cpp_source.html#l00321">RowFile::matrixFromFile()</a>, <a class="el" href="affy-base-types_8h_source.html#l00059">Max</a>, <a class="el" href="Verbose_8cpp_source.html#l00259">Verbose::out()</a>, and <a class="el" href="Convert_8h_source.html#l00248">ToStr()</a>.</p>

<p>Referenced by <a class="el" href="MatrixCheck_8h_source.html#l00102">MatrixCheck::check()</a>.</p>

</div>
</div>
<a class="anchor" id="abd09dcbcbe5d0dc6714bf008005fe0b7"></a><!-- doxytag: member="Util::memInfo" ref="abd09dcbcbe5d0dc6714bf008005fe0b7" args="(uint64_t &amp;free, uint64_t &amp;total, uint64_t &amp;swapAvail, uint64_t &amp;memAvail, bool cap32bit=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::memInfo </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&nbsp;</td>
          <td class="paramname"> <em>free</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&nbsp;</td>
          <td class="paramname"> <em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&nbsp;</td>
          <td class="paramname"> <em>swapAvail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&nbsp;</td>
          <td class="paramname"> <em>memAvail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>cap32bit</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine the free and total amount of memory in bytes on this machine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>free</em>&nbsp;</td><td>- Bytes available currently. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>total</em>&nbsp;</td><td>- Total bytes installed on machine. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>swapAvail</em>&nbsp;</td><td>- Amount of swap available on machine. OSX can use all disk space so reports 0 on OSX </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>memAvail</em>&nbsp;</td><td>- Amount of space we should consider available. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cap32bit</em>&nbsp;</td><td>- Cap the memory at 4GB.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, false otherwise. </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000317">Todo:</a></b></dt><dd>is there a more robust way to determine 32 vs 64 bitness? </dd></dl>
</p>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00695">695</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>References <a class="el" href="Util_8h_source.html#l00062">MEMINFO_2GB_MAX</a>.</p>

<p>Referenced by <a class="el" href="BaseEngine_8cpp_source.html#l00086">BaseEngine::BaseEngine()</a>.</p>

</div>
</div>
<a class="anchor" id="a772cd3b6f20be1e6082a800bb38d5e08"></a><!-- doxytag: member="Util::nextWhiteSpace" ref="a772cd3b6f20be1e6082a800bb38d5e08" args="(const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Util::nextWhiteSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a pointer to the next character that is white space or NULL if none found. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- cstring to find white space in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- Pointer to next whitespace character or NULL if none found. </dd></dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00750">750</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>Referenced by <a class="el" href="Util_8cpp_source.html#l00767">printStringWidth()</a>.</p>

</div>
</div>
<a class="anchor" id="a19c53e9ca0edb65d4a32717b509ba857"></a><!-- doxytag: member="Util::printStringWidth" ref="a19c53e9ca0edb65d4a32717b509ba857" args="(std::ostream &amp;out, const std::string &amp;str, int prefix, int currentPos, int maxWidth=70)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::printStringWidth </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>currentPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxWidth</em> = <code>70</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classPrint.html">Print</a> a string wrapping at max width from the current position. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>- stream to output string to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>- The cstring to be printed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>- How many spaces to put on begining of newline. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxWidth</em>&nbsp;</td><td>- Where to wrap text at. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentPos</em>&nbsp;</td><td>- What position in the line is cursor currently at. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00767">767</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>References <a class="el" href="Util_8cpp_source.html#l00750">nextWhiteSpace()</a>.</p>

<p>Referenced by <a class="el" href="SelfDoc_8cpp_source.html#l00139">SelfDoc::printExplanation()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f3f450e9baf79936a220deba4716f9d"></a><!-- doxytag: member="Util::replaceString" ref="a4f3f450e9baf79936a220deba4716f9d" args="(std::string &amp;s, const std::string &amp;from, const std::string &amp;to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Util::replaceString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace the from string with the to string for all instances in string supplied. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- string to do the replacement in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>- original string to be replaced. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>- string to do the replacing with. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00420">420</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0d2126d2d7027b17fdcba5f94e18567e"></a><!-- doxytag: member="Util::sameString" ref="a0d2126d2d7027b17fdcba5f94e18567e" args="(const std::string &amp;s1, const std::string &amp;s2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Util::sameString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check to see if two strings are the same. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s1</em>&nbsp;</td><td>- string 1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>s2</em>&nbsp;</td><td>- string 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if compare() considers them the same. </dd></dl>

<p>Definition at line <a class="el" href="Util_8h_source.html#l00264">264</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="QuantMethodGTypeCHPReport_8cpp_source.html#l00153">QuantMethodGTypeCHPReport::report()</a>, and <a class="el" href="QuantMethodGTypeCHPReport_8cpp_source.html#l00246">QuantMethodGTypeCHPReport::reportFailure()</a>.</p>

</div>
</div>
<a class="anchor" id="a425642d78784387daa25abdca75ecd17"></a><!-- doxytag: member="Util::schrageRandom" ref="a425642d78784387daa25abdca75ecd17" args="(int32_t *ix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Util::schrageRandom </td>
          <td>(</td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>ix</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schrage's algorithm for generating random numbers in 32 bits. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ix</em>&nbsp;</td><td>- pointer to integer seed, cannot be zero. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00438">438</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>References <a class="el" href="Err_8h_source.html#l00124">Err::check()</a>.</p>

</div>
</div>
<a class="anchor" id="ab074b74806364312a75e60933cd6d3e7"></a><!-- doxytag: member="Util::stringEndsWith" ref="ab074b74806364312a75e60933cd6d3e7" args="(const std::string &amp;str, const std::string &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Util::stringEndsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does the string end with the other string? </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>string to check </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endstr</em>&nbsp;</td><td>ending string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if str ends with endstr. </dd></dl>

<p>Definition at line <a class="el" href="Util_8cpp_source.html#l00151">151</a> of file <a class="el" href="Util_8cpp_source.html">Util.cpp</a>.</p>

<p>Referenced by <a class="el" href="PriorsReader_8cpp_source.html#l00067">birdseed::dev::BasicPriorsReader::writePriorsFile()</a>.</p>

</div>
</div>
<a class="anchor" id="af48d8be413de4e28b620e58e9f1d5ec1"></a><!-- doxytag: member="Util::subChar" ref="af48d8be413de4e28b620e58e9f1d5ec1" args="(std::string &amp;s, char from, char to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Util::subChar </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>to</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace the from character with the to character for all instances in string supplied. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- string to do the replacement in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>from</em>&nbsp;</td><td>- original character to be replaced. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>- character to do the replacing with. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8h_source.html#l00303">303</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="MsgStream_8cpp_source.html#l00045">MsgStream::message()</a>.</p>

</div>
</div>
<a class="anchor" id="aa912567f9cdde6941ba305f4278b5828"></a><!-- doxytag: member="Util::trimString" ref="aa912567f9cdde6941ba305f4278b5828" args="(std::string &amp;s, const char *whitespace=&quot; \r\n\t&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Util::trimString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>whitespace</em> = <code>&quot;&nbsp;\r\n\t&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cut off any preceding and trailing white space. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- String to be trimmed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>whitespace</em>&nbsp;</td><td>- String with characters to be trimmed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8h_source.html#l00239">239</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="LineFile_8cpp_source.html#l00124">LineFile::getline()</a>, <a class="el" href="Util_8cpp_source.html#l00861">getTimeStamp()</a>, <a class="el" href="RowFile_8cpp_source.html#l00094">RowFile::nextLine()</a>, and <a class="el" href="TranslationInputTsvTableModel_8cpp_source.html#l00129">TranslationInputTsvTableModel::readTsvFile()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c0b8f3bada1532e2939e3f57388360d"></a><!-- doxytag: member="Util::upcaseString" ref="a7c0b8f3bada1532e2939e3f57388360d" args="(const std::string &amp;str_orig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Util::upcaseString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str_orig</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy and upcase a 8bit string. ///. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str_orig</em>&nbsp;</td><td>/// </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="Util_8h_source.html#l00133">133</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8125745828794db4e98a63862a1daf0f"></a><!-- doxytag: member="Util::upcaseString_inplace" ref="a8125745828794db4e98a63862a1daf0f" args="(std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Util::upcaseString_inplace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make the string all uppercase. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>- string to be modified </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Util_8h_source.html#l00125">125</a> of file <a class="el" href="Util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>util/<a class="el" href="Util_8h_source.html">Util.h</a></li>
<li>util/<a class="el" href="Util_8cpp_source.html">Util.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2016 12:59:40 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
