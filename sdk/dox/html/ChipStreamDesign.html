<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: Architecture: ChipStream Design Notes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Architecture: <a class="el" href="classChipStream.html" title="ChipStream - base class for objects that can initialize themselves one at a time and transform intens...">ChipStream</a> Design Notes </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="chipstreamContent"></a>
Contents</h2>
<ul>
<li>
<a href="#intro">Introduction.</a> </li>
<li>
<a href="#designGoals">Design Goals.</a> </li>
<li>
<a href="#chipstreamPhases">ChipStream phases of computation.</a> </li>
<li>
<a href="#getttingStarted">Classes to get started with.</a> </li>
</ul>
<p><a class="anchor" id="intro"></a> </p>
<h2><a class="anchor" id="chipstreamIntro"></a>
Introduction</h2>
<p>Originally the <a class="el" href="classChipStream.html" title="ChipStream - base class for objects that can initialize themselves one at a time and transform intens...">ChipStream</a> code was just a mechanism for normalization, background subtraction, etc. While it is still useful in that context (see <a class="el" href="apt-cel-transformer.html">apt-cel-transformer </a> for example) the codebase has grown into doing more data analysis jobs which are can be seen by the applications <a class="el" href="apt-probeset-summarize.html">apt-probeset-summarize </a> and <a class="el" href="apt-probeset-genotype.html">apt-probeset-genotype </a>. Each of these applications uses the <a class="el" href="classAnalysisStream.html" title="Utility class for centralizing analysis pathway.">AnalysisStream</a> framework to compartmentalize the different steps of the data analysis:</p>
<ul>
<li>Raw data modifications that happen at the chip level like normalization, background subtraction, etc. happen in the <a class="el" href="classChipStream.html" title="ChipStream - base class for objects that can initialize themselves one at a time and transform intens...">ChipStream</a> step.</li>
</ul>
<ul>
<li>Data modifications specific to the PM probes (i.e. subtracting MM value) are encapsulated in the <a class="el" href="classPmAdjuster.html" title="Interface for determining a change based on intensity of perfect match.">PmAdjuster</a> step.</li>
</ul>
<ul>
<li>Summarization of the data such as genotype calls for mapping chips or RMA's median polish for expression arrays, or PLIER's iterative summary method for expression arrays happen in the <a class="el" href="classQuantMethod.html" title="QuantMethod - Interface for computing quantification summaries from PM intensities grouped into probe...">QuantMethod</a> (Quantification Method) step.</li>
</ul>
<p>Some microarray applications like tiling arrays don't have a notion of a probeset and so the <a class="el" href="classAnalysisStream.html" title="Utility class for centralizing analysis pathway.">AnalysisStream</a> framework doesn't really apply to them. The <a class="el" href="classChipStream.html" title="ChipStream - base class for objects that can initialize themselves one at a time and transform intens...">ChipStream</a> and <a class="el" href="classPmAdjuster.html" title="Interface for determining a change based on intensity of perfect match.">PmAdjuster</a> steps are quite generic though and could in theory be reused for many different applications.</p>
<p><a class="anchor" id="designGoals"></a> </p>
<h2><a class="anchor" id="chipstreamDesignGoals"></a>
Design Goals</h2>
<p>Design goals for this module were to:</p>
<ul>
<li>Minimize memory impact to allow large number of chips to be processed at one time. It may be that only a smaller number of probesets can be processed at one time, but a large number of chips are still possible.</li>
</ul>
<ul>
<li>Allow multiple analysis at once. Previously data transformations (i.e. normalization or background subtraction) were performed serially in core, meaning that it was not possible to use two different forms of normalization at one time.</li>
</ul>
<ul>
<li>Increase speed compared to hybrid c++/perl implementation. The heavy lifting of computation has been pushed down to the c++ code for speed increases. Additionally many objects have their own memory cache to avoid millions of new's and deletes.</li>
</ul>
<ul>
<li>Provide flexibility for new summary methods, data transformations, and background estimators.</li>
</ul>
<p><a class="anchor" id="chipstreamPhases"></a> </p>
<h2><a class="anchor" id="chipstreamPhases"></a>
ChipStream Phases</h2>
<p>The design has three main phases: 1) initiation, 2) data caching and parameter estimation, and 3) data summarization. The goal is to not need to have more than one complete cel file's worth of data open at one time. Each cel file is opened and used to estimate necessary parameters for that chip (i.e. <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> background - <a class="el" href="classRmaBgTran.html" title="RmaBgTran - Class for doing RMA style background subtraction.">RmaBgTran</a>, median normalization - <a class="el" href="classMedNormTran.html" title="MedNormTran - Class for doing median, or average, normalization.">MedNormTran</a>) and data to be used is cached in memory in an <a class="el" href="classIntensityMart.html" title="IntensityMart.">IntensityMart</a> such as <a class="el" href="classSparseMart.html" title="SparseMart Class for representing only a subset of cel file intensity data in memory.">SparseMart</a>. That way the amount of memory is dependent on the number of probeset specified to summarize and the number of chips, rather than requiring having all probeset data in memory. Additional memory will be required for annotation of chip, and other parameters like sketches in quantile normalization (<a class="el" href="classSketchQuantNormTran.html" title="SketchQuantNormTran for doing normalization.">SketchQuantNormTran</a>), but these should be much smaller than the size of a cel file.</p>
<p>Below are visual representations of the different phases:</p>
<div align="center">
<img src="phase1_intiation.png" alt="phase1_intiation.png"/>
<p><strong>Phase 1: Objects to do analysis are created and linked together.</strong></p></div>
<p> Objects are initialized using chip annotation provided by the pgf or cdf and encapsulated in the <a class="el" href="classChipLayout.html" title="ChipLayout - Data structure to represent the probesets encoded in the CDF, SPF or PGF files which def...">ChipLayout</a> file which specify <a class="el" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> groupings, <a class="el" href="classProbe.html" title="Represents an individual feature on a chip.">Probe</a> locations, mismatch probes, etc. <a class="el" href="classChipStream.html" title="ChipStream - base class for objects that can initialize themselves one at a time and transform intens...">ChipStream</a> objects are connected to each other to form data transformation paths.</p>
<div align="center">
<img src="phase2_dat-ext_param-est.png" alt="phase2_dat-ext_param-est.png"/>
<p><strong>Phase 2: Cel files opened one at a time and used for parameter estimation.</strong></p></div>
<p> Having one cel file opened at a time reduces memory impact. Only data that will actually be used in computation (i.e. not pixel number, stdev ) is stored in memory and then cel file is closed. Further, only data for which results are desired are stored in memory. If all of the probe sets are desired multiple runs with a smaller number of probe sets might be necessary, but large numbers of chips can be analyzed together. It can be algorithmically challenging to require that parameter estimation happens one cel file at a time. Quantile normalization (<a class="el" href="classSketchQuantNormTran.html" title="SketchQuantNormTran for doing normalization.">SketchQuantNormTran</a>) must see all the chips before a target profile can be generated, if doing a full normalization this means that all data from all chips is loaded into memory. Using a sketch normalization gets around this problem. Raw data from cel files is stored in matrix such as <a class="el" href="classSparseMart.html" title="SparseMart Class for representing only a subset of cel file intensity data in memory.">SparseMart</a>. Note that in addition to requested probesets other data, such as gc background probes (i.e for <a class="el" href="classGcAdjust.html" title="Class for doing an adjustment based on the median intensity of probes with similar GC content...">GcAdjust</a>), must be loaded into the memory cache.</p>
<div align="center">
<img src="phase3_data-tran_ps-summarize.png" alt="phase3_data-tran_ps-summarize.png"/>
<p><strong>Phase 3: Generate summary estimations using data transformations requested.</strong></p></div>
<p> For each probe set data is extracted from the memory cache and transformed through the <a class="el" href="classChipStream.html" title="ChipStream - base class for objects that can initialize themselves one at a time and transform intens...">ChipStream</a> pathway to be summarized by the requested <a class="el" href="classQuantMethod.html" title="QuantMethod - Interface for computing quantification summaries from PM intensities grouped into probe...">QuantMethod</a> (i.e. plier - <a class="el" href="classQuantPlier.html" title="Class for doing probe set quantification using the PLIER (Probe Logarithmic Error Intensity Estimate)...">QuantPlier</a>, median polish - <a class="el" href="classQuantRma.html" title="Class for doing probe set quantification using median polish as does RMA.">QuantRma</a>). What value to use for a mismatch probe is determined by the <a class="el" href="classPmAdjuster.html" title="Interface for determining a change based on intensity of perfect match.">PmAdjuster</a> class such as GcAdjuster or MmAdjuster. As data in memory cache is original raw data, multiple transformation pathways, background estimates and summary methods can be specified.</p>
<p>All three classes of objects <a class="el" href="classChipStream.html" title="ChipStream - base class for objects that can initialize themselves one at a time and transform intens...">ChipStream</a>, <a class="el" href="classPmAdjuster.html" title="Interface for determining a change based on intensity of perfect match.">PmAdjuster</a> and <a class="el" href="classQuantMethod.html" title="QuantMethod - Interface for computing quantification summaries from PM intensities grouped into probe...">QuantMethod</a> know how to make themselves via <a class="el" href="classSelfCreate.html" title="Small interface for functions that know how to make an instance of themselves given a map of key...">SelfCreate</a> and are self documenting via <a class="el" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a>. This helps to standardize their creation in the classes <a class="el" href="classChipStreamFactory.html" title="Factory class for making chip streams based on a string representation.">ChipStreamFactory</a>, <a class="el" href="classPmAdjusterFactory.html" title="Factory class for making chip streams based on a string representation.">PmAdjusterFactory</a> and <a class="el" href="classQuantMethodFactory.html" title="Factory class for making chip streams based on a string representation.">QuantMethodFactory</a>. To create a new type of transformation, PM adjustment class, or summary methods one must supply the class with all of the necessary methods then register the explainSelf() and newObject() classes with the constructor of the correct factory class (i.e. <a class="el" href="classChipStreamFactory.html" title="Factory class for making chip streams based on a string representation.">ChipStreamFactory</a>).</p>
<p><a class="anchor" id="gettingStarted"></a> </p>
<h2><a class="anchor" id="chipstreamGettingStarted"></a>
Getting Started...</h2>
<p>There are two essential things you need to implement any Affymetrix algorithm:</p>
<ol type="1">
<li>A notion of what individual probes on the array are detecting, traditionally a <a class="el" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> for Expression and Genotyping arrays. Tiling arrays use a different mechanism which is currently unsupported in this module.</li>
</ol>
<ol type="1">
<li>The intensity data stored in a CEL file, possibly after modifications such as normalization or background subtraction.</li>
</ol>
<p>Knowing the probes to use and having the intensity data from the experiment are the two cornerstones to any algorithm analysis.</p>
<h3><a class="anchor" id="ProbeSets"></a>
ProbeSets</h3>
<p>A <a class="el" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a>, or group of Probes, both perfect match (PM) and possibly mismatch (MM) that detect a particular target. Each <a class="el" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> has an <a class="el" href="classAtom.html" title="Represents a collection of probes that make up a unit for an intensity measurement of a particular se...">Atom</a> vector which in turn has a <a class="el" href="classProbe.html" title="Represents an individual feature on a chip.">Probe</a> vector. The <a class="el" href="classAtom.html" title="Represents a collection of probes that make up a unit for an intensity measurement of a particular se...">Atom</a> is represents a collection of probes that are used to get an estimate for a particular portion of a sequence target. For example an <a class="el" href="classAtom.html" title="Represents a collection of probes that make up a unit for an intensity measurement of a particular se...">Atom</a> may consist of a PM probe and an MM probe for an expression array (corresponding to the concept of "list" in a CDF file) or an <a class="el" href="classAtom.html" title="Represents a collection of probes that make up a unit for an intensity measurement of a particular se...">Atom</a> could contain probes interrogating each possible target base in a resequencing array. A <a class="el" href="classProbe.html" title="Represents an individual feature on a chip.">Probe</a> corresponds to the feature present at physical position x,y on the array. Each Probe's id is actually the index into a vector representing all the Probes on the array based on their physical x,y position based on the transformation <img class="formulaInl" alt="$ index = (y*NumColumns) + x $" src="form_14.png"/> where NumColumns is the number of columns on that array. For speed and simplicity the <a class="el" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> class is a essentially a fancy struct with data publicly available.</p>
<p>APT applications use the <a class="el" href="classChipLayout.html" title="ChipLayout - Data structure to represent the probesets encoded in the CDF, SPF or PGF files which def...">ChipLayout</a> class to read in the desired ProbeSets from either a CDF file (traditional arrays like U133 or 500K) or PGF file (Exon arrays). Having the RAM representation independent of the disk representation allows us to support multiple different file formats and more easily accommodate future formats. The ProbeSets read by a <a class="el" href="classChipLayout.html" title="ChipLayout - Data structure to represent the probesets encoded in the CDF, SPF or PGF files which def...">ChipLayout</a> object can be accessed serially by functions like ChipLayout::getProbeSetIndex() or randomly using functions like ChipLayout::getProbeSetByName().</p>
<h3><a class="anchor" id="Intensity"></a>
Data</h3>
<p>After the hybridization, scanning, griding the raw intensity data is stored in CEL files. These CEL files are the beginning for most analyses. When doing mulitchip algorithms these CEL files can quickly add up to a lot of data. For example the 5 micron chips (i.e. Exon and 500K Mapping) each have 6.5 million features each and so having the intensity data for 100 CEL files requires about 6.5 million * 100 * 4 bytes per float requires 2.6 Gig of RAM.</p>
<p>Most of the current APT applications use a combination of <a class="el" href="classCelReader.html" title="Class for reading cel files and passing the data to memory representation and analysis objects...">CelReader</a> to read the CEL file data and <a class="el" href="classSparseMart.html" title="SparseMart Class for representing only a subset of cel file intensity data in memory.">SparseMart</a> to store the data in RAM. <a class="el" href="classSparseMart.html" title="SparseMart Class for representing only a subset of cel file intensity data in memory.">SparseMart</a> has the benefit of being able to store a subset of the total data in a CEL file compactly so when computing a subset of ProbeSets it allows an application to fit in a much smaller amount of RAM.</p>
<p>Running the raw intensity data in a <a class="el" href="classSparseMart.html" title="SparseMart Class for representing only a subset of cel file intensity data in memory.">SparseMart</a> through a <a class="el" href="classChipStream.html" title="ChipStream - base class for objects that can initialize themselves one at a time and transform intens...">ChipStream</a> set of transformations via ChipStream::transformData() allows common work flows such as normalization and background subtraction. See the <a class="el" href="apt-cel-transformer.html">apt-cel-transformer </a> program for an example usage of the <a class="el" href="classChipStream.html" title="ChipStream - base class for objects that can initialize themselves one at a time and transform intens...">ChipStream</a> framework in a real, yet relatively simple, application.</p>
<p>Once you have the <a class="el" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> specifying the probe of interest and the accompanying intensity data via <a class="el" href="classSparseMart.html#aefd6101b74d8d46aa3031e33ea873ca3" title="Given the probe index and chip index return the intensity data appropriate for that probe in that chi...">SparseMart::getProbeIntensity()</a> many algorithms, such as <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> (QuantRMA), plier (<a class="el" href="classQuantPlier.html" title="Class for doing probe set quantification using the PLIER (Probe Logarithmic Error Intensity Estimate)...">QuantPlier</a>), BRLMM (<a class="el" href="classQuantBRLMM.html" title="Implements a SNP genotype calling method motivated by Nusrat Rabbee&#39;s RLMM (Robust Linear Model w...">QuantBRLMM</a>), etc. can be implemented in a relatively efficient method. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2016 12:59:13 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
