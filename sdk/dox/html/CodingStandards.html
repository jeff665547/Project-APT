<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: Coding Standards</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Coding Standards </h1>  </div>
</div>
<div class="contents">
<h1>APT Coding Standards</h1>
<h2><a class="anchor" id="CodingPhilosophy"></a>
Basic Philosophy</h2>
<ul>
<li><b>Code should compile cleanly and run correctly.</b> Our goal is that the head of the tree should build and pass all of its tests every night on all platforms. If a code change is causing the build to fail the code should be fixed or backed out as soon as possible. Checking in code that hasn't been tested is bad practice. Test your code - if you don't have a test, then write a test and check that into cvs at the same time. Checking code that is known to be broken into the repository is very bad practice. Code should be proactive about checking its assumptions and erroring when invalid.</li>
</ul>
<ul>
<li><b>Code should be written clearly and be easy for others to understand.</b> Clear and concise variable names are a good thing. Functions should be short and have a single purpose. Prefer clear to clever and if being clever document how and why. Comments are a good thing. Code will be reused through libraries rather than cutting and pasting.</li>
</ul>
<ul>
<li><b>Performance counts.</b> Code should run as fast as reasonably possible using a reasonable amount of memory and disk space. Be careful to avoid obfuscating code that is rarely called for the sake of speed. As stated by Donald Knuth ''We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil.'' A programmer's job is to find that 3% that matters, isolate it in the design and make it fast. Know your libraries and use appropriate algorithms.</li>
</ul>
<ul>
<li><b>Code isn't done until there is an automatic test to prove it works.</b> The algorithms and applications of a technology company are constantly changing. Automated tests are necessary to ensure correctness both at the time of initial development and as the code is extended and refactored for new applications and algorithms.</li>
</ul>
<ul>
<li><b>Code for today, but design for tomorrow.</b> Quick and dirty design hacks are discouraged. Work through interfaces rather than tightly coupling code. Refactor rather than cut and paste code. Talk to your coworkers about design, respect their input. Use Design Patterns to help think about problems, but the objective is to keep things as simple as possible for a given implementation so they are not a convention per se. The underlying philosophy is to try and use the abstractions that give the most benefit for the trouble in a given project and to have tests so it is possible to go in and refactor things as new abstractions become worthwhile.</li>
</ul>
<h2><a class="anchor" id="CodingStyle"></a>
Style Guide</h2>
<p>There are a lot of style guides out there that have been developed over the years. The following are a set of general guidelines that hopefully cut across all of the main styles and we can all agree on. The following are guidelines and there may be reasons where a particular efficiency or feature require extreme measures but they should be the exception rather than the rule.</p>
<h3>Indentation:</h3>
<p>How to format code is a subject of much debate which can turn seemingly nice coworkers into zealots that would make the Spanish inquisition proud. Most of the disagreements center on where to but the braces on blocks of code. The classic Kernighan and Ritchie's style (k&amp;r) from their book "The C Programming Language" puts the opening bracket on the same line as the control statement. This is also the style used in the Linux kernel and in Stroustrup's original c++ books. It looks like this: </p>
<div class="fragment"><pre class="fragment">
if (x == y) {
   something();
}
</pre></div><p> Another popular method is to put the first bracket on a separate line as seen in the BSD style (also called the Allman style): </p>
<div class="fragment"><pre class="fragment">
if (x == y) 
{
   something();
}
</pre></div><p> Another variation is GNU official style which looks like: </p>
<div class="fragment"><pre class="fragment">
if (x == y) 
   {
      something();
   }
</pre></div><p> All of the above are reasonable if you are creating a new module, but please don't get creative outside of these styles.</p>
<p>Switch statements seem to be a particularly fertile ground for creativity. Stick to the basic version (using Allman style bracket on a separate line is ok too) like:</p>
<div class="fragment"><pre class="fragment">
switch (num)  {      
 case one: 
   doOne(); 
   break;
 case two: 
   doTwo(); 
   break;
 default: 
   error();
}
</pre></div><p>Put a default case in your switch statements. It lets others know what is do be done in the default case.</p>
<h3>Only Spaces, No Tabs.</h3>
<p>Tabs can display very differently in other editors so they are not allowed. Use 2 spaces for an indentation. No whitespace at the end of a line.</p>
<ul>
<li>For Emacs put the following in your .emacs file <div class="fragment"><pre class="fragment">
     ;; Make formatting use spaces instead of tabs.
     (defun affy-setup-no-tabs ()  
        (setq indent-tabs-mode nil
     	    c-indent-level   4))

    (add-hook 'c-mode-hook 'affy-setup-no-tabs) 
    (add-hook 'c++-mode-hook 'affy-setup-no-tabs) 
    ;; to remove this hook:
    ;;  (remove-hook 'c-mode-hook 'affy-setup-no-tabs)
     </pre></div></li>
<li>For Vim add the following in your .vimrc <a href="file:">file:</a> <div class="fragment"><pre class="fragment">
       set tabstop=4
       set shiftwidth=4
       set expandtab
   </pre></div></li>
<li>In Microsoft VC2005 this is settable via Tools-&gt;<a class="el" href="classOptions.html" title="base class for tracking class options">Options</a> -- Text Editor-&gt;All Languages-&gt;"Insert Spaces" under tabs.</li>
</ul>
<h3>Whitespace Use</h3>
<p>Readable code is a compromise between having enough whitespace to make things readable and keeping the code compact enough to fit a useful chunk in the editor window. Try to find a reasonable balance. Some examples would be</p>
<ul>
<li>Very dense... <div class="fragment"><pre class="fragment">
  void myfunction(int count,float param){
    for(i=0;i&lt;count;i++){i%2==0?doSomething(param):doOther(param);}
  }
  </pre></div></li>
<li>Too much whitespace? <div class="fragment"><pre class="fragment">
  void 
  myfunction(int count, 
                  float param) {

    for ( i = 0 ; i &lt; count ; i++ ) {

      if ( i % 2 == 0 ) {
      
        doSomething(param);

      } 

      else {
      
        doOther(param);

      } 

    }

  }
  </pre></div></li>
<li>Something reasonable? <div class="fragment"><pre class="fragment">
  void myfunction(int count, float param) {
    for ( i=0 ; i&lt;count; i++) {
      if ( i % 2 == 0 ) 
        doSomething(param);
      else
        doOther(param);
    }
  }
  </pre></div></li>
<li>Whitespace before control statements like <code>if (x)</code> is encouraged, but whitespace before function names like <code>myFunction (x,y,z)</code> is frowned upon, use <code>myFunction(x,y,z)</code> instead. Putting whitespace before or after the <code>-&gt;</code> operator is not allowed, so pointers should always be used like <code>p-&gt;var</code> and never <code>p -&gt; var</code>.</li>
</ul>
<h3>Variable Names</h3>
<p>Naming conventions for variables is another fertile ground for creativity. In general the basic format falls into two schools:</p>
<ol type="1">
<li><b>Camel Case Based.</b> Many projects and the entire Java language use variable names where new words being concatenated together use a capital letter. For example <code>int myCountForX;</code>.</li>
<li><b>Underscore Based.</b> The GNU coding style and STL project use unerscores '_' to separate compound variable names. For example <code>int my_count_for_x;</code>.</li>
</ol>
<p>Both schools of thought have their advantages and disadvantages and really it is more a matter of what you're used to coding. Much of the APT codebase uses the same variable naming conventions as Java where variables and functions are camelCase while classes are UpperCamelCase. While APT tolerates a few different styles the following shall be enforced:</p>
<ul>
<li><b>Be consistent within a file or module.</b> If staring a new module or file use the same conventions throughout the file. If working on an existing file or module use the convention already in place.</li>
<li><b>Hungarian notation is <em>not</em> required.</b> Feel free to add prefixes to variables to help remember their type such as <code>string *pName;</code> but they are not required.</li>
<li><b>Macros shall be entirely uppercase.</b> Macros should not masquerade as functions.</li>
<li><b>Constants defined shall be upppercase.</b> All preprocessor defined constants shall be uppercase as a convention.</li>
</ul>
<h2><a class="anchor" id="CodingGuidelines"></a>
Other Guidelines</h2>
<ul>
<li><b>Use the prevailing style in a file or module.</b> Or ask the author you are modifying existing code.</li>
</ul>
<ul>
<li><b>Declaration and documentation go in the .h file, definition goes in the .cpp file.</b> The .h file declares functions and provides a reference for documentation. Keeping code in the .cpp files speeds up compilation. When writing templates everything goes in the .h file.</li>
</ul>
<ul>
<li><b>Keep a reasonable number of arguments per function.</b> More than 5 arguments for a function and it is time to consider refactoring.</li>
</ul>
<ul>
<li><b>Use meaningful variable names.</b> Don't pack a paragraph description into a variable name. <div class="fragment"><pre class="fragment">
  string s; // Not very helpful.
  string fileName; // Helpful.
  string fileNameThatImPlanningToUseForOutput; // Too much of a good thing.
</pre></div></li>
</ul>
<ul>
<li><b>Use comments.</b> Write timely, concise and meaningful comments aimed to help the understanding of what program is doing. Use doxygen format. <div class="fragment"><pre class="fragment">
  int xCount; ///&lt; Count for x (this is a useless comment);
  int xCount; ///&lt; Current number of items in the x array.
</pre></div></li>
</ul>
<ul>
<li><b>No sprintf().</b> There shall be <b>no sprintf()</b>. Use snprintf() or equivalent if you need to print into a string. Plain old sprintf() is a security hazard and makes for the worst sort of weird memory bugs.</li>
</ul>
<ul>
<li><b>"void *" is prohibited.</b> Typed languages help to keep bugs found at compile time rather than at run time. There may be compelling use cases for using "void *" but they should be the exception rather than the rule.</li>
</ul>
<ul>
<li><b>"goto" statements are prohibited.</b> Goto statements make the flow of control in a program difficult to follow. There may be exceptions to this rule, but they should be rare.</li>
</ul>
<ul>
<li><b>Lines should 80 characters or less.</b> There may be exceptions to this rule, but they should be rare.</li>
</ul>
<ul>
<li><b>Functions should be a reasonable length.</b> Monolithic functions are bad practice and lead to obfuscated code that is difficult to maintain or reuse. If a function is more than 50 lines it is probably time to refactor some functionality.</li>
</ul>
<ul>
<li><b>Initialize local variables.</b>. If nothing else this makes the bugs reproducible...</li>
</ul>
<ul>
<li><b>Use variables for single purpose.</b> Don't reuse a variable for something else.</li>
</ul>
<ul>
<li><b>Don't use "#pragma once" in header files.</b> Many C compilers don't like "#pragma once". Use the standard convention of: <div class="fragment"><pre class="fragment">
#ifndef _NAMEOFDOT_H_
#define _NAMEOFDOT_H_

// contents...

#endif // _NAMEOFDOT_H_
</pre></div></li>
</ul>
<ul>
<li><b>No magic strings/numbers.</b> Any constants should be defined in a single place. If the value is used only locally then in the .cpp file or in the .h file if it needs to be shared as part of the api.</li>
</ul>
<ul>
<li><b>Exceptions are for the unexpected.</b> Use error codes if errors are expected or booleans are to be passed back to the calling function.</li>
</ul>
<ul>
<li><b>Specify Copyright/License.</b> All source files shall contain a copyright or license at the top of the file.</li>
</ul>
<ul>
<li><b>Limit Global Variables.</b> Variables should be defined and used locally</li>
</ul>
<ul>
<li><b>No hard coded paths.</b> File paths should come from configuration files, user input or function input.</li>
</ul>
<ul>
<li><b>Write useful commit messages.</b> Don't bundle multiple functional changes in a single commit. Include the ticket number when available. Don't mix formatting fixes with functional changes.</li>
</ul>
<ul>
<li><b>Use the STL.</b> Don't recode sorting, vector, etc. use the c++ standard. <b>NB:</b> when coding the predicate (e.g. "less than") for the sort, make it a functor rather than a plain function, and put the predicate body into the functor's <code>operator()()</code>. <br/>
For example, to sort someContainer of X by values of someElement inside X: <div class="fragment"><pre class="fragment">
struct MyLessThan {
    bool operator()(const X&amp; lhs, const X&amp; rhs) const {
        return lhs.someElement &lt; rhs.someElement;
    }
};
...
sort(someContainer.begin(), someContainer.end(), MyLessThan());
</pre></div> The reason for this is that compilers happily inline a class method like operator()() but they typically won't inline a straight function call via function pointer.</li>
</ul>
<ul>
<li><b>Use APT header include formats.</b> Feel free to use the script under affy/sdk/apt/bin/apt-header-cleanup if desired. The rules for <code>#include</code> formats are:<ul>
<li>No implied paths below affy/sdk. Everything must be relative to affy/sdk that is under affy/sdk.</li>
<li>Four or five sections, each divided by a line with only "//". An application file "foo.cpp" will have five section where the "foo.h" is at the single include line at the top, all by itself. Call it section 0.</li>
<li>Section 1: Application for the particular application directory "XXX" immediately under affy/sdk/XXX. A directory such as affysdk/XXX/foo/bar is included in this section.</li>
<li>Section 2: Affy library section, all affy/sdk/YYY directories that are not the affy/sdk/XXX directory of the file.</li>
<li>Section 3. External, 3rd party packages such as pcre or xerces.</li>
<li>Section 4. System</li>
</ul>
</li>
</ul>
<ul>
<li><b>Use caution with Floating point numbers.</b> The two main types of floating point are "float" and "double". float is generally an IEEE-754 32b floating point number and double 64b one. However, on IA32, it is sometimes an extended precision 80b fp number. While more accurate, it can cause differences when comparing the output of your program across architectures.<ul>
<li>If you can, you may want to consider using the flags <code>-march=i686 -msse -mfpmath=sse</code> with GCC. This will instruct GCC to use the SSE unit for FP math instead of the normal FP unit. The SSE units are designed to do IEEE math. This should generate the same answers as on other IEEE fp systems.</li>
<li>Like byte order there has been much written about floating point. A good read is "What Every Computer Scientist Should Know About Floating-Point Arithmetic". [Goldberg] [Cohen] <a href="http://www.rdrop.com/~cary/html/endian_faq.html">http://www.rdrop.com/~cary/html/endian_faq.html</a> [Goldberg] <a href="http://docs.sun.com/source/806-3568/ncg_goldberg.html">http://docs.sun.com/source/806-3568/ncg_goldberg.html</a></li>
</ul>
</li>
</ul>
<ul>
<li><b>Be specific about data types.</b> Just like byte order, processor architectures have different ideas how big the native word size is. Many machines think the word size is 32b, while some think it is 64b. (Others are less than 32b, but Affymetrix is unlikely to use them.)<ul>
<li>When writing code which does IO, you should take care to specify the word size. This will both ensure that the quantities written are of the correct size as well as documenting the IO which is being done.</li>
<li>"FileIO.h" defines a series of types which we will make sure are of the correct size. These types are counted in bit width: "int8_t", "int16_t", "int32_t", and "int64_t", along with their unsigned versions.</li>
<li>One C data type to avoid is "long". <b>Dont use 'long'.</b> The size of long will vary by architecture and the compiler used. Because of this variation it will cause problems.</li>
</ul>
</li>
</ul>
<ul>
<li><b>[[Jan] Item for discussion:] Use <code>static_cast</code> for compile time downcasting.</b> There are many instances of <code>dynamic_cast</code> in APT code where the plain <code>static_cast</code> would be sufficient, for example: <div class="fragment"><pre class="fragment">
if (InstanceOf(create, ChipStream)) {
    stream = dynamic_cast&lt;ChipStream *&gt;(create);
}
</pre></div> &nbsp;<br/>
 There is a <code>dynamic_cast</code> hidden inside <code>InstanceOf</code> so there is no need to repeat the runtime check and we can do instead: <div class="fragment"><pre class="fragment">
    stream = static_cast&lt;ChipStream *&gt;(create);
</pre></div> &nbsp;<br/>
 Basically, <code>static_cast</code> is like the old C-style cast except it's restricted to perform only pointer or reference <em>downcasting</em> (to publicly derived subclasses) and simple type conversions like <code>float</code> to <code>int</code>. It cannot cast pointers to <em>unrelated</em> classes (and protectedly[sic!] or privately derived ones) or remove constness. Use <code>reinterpret_cast</code> for the former and <code>const_cast</code> for the latter (<code>reinterpret_cast</code> cannot remove constness). <br/>
<br/>
 I'm also not too sure about the Javaesque macro <code>InstanceOf</code> - why not use <code>dynamic_cast</code> straight? Macros are best avoided, esp. when replacing established C++ idioms like: <div class="fragment"><pre class="fragment">
if (stream = dynamic_cast&lt;ChipStream *&gt;(create)) {
    // ... use stream as if it was a ChipStream, no static_cast needed
}
else {
    // ... not a ChipStream
}
</pre></div></li>
</ul>
<ul>
<li><b>[[Jan] An item probably too early for discussion:]</b> Take a look if some classes could benefit from adding move constructors (the new C++0x thingy). Visual Studio&nbsp;2010 will support move semantics (and rvalue references) and current gcc supports it already via the <code>-std=c++0x</code> command line option. While most of the speed improvements will come from the C++0x version of the STL, it's still worth checking for instances where unnecessary copy constructor calls are a noticeable drag.</li>
</ul>
<ul>
<li><b>[[Jan] Item for discussion:] Avoid one-liner if clauses.</b> Lines like: <div class="fragment"><pre class="fragment">
if (x) y;
</pre></div> ...make it impossible to set a breakpoint at <code>y;</code> Use instead: &nbsp;<br/>
 <div class="fragment"><pre class="fragment">
if (x) {
    y;
}
</pre></div> </li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2016 12:59:11 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
