<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: copynumber/CNAnalysisMethod.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_41dda80f44caddc01a4a55d902223772.html">copynumber</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>CNAnalysisMethod.cpp</h1>  </div>
</div>
<div class="contents">
<a href="CNAnalysisMethod_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00002"></a>00002 <span class="comment"></span><span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// Copyright (C) 2005 Affymetrix, Inc.</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// This program is free software; you can redistribute it and/or modify</span>
<a name="l00006"></a>00006 <span class="comment">// it under the terms of the GNU General Public License (version 2) as</span>
<a name="l00007"></a>00007 <span class="comment">// published by the Free Software Foundation.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<a name="l00012"></a>00012 <span class="comment">// General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment">// along with this program;if not, write to the</span>
<a name="l00016"></a>00016 <span class="comment">//</span>
<a name="l00017"></a>00017 <span class="comment">// Free Software Foundation, Inc.,</span>
<a name="l00018"></a>00018 <span class="comment">// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00019"></a>00019 <span class="comment">//</span><span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00021"></a>00021 <span class="comment"></span><span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">/**</span>
<a name="l00023"></a>00023 <span class="comment"> * @file CNAnalysisMethod.cpp</span>
<a name="l00024"></a>00024 <span class="comment"> *</span>
<a name="l00025"></a>00025 <span class="comment"> * @brief This file contains the CNAnalysisMethod class members.</span>
<a name="l00026"></a>00026 <span class="comment"> */</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment">//</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="CNAnalysisMethod_8h.html" title="This header contains the CNAnalysisMethod class definition.">copynumber/CNAnalysisMethod.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="CNExperiment_8h.html" title="This header contains the CNExperiment class definition.">copynumber/CNExperiment.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="CNAnalysisMethodCovariateParams_8h.html" title="Class containing common data for covariate-based signal and log2ratio adjustment.">copynumber/CNAnalysisMethodCovariateParams.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="comment">//</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;file5/File5.h&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;file5/File5_Tsv.h&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="affy-base-types_8h.html">portability/affy-base-types.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="AffxStatistics_8h.html" title="This header contains the AffxStatistics class definition.">util/AffxStatistics.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="Fs_8h.html" title="///">util/Fs.h</a>&quot;</span>
<a name="l00038"></a>00038 <span class="comment">//</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">using namespace </span>std;
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keywordtype">int</span> CNAnalysisMethod::m_iInstanceCount = 0;
<a name="l00047"></a>00047 std::vector&lt;affymetrix_calvin_parameter::ParameterNameValueType&gt; CNAnalysisMethod::m_vCelFileParams;
<a name="l00048"></a>00048 std::vector&lt;affymetrix_calvin_parameter::ParameterNameValueType&gt; CNAnalysisMethod::m_vParams;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <a class="code" href="classAffxString.html" title="A class derived from std::string.">AffxString</a> CNAnalysisMethod::getPrefix()
<a name="l00051"></a>00051 {
<a name="l00052"></a>00052   <span class="keywordflow">return</span> <span class="stringliteral">&quot;affymetrix-algorithm-param-&quot;</span>;
<a name="l00053"></a>00053 }
<a name="l00054"></a>00054 <span class="keywordtype">int</span> CNAnalysisMethod::getSegmentType()
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056   <span class="keywordflow">return</span> CNSegment::getSegmentType(getName());
<a name="l00057"></a>00057 }
<a name="l00058"></a>00058 <a class="code" href="classAffxString.html" title="A class derived from std::string.">AffxString</a> CNAnalysisMethod::getSegmentTypeString()
<a name="l00059"></a>00059 {
<a name="l00060"></a>00060   <span class="keywordflow">return</span> <a class="code" href="classCNSegment.html#a936ebb8836b94e42541a9ede9e3f3dbe" title="Return the segment type string associated with the specified segment type.">CNSegment::getSegmentTypeString</a>(getSegmentType());
<a name="l00061"></a>00061 }
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <a class="code" href="classCNSegmentArray.html" title="A vector of Segment Pointers.">CNSegmentArray</a>&amp; CNAnalysisMethod::getSegments()
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065   <span class="keywordflow">return</span> m_vSegments;
<a name="l00066"></a>00066 }
<a name="l00067"></a>00067 <a class="code" href="classCNSegmentArray.html" title="A vector of Segment Pointers.">CNSegmentArray</a> CNAnalysisMethod::getSegments(<span class="keywordtype">int</span> iType)
<a name="l00068"></a>00068 {
<a name="l00069"></a>00069   <a class="code" href="classCNSegmentArray.html" title="A vector of Segment Pointers.">CNSegmentArray</a> v;
<a name="l00070"></a>00070   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; (iIndex &lt; m_vSegments.getCount()); iIndex++) {
<a name="l00071"></a>00071     <a class="code" href="classCNSegment.html" title="A class for storing Segment data.">CNSegment</a>* p = m_vSegments.getAt(iIndex);
<a name="l00072"></a>00072     <span class="keywordflow">if</span> (p-&gt;getSegmentType() == iType) {
<a name="l00073"></a>00073       v.push_back(p);
<a name="l00074"></a>00074     }
<a name="l00075"></a>00075   }
<a name="l00076"></a>00076   <span class="keywordflow">return</span> v;
<a name="l00077"></a>00077 }
<a name="l00078"></a>00078 <span class="keywordtype">int</span> CNAnalysisMethod::getSegmentCount(<span class="keywordtype">int</span> iType)
<a name="l00079"></a>00079 {
<a name="l00080"></a>00080   <span class="keywordflow">return</span> m_vSegments.getSegmentCount(iType);
<a name="l00081"></a>00081 }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="keywordtype">void</span> CNAnalysisMethod::setEngine(<a class="code" href="classBaseEngine.html" title="Base class for analysis engines.">BaseEngine</a>* p)
<a name="l00084"></a>00084 {
<a name="l00085"></a>00085   m_pEngine = p;
<a name="l00086"></a>00086   m_iXChromosome = m_pEngine-&gt;<a class="code" href="classOptions.html#afcfab86e21cac5bba43e0858bd428e62" title="Get the integer value of an option.">getOptInt</a>(<span class="stringliteral">&quot;xChromosome&quot;</span>);
<a name="l00087"></a>00087   m_iYChromosome = m_pEngine-&gt;<a class="code" href="classOptions.html#afcfab86e21cac5bba43e0858bd428e62" title="Get the integer value of an option.">getOptInt</a>(<span class="stringliteral">&quot;yChromosome&quot;</span>);
<a name="l00088"></a>00088 }
<a name="l00089"></a>00089 <a class="code" href="classBaseEngine.html" title="Base class for analysis engines.">BaseEngine</a>* CNAnalysisMethod::getEngine()
<a name="l00090"></a>00090 {
<a name="l00091"></a>00091   <span class="keywordflow">return</span> m_pEngine;
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 <a class="code" href="classCNExperiment.html" title="A class for storing CNExperiment data.">CNExperiment</a>* CNAnalysisMethod::getExperiment()
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095   <span class="keywordflow">return</span> m_pobjExperiment;
<a name="l00096"></a>00096 }
<a name="l00097"></a>00097 <a class="code" href="classCNExperimentArray.html" title="A vector of CNExperiment pointers.">CNExperimentArray</a>* CNAnalysisMethod::getExperiments()
<a name="l00098"></a>00098 {
<a name="l00099"></a>00099   <span class="keywordflow">return</span> m_pvExperiments;
<a name="l00100"></a>00100 }
<a name="l00101"></a>00101 <span class="keywordtype">void</span> CNAnalysisMethod::setProbes(<a class="code" href="classCNProbeArray.html" title="A vector of CNProbe pointers.">CNProbeArray</a>&amp; vProbes)
<a name="l00102"></a>00102 {
<a name="l00103"></a>00103   m_pvProbes = &amp;vProbes;
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 <a class="code" href="classCNProbeArray.html" title="A vector of CNProbe pointers.">CNProbeArray</a>* CNAnalysisMethod::getProbes()
<a name="l00106"></a>00106 {
<a name="l00107"></a>00107   <span class="keywordflow">return</span> m_pvProbes;
<a name="l00108"></a>00108 }
<a name="l00109"></a>00109 std::vector&lt;affymetrix_calvin_parameter::ParameterNameValueType&gt;* CNAnalysisMethod::getCelFileParams()
<a name="l00110"></a>00110 {
<a name="l00111"></a>00111   <span class="keywordflow">return</span> &amp;m_vCelFileParams;
<a name="l00112"></a>00112 }
<a name="l00113"></a>00113 std::vector&lt;affymetrix_calvin_parameter::ParameterNameValueType&gt;* CNAnalysisMethod::getParams()
<a name="l00114"></a>00114 {
<a name="l00115"></a>00115   <span class="keywordflow">return</span> &amp;m_vParams;
<a name="l00116"></a>00116 }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="keywordtype">void</span> CNAnalysisMethod::setup(<a class="code" href="classCNExperiment.html" title="A class for storing CNExperiment data.">CNExperiment</a>&amp; objExperiment, <a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>&amp; vProbeSets, <a class="code" href="classCNProbeArray.html" title="A vector of CNProbe pointers.">CNProbeArray</a>* pvProbes)
<a name="l00119"></a>00119 {
<a name="l00120"></a>00120   m_pobjExperiment = &amp;objExperiment;
<a name="l00121"></a>00121   m_pvProbeSets = &amp;vProbeSets;
<a name="l00122"></a>00122   m_pvProbes = pvProbes;
<a name="l00123"></a>00123 }
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="keywordtype">void</span> CNAnalysisMethod::setup(<a class="code" href="classCNExperimentArray.html" title="A vector of CNExperiment pointers.">CNExperimentArray</a>&amp; vExperiments, <span class="keywordtype">int</span> experimentIndex, <a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>&amp; vProbeSets)
<a name="l00126"></a>00126 {
<a name="l00127"></a>00127   m_pvExperiments = &amp;vExperiments;
<a name="l00128"></a>00128   m_pobjExperiment = vExperiments.getAt(experimentIndex);
<a name="l00129"></a>00129   m_pvProbeSets = &amp;vProbeSets;
<a name="l00130"></a>00130 }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 <span class="keywordtype">void</span> CNAnalysisMethod::setup(<a class="code" href="classCNExperimentArray.html" title="A vector of CNExperiment pointers.">CNExperimentArray</a>&amp; vExperiments, <a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>&amp; vProbeSets)
<a name="l00133"></a>00133 {
<a name="l00134"></a>00134   m_pvExperiments = &amp;vExperiments;
<a name="l00135"></a>00135   m_pvProbeSets = &amp;vProbeSets;
<a name="l00136"></a>00136 }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 <span class="keywordtype">void</span> CNAnalysisMethod::isSetup()
<a name="l00139"></a>00139 {
<a name="l00140"></a>00140   <span class="keywordflow">if</span> ((m_pobjExperiment == NULL) &amp;&amp; (m_pvProbeSets == NULL)) {
<a name="l00141"></a>00141     <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;CNAnalysisMethod &quot;</span> + getName() + <span class="stringliteral">&quot; is not setup properly.&quot;</span>);
<a name="l00142"></a>00142   }
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="keywordtype">void</span> CNAnalysisMethod::setDataSetOffset(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ui)
<a name="l00146"></a>00146 {
<a name="l00147"></a>00147   m_uiDataSetOffset = ui;
<a name="l00148"></a>00148 }
<a name="l00149"></a>00149 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> CNAnalysisMethod::getDataSetOffset()
<a name="l00150"></a>00150 {
<a name="l00151"></a>00151   <span class="keywordflow">return</span> m_uiDataSetOffset;
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keywordtype">void</span> CNAnalysisMethod::memory(<span class="keyword">const</span> <a class="code" href="classAffxString.html" title="A class derived from std::string.">AffxString</a>&amp; str)
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156   <span class="comment">/*</span>
<a name="l00157"></a>00157 <span class="comment">  static uint64_t init = 0;</span>
<a name="l00158"></a>00158 <span class="comment">  uint64_t free = 0;</span>
<a name="l00159"></a>00159 <span class="comment">  uint64_t total = 0;</span>
<a name="l00160"></a>00160 <span class="comment">  uint64_t swapAvailable = 0;</span>
<a name="l00161"></a>00161 <span class="comment">  uint64_t memAvailable = 0;</span>
<a name="l00162"></a>00162 <span class="comment">  Util::memInfo(free, total, swapAvailable, memAvailable, false);</span>
<a name="l00163"></a>00163 <span class="comment">  if (init == 0) {init = total - free;}</span>
<a name="l00164"></a>00164 <span class="comment">  int iMB = (int)((total - free - init) / 1048576.0);</span>
<a name="l00165"></a>00165 <span class="comment">  if (iMB &lt; 0) {iMB = 0;}</span>
<a name="l00166"></a>00166 <span class="comment">  Verbose::out(1, str + &quot;: Memory usage = &quot; + ::getInt(iMB) + &quot; MB&quot;);</span>
<a name="l00167"></a>00167 <span class="comment">  */</span>
<a name="l00168"></a>00168 }
<a name="l00169"></a>00169 <span class="comment"></span>
<a name="l00170"></a>00170 <span class="comment">/**</span>
<a name="l00171"></a>00171 <span class="comment"> * Constructor</span>
<a name="l00172"></a>00172 <span class="comment"> */</span>
<a name="l00173"></a><a class="code" href="classCNAnalysisMethod.html#ad3c383bef9cb50ed212322f3b57fd58a">00173</a> <a class="code" href="classCNAnalysisMethod.html#ad3c383bef9cb50ed212322f3b57fd58a" title="Constructor.">CNAnalysisMethod::CNAnalysisMethod</a>()
<a name="l00174"></a>00174 {
<a name="l00175"></a>00175     m_iInstanceCount++;
<a name="l00176"></a>00176     m_uiDataSetOffset = 0;
<a name="l00177"></a>00177     m_pEngine = NULL;
<a name="l00178"></a>00178     m_pobjExperiment = NULL;
<a name="l00179"></a>00179     m_pvExperiments = NULL;
<a name="l00180"></a>00180     m_pvProbeSets = NULL;
<a name="l00181"></a>00181     m_iXChromosome = 24;
<a name="l00182"></a>00182     m_iYChromosome = 25;
<a name="l00183"></a>00183     <span class="comment">//m_boundsFilled = false;</span>
<a name="l00184"></a>00184     m_pvProbes = NULL;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     m_iStep = 0;
<a name="l00187"></a>00187     m_iWindow = 0;
<a name="l00188"></a>00188     m_iPointCount = 0;
<a name="l00189"></a>00189     m_dBandwidth = 0;
<a name="l00190"></a>00190     m_dCutoff = 0;
<a name="l00191"></a>00191     m_dCleanThreshold = 0;
<a name="l00192"></a>00192     m_bSymmetry = <span class="keyword">false</span>;
<a name="l00193"></a>00193     m_boundsFilled=<span class="keyword">false</span>;
<a name="l00194"></a>00194 }
<a name="l00195"></a>00195 <span class="comment"></span>
<a name="l00196"></a>00196 <span class="comment">/**</span>
<a name="l00197"></a>00197 <span class="comment"> * Destructor</span>
<a name="l00198"></a>00198 <span class="comment"> */</span>
<a name="l00199"></a><a class="code" href="classCNAnalysisMethod.html#a40ea266805260524bc623fdf22300f9c">00199</a> <a class="code" href="classCNAnalysisMethod.html#a40ea266805260524bc623fdf22300f9c" title="Destructor.">CNAnalysisMethod::~CNAnalysisMethod</a>()
<a name="l00200"></a>00200 {
<a name="l00201"></a>00201   m_iInstanceCount--;
<a name="l00202"></a>00202   <span class="keywordflow">if</span> (m_iInstanceCount == 0) {
<a name="l00203"></a>00203     m_vCelFileParams.clear();
<a name="l00204"></a>00204     m_vParams.clear();
<a name="l00205"></a>00205   }
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 <span class="comment"></span>
<a name="l00208"></a>00208 <span class="comment">/**</span>
<a name="l00209"></a>00209 <span class="comment"> * Return SelfDoc option associated with a specified name.</span>
<a name="l00210"></a>00210 <span class="comment"> * @param std::vector&lt;SelfDoc::Opt&gt;&amp; - The SelfDoc options to search.</span>
<a name="l00211"></a>00211 <span class="comment"> * @param const std::string&amp; - The specified name to search for.</span>
<a name="l00212"></a>00212 <span class="comment"> * @return SelfDoc::Opt* - The SelfDoc option pointer or NULL if not found.</span>
<a name="l00213"></a>00213 <span class="comment"> */</span>
<a name="l00214"></a><a class="code" href="classCNAnalysisMethod.html#a1aa53722021e4bd41fc73a6be5b5de71">00214</a> <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a>* <a class="code" href="classCNAnalysisMethod.html#a1aa53722021e4bd41fc73a6be5b5de71" title="Return SelfDoc option associated with a specified name.">CNAnalysisMethod::getSelfDocOpt</a>(std::vector&lt;SelfDoc::Opt&gt;&amp; opts, <span class="keyword">const</span> std::string&amp; strName)
<a name="l00215"></a>00215 {
<a name="l00216"></a>00216   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; (iIndex &lt; opts.size()); iIndex++) {
<a name="l00217"></a>00217     <span class="keywordflow">if</span> (opts[iIndex].name == strName) {
<a name="l00218"></a>00218       <span class="keywordflow">return</span> &amp;opts[iIndex];
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220   }
<a name="l00221"></a>00221   <span class="keywordflow">return</span> NULL;
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 <span class="comment"></span>
<a name="l00224"></a>00224 <span class="comment">/**</span>
<a name="l00225"></a>00225 <span class="comment"> * Setup a bool parameter for this analysis method.</span>
<a name="l00226"></a>00226 <span class="comment"> * @param const std::string&amp; - The name of the parameter</span>
<a name="l00227"></a>00227 <span class="comment"> * @param const std::string&amp; - The prefix to use when setting up the header</span>
<a name="l00228"></a>00228 <span class="comment"> * @param std::map&lt;std::string,std::string&gt;&amp; - A map of parameters to fill in</span>
<a name="l00229"></a>00229 <span class="comment"> * @param SelfDoc&amp; - The SelfDoc object needed by the fillInValue function</span>
<a name="l00230"></a>00230 <span class="comment"> * @param std::vector&lt;SelfDoc::Opt&gt;&amp; - The SelfDoc option to setup.</span>
<a name="l00231"></a>00231 <span class="comment"> * @return bool - The value of the parameter as setup by this function.</span>
<a name="l00232"></a>00232 <span class="comment"> */</span>
<a name="l00233"></a><a class="code" href="classCNAnalysisMethod.html#ab0a31500922c8cb3c81dbd688ab0aadb">00233</a> <span class="keywordtype">bool</span> <a class="code" href="classCNAnalysisMethod.html#ab0a31500922c8cb3c81dbd688ab0aadb" title="Setup a bool parameter for this analysis method.">CNAnalysisMethod::setupBoolParameter</a>(<span class="keyword">const</span> std::string&amp; strName, <span class="keyword">const</span> std::string&amp; strPrefix, std::map&lt;std::string, std::string&gt;&amp; params, <a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a>&amp; doc, std::vector&lt;SelfDoc::Opt&gt;&amp; opts)
<a name="l00234"></a>00234 {
<a name="l00235"></a>00235   <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a>* popt = <a class="code" href="classCNAnalysisMethod.html#a1aa53722021e4bd41fc73a6be5b5de71" title="Return SelfDoc option associated with a specified name.">getSelfDocOpt</a>(opts, strName);
<a name="l00236"></a>00236   <span class="keywordflow">if</span> (popt == NULL) {
<a name="l00237"></a>00237     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt not found: &quot;</span> + strName));
<a name="l00238"></a>00238   }
<a name="l00239"></a>00239   <span class="keywordtype">bool</span> b = <a class="code" href="classAffxByteArray.html" title="A class for managing large byte arrays.">AffxByteArray</a>(popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ad2084a20b7322f83400915cbecaa9e87" title="Default value for option.">defaultVal</a>).parsebool();
<a name="l00240"></a>00240   fillInValue(b, std::string(strName), params, doc);
<a name="l00241"></a>00241   std::wstring wstr = <a class="code" href="classaffymetrix__calvin__utilities_1_1StringUtils.html#ade66e5470a852dd374eef3907954ac4c">affymetrix_calvin_utilities::StringUtils::ConvertMBSToWCS</a>(strPrefix + strName);
<a name="l00242"></a>00242   <a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html">affymetrix_calvin_parameter::ParameterNameValueType</a> param;
<a name="l00243"></a>00243   param.<a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html#ac2eb9ad835d3a8845385811f98ea9f2a">SetName</a>(wstr);
<a name="l00244"></a>00244   param.<a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html#a2e6ccd92aafd9a768e310f5719880643">SetValueInt8</a>(b);
<a name="l00245"></a>00245   m_vParams.push_back(param);
<a name="l00246"></a>00246   <span class="keywordflow">return</span> b;
<a name="l00247"></a>00247 }
<a name="l00248"></a>00248 <span class="comment"></span>
<a name="l00249"></a>00249 <span class="comment">/**</span>
<a name="l00250"></a>00250 <span class="comment"> * Setup an int parameter for this analysis method, including min amd max validation.</span>
<a name="l00251"></a>00251 <span class="comment"> * @param const std::string&amp; - The name of the parameter</span>
<a name="l00252"></a>00252 <span class="comment"> * @param const std::string&amp; - The prefix to use when setting up the header</span>
<a name="l00253"></a>00253 <span class="comment"> * @param std::map&lt;std::string,std::string&gt;&amp; - A map of parameters to fill in</span>
<a name="l00254"></a>00254 <span class="comment"> * @param SelfDoc&amp; - The SelfDoc object needed by the fillInValue function</span>
<a name="l00255"></a>00255 <span class="comment"> * @param std::vector&lt;SelfDoc::Opt&gt;&amp; - The SelfDoc option to setup.</span>
<a name="l00256"></a>00256 <span class="comment"> * @return int - The value of the parameter as setup by this function.</span>
<a name="l00257"></a>00257 <span class="comment"> */</span>
<a name="l00258"></a><a class="code" href="classCNAnalysisMethod.html#a72e009aa8390f61ca119d5204db6115c">00258</a> <span class="keywordtype">int</span> <a class="code" href="classCNAnalysisMethod.html#a72e009aa8390f61ca119d5204db6115c" title="Setup an int parameter for this analysis method, including min amd max validation.">CNAnalysisMethod::setupIntParameter</a>(<span class="keyword">const</span> std::string&amp; strName, <span class="keyword">const</span> std::string&amp; strPrefix, std::map&lt;std::string, std::string&gt;&amp; params, <a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a>&amp; doc, std::vector&lt;SelfDoc::Opt&gt;&amp; opts)
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260   <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a>* popt = <a class="code" href="classCNAnalysisMethod.html#a1aa53722021e4bd41fc73a6be5b5de71" title="Return SelfDoc option associated with a specified name.">getSelfDocOpt</a>(opts, strName);
<a name="l00261"></a>00261   <span class="keywordflow">if</span> (popt == NULL) {
<a name="l00262"></a>00262     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt not found: &quot;</span> + strName));
<a name="l00263"></a>00263   }
<a name="l00264"></a>00264   <span class="keywordtype">int</span> i =<a class="code" href="AffxConv_8cpp.html#ab7d46fb769602a66d9e19f96e792498d" title="Converts a string with commas into an int."> ::getInt</a>(popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ad2084a20b7322f83400915cbecaa9e87" title="Default value for option.">defaultVal</a>);
<a name="l00265"></a>00265   fillInValue(i, std::string(strName), params, doc);
<a name="l00266"></a>00266   <span class="keywordflow">if</span> ((popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a> != <span class="stringliteral">&quot;NA&quot;</span>) &amp;&amp; (popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a> != <span class="stringliteral">&quot;&quot;</span>) &amp;&amp; (i &lt; ::<a class="code" href="AffxConv_8cpp.html#ab7d46fb769602a66d9e19f96e792498d" title="Converts a string with commas into an int.">getInt</a>(popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a>))) {
<a name="l00267"></a>00267     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt &quot;</span> + strName + <span class="stringliteral">&quot; below minimum value of &quot;</span> + popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a>));
<a name="l00268"></a>00268   }
<a name="l00269"></a>00269   <span class="keywordflow">if</span> ((popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a> != <span class="stringliteral">&quot;NA&quot;</span>) &amp;&amp; (popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a> != <span class="stringliteral">&quot;&quot;</span>) &amp;&amp; (i &gt; ::<a class="code" href="AffxConv_8cpp.html#ab7d46fb769602a66d9e19f96e792498d" title="Converts a string with commas into an int.">getInt</a>(popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a>))) {
<a name="l00270"></a>00270     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt &quot;</span> + strName + <span class="stringliteral">&quot; above maximum value of &quot;</span> + popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a>));
<a name="l00271"></a>00271   }
<a name="l00272"></a>00272   std::wstring wstr = <a class="code" href="classaffymetrix__calvin__utilities_1_1StringUtils.html#ade66e5470a852dd374eef3907954ac4c">affymetrix_calvin_utilities::StringUtils::ConvertMBSToWCS</a>(strPrefix + strName);
<a name="l00273"></a>00273   <a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html">affymetrix_calvin_parameter::ParameterNameValueType</a> param;
<a name="l00274"></a>00274   param.<a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html#ac2eb9ad835d3a8845385811f98ea9f2a">SetName</a>(wstr);
<a name="l00275"></a>00275   param.<a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html#ab6641303770a83bf5aebf22b47cbac5e">SetValueInt32</a>(i);
<a name="l00276"></a>00276   m_vParams.push_back(param);
<a name="l00277"></a>00277   <span class="keywordflow">return</span> i;
<a name="l00278"></a>00278 }
<a name="l00279"></a>00279 <span class="comment"></span>
<a name="l00280"></a>00280 <span class="comment">/**</span>
<a name="l00281"></a>00281 <span class="comment"> * Setup a float parameter for this analysis method, including min amd max validation.</span>
<a name="l00282"></a>00282 <span class="comment"> * @param const std::string&amp; - The name of the parameter</span>
<a name="l00283"></a>00283 <span class="comment"> * @param const std::string&amp; - The prefix to use when setting up the header</span>
<a name="l00284"></a>00284 <span class="comment"> * @param std::map&lt;std::string,std::string&gt;&amp; - A map of parameters to fill in</span>
<a name="l00285"></a>00285 <span class="comment"> * @param SelfDoc&amp; - The SelfDoc object needed by the fillInValue function</span>
<a name="l00286"></a>00286 <span class="comment"> * @param std::vector&lt;SelfDoc::Opt&gt;&amp; - The SelfDoc option to setup.</span>
<a name="l00287"></a>00287 <span class="comment"> * @return float - The value of the parameter as setup by this function.</span>
<a name="l00288"></a>00288 <span class="comment"> */</span>
<a name="l00289"></a><a class="code" href="classCNAnalysisMethod.html#a595a9187f287c87e5904f4415d95d3cb">00289</a> <span class="keywordtype">float</span> <a class="code" href="classCNAnalysisMethod.html#a595a9187f287c87e5904f4415d95d3cb" title="Setup a float parameter for this analysis method, including min amd max validation.">CNAnalysisMethod::setupFloatParameter</a>(<span class="keyword">const</span> std::string&amp; strName, <span class="keyword">const</span> std::string&amp; strPrefix, std::map&lt;std::string, std::string&gt;&amp; params, <a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a>&amp; doc, std::vector&lt;SelfDoc::Opt&gt;&amp; opts)
<a name="l00290"></a>00290 {
<a name="l00291"></a>00291   <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a>* popt = <a class="code" href="classCNAnalysisMethod.html#a1aa53722021e4bd41fc73a6be5b5de71" title="Return SelfDoc option associated with a specified name.">getSelfDocOpt</a>(opts, strName);
<a name="l00292"></a>00292   <span class="keywordflow">if</span> (popt == NULL) {
<a name="l00293"></a>00293     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt not found: &quot;</span> + strName));
<a name="l00294"></a>00294   }
<a name="l00295"></a>00295   <span class="keywordtype">float</span> f = (float)::<a class="code" href="AffxConv_8cpp.html#a4e40c31006c5b45e47ea0240921b98b2" title="Converts a string with commas into a double.">getDouble</a>(popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ad2084a20b7322f83400915cbecaa9e87" title="Default value for option.">defaultVal</a>);
<a name="l00296"></a>00296   fillInValue(f, std::string(strName), params, doc);
<a name="l00297"></a>00297   <span class="keywordflow">if</span> ((popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a> != <span class="stringliteral">&quot;NA&quot;</span>) &amp;&amp; (popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a> != <span class="stringliteral">&quot;&quot;</span>) &amp;&amp; (f &lt; (<span class="keywordtype">float</span>)::<a class="code" href="AffxConv_8cpp.html#a4e40c31006c5b45e47ea0240921b98b2" title="Converts a string with commas into a double.">getDouble</a>(popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a>))) {
<a name="l00298"></a>00298     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt &quot;</span> + strName + <span class="stringliteral">&quot; below minimum value of &quot;</span> + popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a>));
<a name="l00299"></a>00299   }
<a name="l00300"></a>00300   <span class="keywordflow">if</span> ((popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a> != <span class="stringliteral">&quot;NA&quot;</span>) &amp;&amp; (popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a> != <span class="stringliteral">&quot;&quot;</span>) &amp;&amp; (f &gt; (<span class="keywordtype">float</span>)::<a class="code" href="AffxConv_8cpp.html#a4e40c31006c5b45e47ea0240921b98b2" title="Converts a string with commas into a double.">getDouble</a>(popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a>))) {
<a name="l00301"></a>00301     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt &quot;</span> + strName + <span class="stringliteral">&quot; above maximum value of &quot;</span> + popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a>));
<a name="l00302"></a>00302   }
<a name="l00303"></a>00303   std::wstring wstr = <a class="code" href="classaffymetrix__calvin__utilities_1_1StringUtils.html#ade66e5470a852dd374eef3907954ac4c">affymetrix_calvin_utilities::StringUtils::ConvertMBSToWCS</a>(strPrefix + strName);
<a name="l00304"></a>00304   <a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html">affymetrix_calvin_parameter::ParameterNameValueType</a> param;
<a name="l00305"></a>00305   param.<a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html#ac2eb9ad835d3a8845385811f98ea9f2a">SetName</a>(wstr);
<a name="l00306"></a>00306   param.<a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html#a17601dadaa07e7a1d955108df7fee9af">SetValueFloat</a>(f);
<a name="l00307"></a>00307   m_vParams.push_back(param);
<a name="l00308"></a>00308   <span class="keywordflow">return</span> f;
<a name="l00309"></a>00309 }
<a name="l00310"></a>00310 <span class="comment"></span>
<a name="l00311"></a>00311 <span class="comment">/**</span>
<a name="l00312"></a>00312 <span class="comment"> * Setup a double parameter for this analysis method, including min amd max validation.</span>
<a name="l00313"></a>00313 <span class="comment"> * @param const std::string&amp; - The name of the parameter</span>
<a name="l00314"></a>00314 <span class="comment"> * @param const std::string&amp; - The prefix to use when setting up the header</span>
<a name="l00315"></a>00315 <span class="comment"> * @param std::map&lt;std::string,std::string&gt;&amp; - A map of parameters to fill in</span>
<a name="l00316"></a>00316 <span class="comment"> * @param SelfDoc&amp; - The SelfDoc object needed by the fillInValue function</span>
<a name="l00317"></a>00317 <span class="comment"> * @param std::vector&lt;SelfDoc::Opt&gt;&amp; - The SelfDoc option to setup.</span>
<a name="l00318"></a>00318 <span class="comment"> * @return double - The value of the parameter as setup by this function.</span>
<a name="l00319"></a>00319 <span class="comment"> */</span>
<a name="l00320"></a><a class="code" href="classCNAnalysisMethod.html#a866c7f2fb9d785c9716277a9395f1701">00320</a> <span class="keywordtype">double</span> <a class="code" href="classCNAnalysisMethod.html#a866c7f2fb9d785c9716277a9395f1701" title="Setup a double parameter for this analysis method, including min amd max validation.">CNAnalysisMethod::setupDoubleParameter</a>(<span class="keyword">const</span> std::string&amp; strName, <span class="keyword">const</span> std::string&amp; strPrefix, std::map&lt;std::string, std::string&gt;&amp; params, <a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a>&amp; doc, std::vector&lt;SelfDoc::Opt&gt;&amp; opts)
<a name="l00321"></a>00321 {
<a name="l00322"></a>00322   <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a>* popt = <a class="code" href="classCNAnalysisMethod.html#a1aa53722021e4bd41fc73a6be5b5de71" title="Return SelfDoc option associated with a specified name.">getSelfDocOpt</a>(opts, strName);
<a name="l00323"></a>00323   <span class="keywordflow">if</span> (popt == NULL) {
<a name="l00324"></a>00324     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt not found: &quot;</span> + strName));
<a name="l00325"></a>00325   }
<a name="l00326"></a>00326   <span class="keywordtype">double</span> d = (float)::<a class="code" href="AffxConv_8cpp.html#a4e40c31006c5b45e47ea0240921b98b2" title="Converts a string with commas into a double.">getDouble</a>(popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ad2084a20b7322f83400915cbecaa9e87" title="Default value for option.">defaultVal</a>);
<a name="l00327"></a>00327   fillInValue(d, std::string(strName), params, doc);
<a name="l00328"></a>00328   <span class="keywordflow">if</span> ((popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a> != <span class="stringliteral">&quot;NA&quot;</span>) &amp;&amp; (popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a> != <span class="stringliteral">&quot;&quot;</span>) &amp;&amp; (d &lt; ::<a class="code" href="AffxConv_8cpp.html#a4e40c31006c5b45e47ea0240921b98b2" title="Converts a string with commas into a double.">getDouble</a>(popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a>))) {
<a name="l00329"></a>00329     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt &quot;</span> + strName + <span class="stringliteral">&quot; below minimum value of &quot;</span> + popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a>));
<a name="l00330"></a>00330   }
<a name="l00331"></a>00331   <span class="keywordflow">if</span> ((popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a> != <span class="stringliteral">&quot;NA&quot;</span>) &amp;&amp; (popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a> != <span class="stringliteral">&quot;&quot;</span>) &amp;&amp; (d &gt; ::<a class="code" href="AffxConv_8cpp.html#a4e40c31006c5b45e47ea0240921b98b2" title="Converts a string with commas into a double.">getDouble</a>(popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a>))) {
<a name="l00332"></a>00332     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt &quot;</span> + strName + <span class="stringliteral">&quot; above maximum value of &quot;</span> + popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a>));
<a name="l00333"></a>00333   }
<a name="l00334"></a>00334   std::wstring wstr = <a class="code" href="classaffymetrix__calvin__utilities_1_1StringUtils.html#ade66e5470a852dd374eef3907954ac4c">affymetrix_calvin_utilities::StringUtils::ConvertMBSToWCS</a>(strPrefix + strName);
<a name="l00335"></a>00335   <a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html">affymetrix_calvin_parameter::ParameterNameValueType</a> param;
<a name="l00336"></a>00336   param.<a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html#ac2eb9ad835d3a8845385811f98ea9f2a">SetName</a>(wstr);
<a name="l00337"></a>00337   param.<a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html#a17601dadaa07e7a1d955108df7fee9af">SetValueFloat</a>(d);
<a name="l00338"></a>00338   m_vParams.push_back(param);
<a name="l00339"></a>00339   <span class="keywordflow">return</span> d;
<a name="l00340"></a>00340 }
<a name="l00341"></a>00341 <span class="comment"></span>
<a name="l00342"></a>00342 <span class="comment">/**</span>
<a name="l00343"></a>00343 <span class="comment"> * Setup a string parameter for this analysis method, including min amd max validation.</span>
<a name="l00344"></a>00344 <span class="comment"> * @param const std::string&amp; - The name of the parameter</span>
<a name="l00345"></a>00345 <span class="comment"> * @param const std::string&amp; - The prefix to use when setting up the header</span>
<a name="l00346"></a>00346 <span class="comment"> * @param std::map&lt;std::string,std::string&gt;&amp; - A map of parameters to fill in</span>
<a name="l00347"></a>00347 <span class="comment"> * @param SelfDoc&amp; - The SelfDoc object needed by the fillInValue function</span>
<a name="l00348"></a>00348 <span class="comment"> * @param std::vector&lt;SelfDoc::Opt&gt;&amp; - The SelfDoc option to setup.</span>
<a name="l00349"></a>00349 <span class="comment"> * @return std::string - The value of the parameter as setup by this function.</span>
<a name="l00350"></a>00350 <span class="comment"> */</span>
<a name="l00351"></a><a class="code" href="classCNAnalysisMethod.html#a0c9676bddd27780bfc7a76d4224854d4">00351</a> std::string <a class="code" href="classCNAnalysisMethod.html#a0c9676bddd27780bfc7a76d4224854d4" title="Setup a string parameter for this analysis method, including min amd max validation.">CNAnalysisMethod::setupStringParameter</a>(<span class="keyword">const</span> std::string&amp; strName, <span class="keyword">const</span> std::string&amp; strPrefix, std::map&lt;std::string, std::string&gt;&amp; params, <a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a>&amp; doc, std::vector&lt;SelfDoc::Opt&gt;&amp; opts)
<a name="l00352"></a>00352 {
<a name="l00353"></a>00353   <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a>* popt = <a class="code" href="classCNAnalysisMethod.html#a1aa53722021e4bd41fc73a6be5b5de71" title="Return SelfDoc option associated with a specified name.">getSelfDocOpt</a>(opts, strName);
<a name="l00354"></a>00354   <span class="keywordflow">if</span> (popt == NULL) {
<a name="l00355"></a>00355     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt not found: &quot;</span> + strName));
<a name="l00356"></a>00356   }
<a name="l00357"></a>00357   std::string str = popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ad2084a20b7322f83400915cbecaa9e87" title="Default value for option.">defaultVal</a>;
<a name="l00358"></a>00358   fillInValue(str, std::string(strName), params, doc);
<a name="l00359"></a>00359   <span class="keywordflow">if</span> ((popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a> != <span class="stringliteral">&quot;&quot;</span>) &amp;&amp; (str &lt; popt-&gt;minVal)) {
<a name="l00360"></a>00360     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt &quot;</span> + strName + <span class="stringliteral">&quot; below minimum value of &quot;</span> + popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#a455ca615b7d6701aaa2dc396e2ab40cb" title="Minimum value acceptable for numeric types, or NA if not used.">minVal</a>));
<a name="l00361"></a>00361   }
<a name="l00362"></a>00362   <span class="keywordflow">if</span> ((popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a> != <span class="stringliteral">&quot;&quot;</span>) &amp;&amp; (str &gt; popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a>)) {
<a name="l00363"></a>00363     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;SelfDoc::Opt &quot;</span> + strName + <span class="stringliteral">&quot; above maximum value of &quot;</span> + popt-&gt;<a class="code" href="classSelfDoc_1_1Opt.html#ab1869db890b71d4249b169017033a187" title="Maximum value acceptable for numeric types, or NA if not used.">maxVal</a>));
<a name="l00364"></a>00364   }
<a name="l00365"></a>00365   std::wstring wstr = <a class="code" href="classaffymetrix__calvin__utilities_1_1StringUtils.html#ade66e5470a852dd374eef3907954ac4c">affymetrix_calvin_utilities::StringUtils::ConvertMBSToWCS</a>(strPrefix + strName);
<a name="l00366"></a>00366   <a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html">affymetrix_calvin_parameter::ParameterNameValueType</a> param;
<a name="l00367"></a>00367   param.<a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html#ac2eb9ad835d3a8845385811f98ea9f2a">SetName</a>(wstr);
<a name="l00368"></a>00368   param.<a class="code" href="classaffymetrix__calvin__parameter_1_1ParameterNameValueType.html#a5cb4644ca145eab52f8fa6f78123f818">SetValueAscii</a>(str);
<a name="l00369"></a>00369   m_vParams.push_back(param);
<a name="l00370"></a>00370   <span class="keywordflow">return</span> str;
<a name="l00371"></a>00371 }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 <span class="comment"></span>
<a name="l00374"></a>00374 <span class="comment">/**</span>
<a name="l00375"></a>00375 <span class="comment"> * Cache information about starts and stops on chromosomes.  As in STL,</span>
<a name="l00376"></a>00376 <span class="comment"> * the stops are one past the last position.</span>
<a name="l00377"></a>00377 <span class="comment"> */</span>
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 <span class="keywordtype">void</span> CNAnalysisMethod::fillChrBounds()
<a name="l00381"></a>00381 {
<a name="l00382"></a>00382   fillChrBoundsImpl(m_pvProbeSets, m_chrBounds);
<a name="l00383"></a>00383 }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 
<a name="l00386"></a>00386 pair&lt;int, int&gt; <a class="code" href="classCNAnalysisMethod.html#a1f549c0f7cd7509a01112e181a4e30e6" title="Return the bounds of chromosome.">CNAnalysisMethod::getChrBounds</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> chr)
<a name="l00387"></a>00387 {
<a name="l00388"></a>00388   <span class="keywordflow">return</span> <a class="code" href="classCNAnalysisMethod.html#a1f549c0f7cd7509a01112e181a4e30e6" title="Return the bounds of chromosome.">getChrBounds</a>(chr, getProbeSets());
<a name="l00389"></a>00389 }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="comment"></span>
<a name="l00392"></a>00392 <span class="comment">/**</span>
<a name="l00393"></a>00393 <span class="comment"> * Return the bounds of chromosome.</span>
<a name="l00394"></a>00394 <span class="comment"> * @param const int - The chromosome</span>
<a name="l00395"></a>00395 <span class="comment"> * @return pair&lt;int,int&gt; the start and stop of the chromosome.</span>
<a name="l00396"></a>00396 <span class="comment"> */</span>
<a name="l00397"></a><a class="code" href="classCNAnalysisMethod.html#a1f549c0f7cd7509a01112e181a4e30e6">00397</a> pair&lt;int, int&gt; <a class="code" href="classCNAnalysisMethod.html#a1f549c0f7cd7509a01112e181a4e30e6" title="Return the bounds of chromosome.">CNAnalysisMethod::getChrBounds</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> chr, <a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>* pvProbeSets)
<a name="l00398"></a>00398 {
<a name="l00399"></a>00399   <span class="comment">// Make sure that the desired map is filled.</span>
<a name="l00400"></a>00400   this-&gt;fillChrBoundsImpl(pvProbeSets, m_chrBounds);
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <span class="comment">// If the chromosome is not there, here is what you get.</span>
<a name="l00403"></a>00403   <span class="keywordflow">if</span> (m_chrBounds.find(chr) == m_chrBounds.end()) <span class="keywordflow">return</span> pair&lt;int, int&gt;(0, 0);
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <span class="comment">// If the chromosoem is there, here is what you get.</span>
<a name="l00406"></a>00406   <span class="keywordflow">return</span> m_chrBounds[chr];
<a name="l00407"></a>00407 }
<a name="l00408"></a>00408 <span class="comment"></span>
<a name="l00409"></a>00409 <span class="comment">/**</span>
<a name="l00410"></a>00410 <span class="comment"> * Returns a vector of chromosomes. Need to make sure that lvalue conforms</span>
<a name="l00411"></a>00411 <span class="comment"> * to the the assigment from this method call.</span>
<a name="l00412"></a>00412 <span class="comment"> * @return vector&lt;int&gt; the list of chromosomes as integers</span>
<a name="l00413"></a>00413 <span class="comment"> */</span>
<a name="l00414"></a><a class="code" href="classCNAnalysisMethod.html#a2f4ab1065c50fef804d6a133794c93bf">00414</a> vector&lt;int&gt; <a class="code" href="classCNAnalysisMethod.html#a2f4ab1065c50fef804d6a133794c93bf" title="Returns a vector of chromosomes.">CNAnalysisMethod::getChromosomes</a>(<a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a> * pvProbeSetArray)
<a name="l00415"></a>00415 {
<a name="l00416"></a>00416   <span class="comment">// Make sure that the desired map is filled.</span>
<a name="l00417"></a>00417   this-&gt;fillChrBoundsImpl(pvProbeSetArray, m_chrBounds);
<a name="l00418"></a>00418 
<a name="l00419"></a>00419   <span class="comment">// A vector with chromosomes as ints.</span>
<a name="l00420"></a>00420   vector&lt;int&gt;chr_vec;
<a name="l00421"></a>00421 
<a name="l00422"></a>00422   <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">int</span>, pair&lt;int, int&gt; &gt;::iterator iter = m_chrBounds.begin();
<a name="l00423"></a>00423        iter != m_chrBounds.end(); iter++) {
<a name="l00424"></a>00424     chr_vec.push_back(iter-&gt;first);
<a name="l00425"></a>00425   }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427   <span class="comment">// Return the vector of chromosomes.</span>
<a name="l00428"></a>00428   <span class="keywordflow">return</span> chr_vec;
<a name="l00429"></a>00429 }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 <span class="comment"></span>
<a name="l00432"></a>00432 <span class="comment">/**</span>
<a name="l00433"></a>00433 <span class="comment"> * Return the number of probesets for a specified chromosome.</span>
<a name="l00434"></a>00434 <span class="comment"> * @param int - The specified chromosome</span>
<a name="l00435"></a>00435 <span class="comment"> * @return int - The number of probe sets.</span>
<a name="l00436"></a>00436 <span class="comment"> */</span>
<a name="l00437"></a>00437 
<a name="l00438"></a><a class="code" href="classCNAnalysisMethod.html#ab1812e9a47b2a0974fab4f19391a58b3">00438</a> <span class="keywordtype">int</span> <a class="code" href="classCNAnalysisMethod.html#ab1812e9a47b2a0974fab4f19391a58b3" title="Return the number of probesets for a specified chromosome.">CNAnalysisMethod::getProbeSetCount</a>(<span class="keywordtype">int</span> chr, <a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>* pvProbeSets)
<a name="l00439"></a>00439 {
<a name="l00440"></a>00440   <span class="comment">// Make sure that the desired map is filled.</span>
<a name="l00441"></a>00441   this-&gt;fillChrBoundsImpl(pvProbeSets, m_chrBounds);
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   <span class="comment">// If the chromosome is not there, it has size 0.  If this is an</span>
<a name="l00444"></a>00444   <span class="comment">// error for some context then let the calling context handle the</span>
<a name="l00445"></a>00445   <span class="comment">// problem.</span>
<a name="l00446"></a>00446   <span class="keywordflow">if</span> (m_chrBounds.find(chr) == m_chrBounds.end()) <span class="keywordflow">return</span> 0;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   <span class="comment">// If the chromosoem is there, here is what you get.</span>
<a name="l00449"></a>00449   pair&lt;int, int&gt; chr_span = m_chrBounds[chr];
<a name="l00450"></a>00450   <span class="keywordflow">return</span> chr_span.second - chr_span.first;
<a name="l00451"></a>00451 }
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 <span class="keywordtype">void</span> CNAnalysisMethod::bin( std::vector&lt;float&gt;&amp; vValues,
<a name="l00454"></a>00454                             std::vector&lt;int&gt;&amp; vBinIndexes,
<a name="l00455"></a>00455                             <span class="keywordtype">int</span> iBinCount)
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457   vBinIndexes.resize(vValues.size());
<a name="l00458"></a>00458   <a class="code" href="classAffxMultiDimensionalArray.html">AffxMultiDimensionalArray&lt;float&gt;</a> vTemp(vValues.size());
<a name="l00459"></a>00459   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; (iIndex &lt; vValues.size()); iIndex++) {
<a name="l00460"></a>00460     vTemp.set(iIndex, vValues[iIndex]);
<a name="l00461"></a>00461   }
<a name="l00462"></a>00462   vTemp.quickSort();
<a name="l00463"></a>00463   <a class="code" href="classAffxMultiDimensionalArray.html">AffxMultiDimensionalArray&lt;float&gt;</a> v(iBinCount);
<a name="l00464"></a>00464   <span class="keywordtype">float</span> fPercentile = 0;
<a name="l00465"></a>00465   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iBinIndex = 0; (iBinIndex &lt; iBinCount); iBinIndex++) {
<a name="l00466"></a>00466     fPercentile = vTemp.percentile((1.0 / (<span class="keywordtype">double</span>)iBinCount) * (iBinIndex + 1), <span class="keyword">false</span>);
<a name="l00467"></a>00467     v.set(iBinIndex, fPercentile);
<a name="l00468"></a>00468   }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470   <span class="comment">// Do binning.</span>
<a name="l00471"></a>00471   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiLowIndex = 0;
<a name="l00472"></a>00472   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> uiHighIndex = 0;
<a name="l00473"></a>00473   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; (iIndex &lt; vValues.size()); iIndex++) {
<a name="l00474"></a>00474     vBinIndexes[iIndex] = -1;
<a name="l00475"></a>00475     v.binarySearch(vValues[iIndex], uiLowIndex, uiHighIndex);
<a name="l00476"></a>00476     vBinIndexes[iIndex] = uiHighIndex;
<a name="l00477"></a>00477     <span class="keywordflow">if</span> (vBinIndexes[iIndex] == -1) {
<a name="l00478"></a>00478       <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;Binning failed.&quot;</span>));
<a name="l00479"></a>00479     }
<a name="l00480"></a>00480   }
<a name="l00481"></a>00481 }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="comment"></span>
<a name="l00484"></a>00484 <span class="comment">/**</span>
<a name="l00485"></a>00485 <span class="comment"> * Adapted from AffxMultiDimensionalArray::percentile().</span>
<a name="l00486"></a>00486 <span class="comment"> * NB: dPercentile is forced &lt;= 1.0 as STL operator[] is unchecked.</span>
<a name="l00487"></a>00487 <span class="comment"> */</span>
<a name="l00488"></a><a class="code" href="classCNAnalysisMethod.html#a1642da07d40af08eb3ac6a2de13ccea2">00488</a> <span class="keywordtype">float</span> <a class="code" href="classCNAnalysisMethod.html#a1642da07d40af08eb3ac6a2de13ccea2" title="Adapted from AffxMultiDimensionalArray::percentile().">CNAnalysisMethod::getPercentile</a>(<span class="keyword">const</span> vector&lt;float&gt;&amp; vec, <span class="keywordtype">double</span> dPercentile)
<a name="l00489"></a>00489 {
<a name="l00490"></a>00490     dPercentile = min(dPercentile, 1.0);
<a name="l00491"></a>00491     <span class="keywordtype">double</span> dIndex = (vec.size() - 1) * dPercentile;
<a name="l00492"></a>00492     <span class="keywordtype">double</span> dMultiplier = dIndex - floor(dIndex);
<a name="l00493"></a>00493     <span class="keywordtype">int</span> low = (int)floor(dIndex);
<a name="l00494"></a>00494     <span class="keywordtype">int</span> high = (int)ceil(dIndex);
<a name="l00495"></a>00495 
<a name="l00496"></a>00496     <span class="keywordflow">return</span> vec[low] + dMultiplier*(vec[high] - vec[low]);
<a name="l00497"></a>00497 }
<a name="l00498"></a>00498 <span class="comment"></span>
<a name="l00499"></a>00499 <span class="comment">/**</span>
<a name="l00500"></a>00500 <span class="comment"> * Bin vValues[] into iBinCount bins containing equal number</span>
<a name="l00501"></a>00501 <span class="comment"> * of elements.</span>
<a name="l00502"></a>00502 <span class="comment"> * @param const vector&lt;float&gt; - the vector to be binned</span>
<a name="l00503"></a>00503 <span class="comment"> * @param vector&lt;int&gt; - bin assignments (0-based)</span>
<a name="l00504"></a>00504 <span class="comment"> */</span>
<a name="l00505"></a><a class="code" href="classCNAnalysisMethod.html#a81d12d272d79fb2457c36fdde7de1e0c">00505</a> <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethod.html#a81d12d272d79fb2457c36fdde7de1e0c" title="Bin vValues[] into iBinCount bins containing equal number of elements.">CNAnalysisMethod::binEqualNumber</a>(
<a name="l00506"></a>00506                                     <span class="keyword">const</span> std::vector&lt;float&gt;&amp; vValues,
<a name="l00507"></a>00507                                     std::vector&lt;int&gt;&amp; vBinIndexes,
<a name="l00508"></a>00508                                     <span class="keywordtype">int</span> iBinCount)
<a name="l00509"></a>00509 {
<a name="l00510"></a>00510     vector&lt;float&gt; vTemp(vValues);
<a name="l00511"></a>00511     std::sort(vTemp.begin(), vTemp.end());
<a name="l00512"></a>00512     vector&lt;float&gt; v(iBinCount);
<a name="l00513"></a>00513     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iBinIndex = 0; iBinIndex &lt; iBinCount; iBinIndex++) {
<a name="l00514"></a>00514         v[iBinIndex] = <a class="code" href="classCNAnalysisMethod.html#a1642da07d40af08eb3ac6a2de13ccea2" title="Adapted from AffxMultiDimensionalArray::percentile().">getPercentile</a>(vTemp, (iBinIndex + 1)/(<span class="keywordtype">double</span>)iBinCount);
<a name="l00515"></a>00515     }
<a name="l00516"></a>00516     <span class="comment">// Do binning.</span>
<a name="l00517"></a>00517     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; vValues.size(); iIndex++) {
<a name="l00518"></a>00518         vector&lt;float&gt;::iterator it = std::lower_bound(v.begin(), v.end(), vValues[iIndex]);
<a name="l00519"></a>00519         vBinIndexes[iIndex] = it - v.begin();
<a name="l00520"></a>00520     }
<a name="l00521"></a>00521 
<a name="l00522"></a>00522     <span class="comment">//Verbose::out(4, &quot;CNAnalysisMethod::binEqualNumber - vTemp range = [&quot; + Convert::toString(vTemp[0]) + &quot;, &quot; + </span>
<a name="l00523"></a>00523     <span class="comment">//    Convert::toString(vTemp[vTemp.size()-1]) + &quot;]&quot;);</span>
<a name="l00524"></a>00524     <span class="comment">//for (int i =0; i &lt; iBinCount; ++i)</span>
<a name="l00525"></a>00525     <span class="comment">//{</span>
<a name="l00526"></a>00526     <span class="comment">//    Verbose::out(4, &quot;   v[&quot; + Convert::toString(i) + &quot;]= &quot; + Convert::toString((double)v[i]));</span>
<a name="l00527"></a>00527     <span class="comment">//}</span>
<a name="l00528"></a>00528 }
<a name="l00529"></a>00529 <span class="comment"></span>
<a name="l00530"></a>00530 <span class="comment">/**</span>
<a name="l00531"></a>00531 <span class="comment"> * Bin vValues[] into iBinCount equally spaced bins.</span>
<a name="l00532"></a>00532 <span class="comment"> * @param const vector&lt;float&gt; - the vector to be binned</span>
<a name="l00533"></a>00533 <span class="comment"> * @param vector&lt;int&gt; - bin assignments (0-based)</span>
<a name="l00534"></a>00534 <span class="comment"> */</span>
<a name="l00535"></a><a class="code" href="classCNAnalysisMethod.html#ab54b0868e549930db0b759b60443bb87">00535</a> <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethod.html#ab54b0868e549930db0b759b60443bb87" title="Bin vValues[] into iBinCount equally spaced bins.">CNAnalysisMethod::binEqualSpacing</a>(
<a name="l00536"></a>00536                                     <span class="keyword">const</span> std::vector&lt;float&gt;&amp; vValues,
<a name="l00537"></a>00537                                     std::vector&lt;int&gt;&amp; vBinIndexes,
<a name="l00538"></a>00538                                     <span class="keywordtype">int</span> iBinCount)
<a name="l00539"></a>00539 {
<a name="l00540"></a>00540     vector&lt;float&gt; v(iBinCount);
<a name="l00541"></a>00541     vector&lt;float&gt;::const_iterator itMin = std::min_element(vValues.begin(), vValues.end());
<a name="l00542"></a>00542     vector&lt;float&gt;::const_iterator itMax = std::max_element(vValues.begin(), vValues.end());
<a name="l00543"></a>00543     <span class="keywordtype">float</span> <a class="code" href="snp_8label_8cpp.html#ad748ef26c031cf6086e3a490afd3a47f" title="difference in cumulative sums: i.e.">delta</a> = (*itMax - *itMin)/iBinCount;
<a name="l00544"></a>00544     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iBinIndex = 0; iBinIndex &lt; iBinCount; iBinIndex++) {
<a name="l00545"></a>00545         v[iBinIndex] = *itMin + (iBinIndex + 1)*delta;
<a name="l00546"></a>00546     }
<a name="l00547"></a>00547     <span class="comment">// Do binning.</span>
<a name="l00548"></a>00548     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; vValues.size(); iIndex++) {
<a name="l00549"></a>00549         vector&lt;float&gt;::iterator it = std::lower_bound(v.begin(), v.end(), vValues[iIndex]);
<a name="l00550"></a>00550         vBinIndexes[iIndex] = it - v.begin();
<a name="l00551"></a>00551     }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553     <span class="comment">//Verbose::out(4, &quot;CNAnalysisMethod::binEqualSpacing&quot;);</span>
<a name="l00554"></a>00554     <span class="comment">//for (int i =0; i &lt; iBinCount; ++i)</span>
<a name="l00555"></a>00555     <span class="comment">//{</span>
<a name="l00556"></a>00556     <span class="comment">//    Verbose::out(4, &quot;   v[&quot; + Convert::toString(i) + &quot;]= &quot; + Convert::toString((double)v[i]));</span>
<a name="l00557"></a>00557     <span class="comment">//}</span>
<a name="l00558"></a>00558 }
<a name="l00559"></a>00559 <span class="comment"></span>
<a name="l00560"></a>00560 <span class="comment">/** Bin vValues[] (presumed discrete) into bins containing equal values.</span>
<a name="l00561"></a>00561 <span class="comment">  * At the end the number of bins equals the number of distinct values.</span>
<a name="l00562"></a>00562 <span class="comment">  * @param const vector&lt;float&gt; - the vector to be binned</span>
<a name="l00563"></a>00563 <span class="comment">  * @param vector&lt;int&gt; - bin assignments (0-based)</span>
<a name="l00564"></a>00564 <span class="comment">  * @return int - number of created bins</span>
<a name="l00565"></a>00565 <span class="comment">  */</span>
<a name="l00566"></a><a class="code" href="classCNAnalysisMethod.html#a66c165a2261561adeae660bef0fc1b47">00566</a> <span class="keywordtype">int</span> <a class="code" href="classCNAnalysisMethod.html#a66c165a2261561adeae660bef0fc1b47" title="Bin vValues[] (presumed discrete) into bins containing equal values.">CNAnalysisMethod::covariateIsBinAssignment</a>(<span class="keyword">const</span> std::vector&lt;float&gt;&amp; vValues, std::vector&lt;int&gt;&amp; vBinIndexes)
<a name="l00567"></a>00567 {
<a name="l00568"></a>00568     vector&lt;float&gt; vTemp(vValues);
<a name="l00569"></a>00569     std::sort(vTemp.begin(), vTemp.end());
<a name="l00570"></a>00570     vTemp.erase(std::unique(vTemp.begin(), vTemp.end()), vTemp.end());
<a name="l00571"></a>00571 
<a name="l00572"></a>00572     <span class="comment">// Do binning</span>
<a name="l00573"></a>00573     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; vValues.size(); iIndex++) {
<a name="l00574"></a>00574         vector&lt;float&gt;::iterator it = std::lower_bound(vTemp.begin(), vTemp.end(), vValues[iIndex]);
<a name="l00575"></a>00575         vBinIndexes[iIndex] = it - vTemp.begin();
<a name="l00576"></a>00576     }
<a name="l00577"></a>00577     <span class="keywordflow">return</span> vTemp.size();
<a name="l00578"></a>00578 }
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 <span class="comment">// This was moved here from CNAnalysisMethodAllelePeaks since it is also used in Chipstream for normal-diploid determination.</span>
<a name="l00581"></a>00581 <span class="keywordtype">double</span> CNAnalysisMethod::bwnrd(<span class="keyword">const</span> vector&lt;double&gt; &amp;x, <span class="keywordtype">double</span> fac)
<a name="l00582"></a>00582 {
<a name="l00583"></a>00583   <span class="keywordtype">int</span> n = x.size();
<a name="l00584"></a>00584 
<a name="l00585"></a>00585   <span class="keywordflow">if</span> (x.size() &lt;= 2) {
<a name="l00586"></a>00586     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;The allele-peaks analysis method has failed. Vector size to small in bwnrd().&quot;</span>));
<a name="l00587"></a>00587   }
<a name="l00588"></a>00588 
<a name="l00589"></a>00589   <span class="comment">// Calculate interquartile range into h</span>
<a name="l00590"></a>00590   <span class="keywordtype">double</span> *tmpdata = <span class="keyword">new</span> <span class="keywordtype">double</span> [n];
<a name="l00591"></a>00591   <span class="keywordtype">int</span> prctile25 = (int)(.25 * n - .5);
<a name="l00592"></a>00592   <span class="keywordflow">if</span> (prctile25 &lt; 0) {
<a name="l00593"></a>00593     prctile25 = 0;
<a name="l00594"></a>00594   }
<a name="l00595"></a>00595   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {
<a name="l00596"></a>00596     tmpdata[i] = x[i];
<a name="l00597"></a>00597   }
<a name="l00598"></a>00598   <span class="keywordtype">double</span> val25 = klowest_select(tmpdata, n, prctile25);
<a name="l00599"></a>00599   <span class="keywordtype">int</span> prctile75 = (int)(.75 * n - .5);
<a name="l00600"></a>00600   <span class="keywordflow">if</span> (prctile75 &lt; 0) {
<a name="l00601"></a>00601     prctile75 = 0;
<a name="l00602"></a>00602   }
<a name="l00603"></a>00603   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {
<a name="l00604"></a>00604     tmpdata[i] = x[i];
<a name="l00605"></a>00605   }
<a name="l00606"></a>00606   <span class="keywordtype">double</span> val75 = klowest_select(tmpdata, n, prctile75);
<a name="l00607"></a>00607   <span class="keywordtype">double</span> h = (val75 - val25);
<a name="l00608"></a>00608 
<a name="l00609"></a>00609   <span class="keyword">delete</span> [] tmpdata;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <span class="comment">// calculate variance of x into var</span>
<a name="l00612"></a>00612   <span class="keywordtype">double</span> var = 0;
<a name="l00613"></a>00613   <span class="keywordtype">double</span> mean = 0;
<a name="l00614"></a>00614   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {
<a name="l00615"></a>00615     mean += x[i];
<a name="l00616"></a>00616   }
<a name="l00617"></a>00617   mean = mean / n;
<a name="l00618"></a>00618   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {
<a name="l00619"></a>00619     var += (x[i] - mean) * (x[i] - mean);
<a name="l00620"></a>00620   }
<a name="l00621"></a>00621   var = var / (n - 1);
<a name="l00622"></a>00622 
<a name="l00623"></a>00623   <span class="keywordflow">return</span> (fac * 1.06 * min(sqrt(var), h / 1.34) * pow((<span class="keywordtype">double</span>)n, -.2));
<a name="l00624"></a>00624 }
<a name="l00625"></a>00625 <span class="comment"></span>
<a name="l00626"></a>00626 <span class="comment">/**</span>
<a name="l00627"></a>00627 <span class="comment"> * kernel density() with an normal kernel</span>
<a name="l00628"></a>00628 <span class="comment"> * @param dat - data of interest.</span>
<a name="l00629"></a>00629 <span class="comment"> * @param weights (matches dat)</span>
<a name="l00630"></a>00630 <span class="comment"> * @param bandWidth</span>
<a name="l00631"></a>00631 <span class="comment"> *</span>
<a name="l00632"></a>00632 <span class="comment"> * @return - values in density evaluated at values xOut</span>
<a name="l00633"></a>00633 <span class="comment"> */</span>
<a name="l00634"></a><a class="code" href="classCNAnalysisMethod.html#a778159232b3c60eae22ab65041c8b0db">00634</a> <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethod.html#a778159232b3c60eae22ab65041c8b0db" title="kernel density() with an normal kernel">CNAnalysisMethod::kdensity</a>(vector&lt;double&gt; &amp;dat,
<a name="l00635"></a>00635                                 vector&lt;double&gt; &amp;density,
<a name="l00636"></a>00636                                 vector&lt;double&gt; &amp;xOut,
<a name="l00637"></a>00637                                 vector&lt;double&gt; &amp;weight,
<a name="l00638"></a>00638                                 <span class="keywordtype">double</span> bandWidth)
<a name="l00639"></a>00639 {
<a name="l00640"></a>00640   <span class="keywordtype">double</span> from, to, maximum, minimum;
<a name="l00641"></a>00641   <span class="comment">// vector&lt;float&gt; xOut(numBins, 0.0);</span>
<a name="l00642"></a>00642 
<a name="l00643"></a>00643   <span class="keywordflow">if</span> ((dat.size() &lt;= 0) || (density.size() &lt;= 0)) {
<a name="l00644"></a>00644     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;The allele-peaks analysis method has failed. Empty data or density vector in kdensity().&quot;</span>));
<a name="l00645"></a>00645   }
<a name="l00646"></a>00646   <span class="keywordtype">int</span> n = dat.size();
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   <span class="keywordtype">int</span> m = density.size();
<a name="l00649"></a>00649 
<a name="l00650"></a>00650   <span class="comment">// bandWidth = findBandWidth(dat);</span>
<a name="l00651"></a>00651   maximum = <a class="code" href="classCNAnalysisMethod.html#a42fad45b285246a5bcee4597a4730eee" title="Find the maximum value in a vector of doubles, should be moved to RMA.cpp.">vectorMax</a>(dat);
<a name="l00652"></a>00652   minimum = <a class="code" href="classCNAnalysisMethod.html#a8e5fce6a378e84b85765593c6519cea0" title="Find the minimum value in a vector of doubles, should be moved to RMA.cpp.">vectorMin</a>(dat);
<a name="l00653"></a>00653 
<a name="l00654"></a>00654   <span class="comment">/* Set the limits. */</span>
<a name="l00655"></a>00655   from = minimum - 3 * bandWidth;
<a name="l00656"></a>00656   to = maximum + 3 * bandWidth;
<a name="l00657"></a>00657   <span class="keywordtype">double</span> xDelta = (to - from) / (m - 1);
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m ; i++) {
<a name="l00660"></a>00660     xOut[i] = from + (i * xDelta);
<a name="l00661"></a>00661   }
<a name="l00662"></a>00662 
<a name="l00663"></a>00663   <span class="comment">// get lazy and allocate a big fat vector, no error checking</span>
<a name="l00664"></a>00664   vector&lt;double&gt; z(n*m, 0); <span class="comment">// n x m matrix</span>
<a name="l00665"></a>00665   <span class="keywordtype">int</span> k = 0;
<a name="l00666"></a>00666   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) { <span class="comment">// i-th row</span>
<a name="l00667"></a>00667     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m; ++j) {  <span class="comment">// j-th row</span>
<a name="l00668"></a>00668       <span class="comment">// apply the kernel</span>
<a name="l00669"></a>00669       z[k] = <a class="code" href="classCNAnalysisMethod.html#a6f020e7e926c0c3a6c29f526b8f3998c" title="Standard normal probability density function.">phi</a>((xOut[j] - dat[i]) / bandWidth);
<a name="l00670"></a>00670       k++;
<a name="l00671"></a>00671     }
<a name="l00672"></a>00672   }
<a name="l00673"></a>00673   vector&lt;int&gt; rowIndex(n, 0);
<a name="l00674"></a>00674   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) { <span class="comment">// i-th column</span>
<a name="l00675"></a>00675     rowIndex[i] = i * m;
<a name="l00676"></a>00676   }
<a name="l00677"></a>00677   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m; ++i) { <span class="comment">// i-th column</span>
<a name="l00678"></a>00678     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; n; ++j) {  <span class="comment">// j-th row</span>
<a name="l00679"></a>00679       density[i] += weight[j] * z[i+rowIndex[j]];
<a name="l00680"></a>00680     }
<a name="l00681"></a>00681     density[i] = density[i] / bandWidth;
<a name="l00682"></a>00682   }
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 <span class="keywordtype">double</span> CNAnalysisMethod::trapzoid(vector&lt;double&gt; &amp;x, vector&lt;double&gt; &amp;y)
<a name="l00686"></a>00686 {
<a name="l00687"></a>00687   <span class="comment">// x: x values</span>
<a name="l00688"></a>00688   <span class="comment">// y: y = f(x) values</span>
<a name="l00689"></a>00689   <span class="comment">// returns the integral of f</span>
<a name="l00690"></a>00690 
<a name="l00691"></a>00691   <span class="keywordtype">int</span> n = x.size();
<a name="l00692"></a>00692   <span class="keywordflow">if</span> ((y.size() != x.size()) || (n &lt;= 1)) {
<a name="l00693"></a>00693     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;The allele-peaks analysis method has failed. Unequal vector lengths in trapzoid().&quot;</span>));
<a name="l00694"></a>00694   }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696   vector&lt;vector&lt;double&gt; &gt; tmpdata(n);
<a name="l00697"></a>00697 
<a name="l00698"></a>00698   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {
<a name="l00699"></a>00699     vector&lt;double&gt; z(2);
<a name="l00700"></a>00700     z[0] = x[i];
<a name="l00701"></a>00701     z[1] = y[i];
<a name="l00702"></a>00702 
<a name="l00703"></a>00703     tmpdata[i] = z;
<a name="l00704"></a>00704   }
<a name="l00705"></a>00705   sort(tmpdata.begin(), tmpdata.end(), comparex());
<a name="l00706"></a>00706 
<a name="l00707"></a>00707   <span class="keywordtype">double</span> integral = 0;
<a name="l00708"></a>00708   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (n - 1); ++i) {
<a name="l00709"></a>00709     vector&lt;double&gt; z = tmpdata[i];
<a name="l00710"></a>00710     vector&lt;double&gt; z1 = tmpdata[i+1];
<a name="l00711"></a>00711     integral += (z1[1] + z[1]) * (z1[0] - z[0]) / 2;
<a name="l00712"></a>00712   }
<a name="l00713"></a>00713   <span class="keywordflow">return</span>(integral);
<a name="l00714"></a>00714 }
<a name="l00715"></a>00715 <span class="comment"></span>
<a name="l00716"></a>00716 <span class="comment">/**</span>
<a name="l00717"></a>00717 <span class="comment"> * Find the minimum value in a vector of doubles, should be moved to RMA.cpp</span>
<a name="l00718"></a>00718 <span class="comment"> *</span>
<a name="l00719"></a>00719 <span class="comment"> * @param dat - vector of data.</span>
<a name="l00720"></a>00720 <span class="comment"> *</span>
<a name="l00721"></a>00721 <span class="comment"> * @return minimum value.</span>
<a name="l00722"></a>00722 <span class="comment"> */</span>
<a name="l00723"></a><a class="code" href="classCNAnalysisMethod.html#a8e5fce6a378e84b85765593c6519cea0">00723</a> <span class="keywordtype">double</span> <a class="code" href="classCNAnalysisMethod.html#a8e5fce6a378e84b85765593c6519cea0" title="Find the minimum value in a vector of doubles, should be moved to RMA.cpp.">CNAnalysisMethod::vectorMin</a>(vector &lt;double&gt; &amp;dat)
<a name="l00724"></a>00724 {
<a name="l00725"></a>00725   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
<a name="l00726"></a>00726   <span class="keywordtype">double</span> minimum = -1;
<a name="l00727"></a>00727   <span class="keywordflow">if</span> (dat.size() &lt;= 0) {
<a name="l00728"></a>00728     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;The allele-peaks analysis method has failed. Data vector is empty in vectorMin().&quot;</span>));
<a name="l00729"></a>00729   }
<a name="l00730"></a>00730   minimum = dat[0];
<a name="l00731"></a>00731   <span class="keywordflow">for</span> (i = 0; i &lt; dat.size(); i++) {
<a name="l00732"></a>00732     minimum = min(minimum, dat[i]);
<a name="l00733"></a>00733   }
<a name="l00734"></a>00734   <span class="keywordflow">return</span> minimum;
<a name="l00735"></a>00735 }
<a name="l00736"></a>00736 <span class="comment"></span>
<a name="l00737"></a>00737 <span class="comment">/**</span>
<a name="l00738"></a>00738 <span class="comment"> * Find the maximum value in a vector of doubles, should be moved to RMA.cpp.</span>
<a name="l00739"></a>00739 <span class="comment"> *</span>
<a name="l00740"></a>00740 <span class="comment"> * @param dat - vector of data.</span>
<a name="l00741"></a>00741 <span class="comment"> *</span>
<a name="l00742"></a>00742 <span class="comment"> * @return maximum value.</span>
<a name="l00743"></a>00743 <span class="comment"> */</span>
<a name="l00744"></a><a class="code" href="classCNAnalysisMethod.html#a42fad45b285246a5bcee4597a4730eee">00744</a> <span class="keywordtype">double</span> <a class="code" href="classCNAnalysisMethod.html#a42fad45b285246a5bcee4597a4730eee" title="Find the maximum value in a vector of doubles, should be moved to RMA.cpp.">CNAnalysisMethod::vectorMax</a>(vector &lt;double&gt; &amp;dat)
<a name="l00745"></a>00745 {
<a name="l00746"></a>00746   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
<a name="l00747"></a>00747   <span class="keywordtype">double</span> maximum = -1;
<a name="l00748"></a>00748   <span class="keywordflow">if</span> (dat.size() &lt;= 0) {
<a name="l00749"></a>00749     <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;The allele-peaks analysis method has failed. Data vector is empty in vectorMax().&quot;</span>));
<a name="l00750"></a>00750   }
<a name="l00751"></a>00751   maximum = dat[0];
<a name="l00752"></a>00752   <span class="keywordflow">for</span> (i = 0; i &lt; dat.size(); i++) {
<a name="l00753"></a>00753     maximum = max(maximum, dat[i]);
<a name="l00754"></a>00754   }
<a name="l00755"></a>00755   <span class="keywordflow">return</span> maximum;
<a name="l00756"></a>00756 }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 <span class="comment"></span>
<a name="l00759"></a>00759 <span class="comment">/**</span>
<a name="l00760"></a>00760 <span class="comment"> * Standard normal probability density function.</span>
<a name="l00761"></a>00761 <span class="comment"> * @param x - value of interest.</span>
<a name="l00762"></a>00762 <span class="comment"> * @return - density at value supplied</span>
<a name="l00763"></a>00763 <span class="comment"> */</span>
<a name="l00764"></a>00764 <span class="comment">//double RMA::phi(double x){</span>
<a name="l00765"></a><a class="code" href="classCNAnalysisMethod.html#a6f020e7e926c0c3a6c29f526b8f3998c">00765</a> <span class="keywordtype">double</span> <a class="code" href="classCNAnalysisMethod.html#a6f020e7e926c0c3a6c29f526b8f3998c" title="Standard normal probability density function.">CNAnalysisMethod::phi</a>(<span class="keywordtype">double</span> x)
<a name="l00766"></a>00766 {
<a name="l00767"></a>00767   <span class="keywordtype">double</span> pi = 3.14159265358979323846;
<a name="l00768"></a>00768   <span class="keywordflow">return</span> 1 / sqrt(2 * pi)* exp(-0.5 * x * x);
<a name="l00769"></a>00769 }
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 
<a name="l00772"></a>00772 <span class="comment">/*==================================================================================*/</span>
<a name="l00773"></a>00773 <span class="comment">/* Mean function applied to (running) window. All additions performed using         */</span>
<a name="l00774"></a>00774 <span class="comment">/* addition algorithm which tracks and corrects addition round-off errors (see      */</span>
<a name="l00775"></a>00775 <span class="comment">/*  http://www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps)*/</span>
<a name="l00776"></a>00776 <span class="comment">/* Input :                                                                          */</span>
<a name="l00777"></a>00777 <span class="comment">/*   In   - array to run moving window over will remain umchanged                   */</span>
<a name="l00778"></a>00778 <span class="comment">/*   Out  - empty space for array to store the results                              */</span>
<a name="l00779"></a>00779 <span class="comment">/*   nIn  - size of arrays In and Out                                               */</span>
<a name="l00780"></a>00780 <span class="comment">/*   nWin - size of the moving window                                               */</span>
<a name="l00781"></a>00781 <span class="comment">/* Output :                                                                         */</span>
<a name="l00782"></a>00782 <span class="comment">/*   Out  - results of runing moving window over array In and colecting window mean */</span>
<a name="l00783"></a>00783 <span class="comment">/*==================================================================================*/</span>
<a name="l00784"></a>00784 
<a name="l00785"></a>00785 <span class="comment">/* SumErr - macro calculating error of the summing operation */</span>
<a name="l00786"></a>00786 <span class="preprocessor">#define SumErr(a,b,ab) ((((a)&gt;(b)) == ((a)&gt;-(b))) ?  (b) - ((ab)-(a)) : (a) - ((ab)-(b)) )</span>
<a name="l00787"></a>00787 <span class="preprocessor"></span><span class="comment">/* SUM_1 - macro for calculating Sum+=x; Num+=n; Which is NaN aware and have minimal (single number) overflow error correction */</span>
<a name="l00788"></a>00788 <span class="preprocessor">#define SUM_1(x,n, Sum, Err, Num)   if (x == x){ y=Sum; Err+=x; Sum+=Err; Num+=n; Err=SumErr(y,Err,Sum);  }</span>
<a name="l00789"></a>00789 <span class="preprocessor"></span>
<a name="l00790"></a>00790 <span class="keywordtype">void</span> CNAnalysisMethod::runmean(<span class="keywordtype">double</span> *In, <span class="keywordtype">double</span> *Out, <span class="keyword">const</span> <span class="keywordtype">int</span> *nIn, <span class="keyword">const</span> <span class="keywordtype">int</span> *nWin)
<a name="l00791"></a>00791 {
<a name="l00792"></a>00792   <span class="comment">/* medium size version with NaN&#39;s and edge calculation, but only one level of round-off correction*/</span>
<a name="l00793"></a>00793   <span class="keywordtype">int</span> i, k1, k2, Num, n = *nIn, m = *nWin;
<a name="l00794"></a>00794   <span class="keywordtype">double</span> *in, y, *out, <a class="code" href="classErr.html" title="Err.">Err</a>, Sum;
<a name="l00795"></a>00795   <span class="keywordtype">double</span> NaN = std::numeric_limits&lt;double&gt;::quiet_NaN();
<a name="l00796"></a>00796   k2  = m &gt;&gt; 1;       <span class="comment">/* right half of window size */</span>
<a name="l00797"></a>00797   k1  = m - k2 - 1;  <span class="comment">/* left half of window size */</span>
<a name="l00798"></a>00798   in = In; out = Out;
<a name="l00799"></a>00799   Sum = 0;           <span class="comment">/* we need to calculate initial &#39;Sum&#39; */</span>
<a name="l00800"></a>00800   Err = 0;
<a name="l00801"></a>00801   Num = 0;
<a name="l00802"></a>00802   <span class="comment">/* step 1 - find mean of elements 0:(k2-1) */</span>
<a name="l00803"></a>00803   <span class="keywordflow">for</span> (i = 0; i &lt; k2; i++) {
<a name="l00804"></a>00804     SUM_1(in[i], 1, Sum, Err, Num)
<a name="l00805"></a>00805   }
<a name="l00806"></a>00806   <span class="comment">/* step 2 - left edge - start expanding the moving window to the right */</span>
<a name="l00807"></a>00807   <span class="keywordflow">for</span> (i = k2; i &lt; m; i++, out++) {
<a name="l00808"></a>00808     SUM_1(in[i], 1, Sum, Err, Num)
<a name="l00809"></a>00809     *out = (Num ? (Sum + Err) / Num : NaN);  <span class="comment">/* save mean and move window */</span>
<a name="l00810"></a>00810   }
<a name="l00811"></a>00811   <span class="comment">/* step 3: runsum of the rest of the vector. Inside loop is same as:   */</span>
<a name="l00812"></a>00812   <span class="comment">/* *out = *(out-1) - *in + *(in+m); but with round of error correction */</span>
<a name="l00813"></a>00813   <span class="keywordflow">for</span> (i = m; i &lt; n; i++, out++, in++) {
<a name="l00814"></a>00814     SUM_1(in[m] ,  1, Sum, Err, Num)
<a name="l00815"></a>00815     SUM_1(-(*in), -1, Sum, Err, Num)
<a name="l00816"></a>00816     *out = (Num ? (Sum + Err) / Num : NaN);  <span class="comment">/* save mean and move window */</span>
<a name="l00817"></a>00817   }
<a name="l00818"></a>00818   <span class="comment">/* step 4 - right edge - right side reached the end and left is shrinking  */</span>
<a name="l00819"></a>00819   for (i = 0; i &lt; k2; i++, out++, in++) {
<a name="l00820"></a>00820     SUM_1(-(*in), -1, Sum, Err, Num)
<a name="l00821"></a>00821     *out = (Num ? (Sum + Err) / Num : NaN);  <span class="comment">/* save mean and move window */</span>
<a name="l00822"></a>00822   }
<a name="l00823"></a>00823 }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825 <span class="keywordtype">double</span> CNAnalysisMethod::corr(Matrix&amp; mx1, Matrix&amp; mx2)
<a name="l00826"></a>00826 {
<a name="l00827"></a>00827   ColumnVector v1 = mx1.AsColumn();
<a name="l00828"></a>00828   ColumnVector v2 = mx2.AsColumn();
<a name="l00829"></a>00829   <span class="keywordflow">if</span> (v1.Nrows() != v2.Nrows()) {
<a name="l00830"></a>00830     <span class="keywordflow">return</span> std::numeric_limits&lt;double&gt;::quiet_NaN();
<a name="l00831"></a>00831   }
<a name="l00832"></a>00832   <span class="keywordtype">int</span> iLength = v1.Nrows();
<a name="l00833"></a>00833   <span class="keywordtype">double</span> dSum = 0;
<a name="l00834"></a>00834   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iElementIndex = 0; (iElementIndex &lt; iLength); iElementIndex++) {
<a name="l00835"></a>00835     dSum += v1.element(iElementIndex);
<a name="l00836"></a>00836   }
<a name="l00837"></a>00837   <span class="keywordtype">double</span> m1 = (dSum / (double)iLength);
<a name="l00838"></a>00838   dSum = 0;
<a name="l00839"></a>00839   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iElementIndex = 0; (iElementIndex &lt; iLength); iElementIndex++) {
<a name="l00840"></a>00840     dSum += v2.element(iElementIndex);
<a name="l00841"></a>00841   }
<a name="l00842"></a>00842   <span class="keywordtype">double</span> m2 = (dSum / (double)iLength);
<a name="l00843"></a>00843   <span class="keywordtype">double</span> dNumerator = 0;
<a name="l00844"></a>00844   <span class="keywordtype">double</span> d1 = 0;;
<a name="l00845"></a>00845   <span class="keywordtype">double</span> d2 = 0;
<a name="l00846"></a>00846   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iElementIndex = 0; (iElementIndex &lt; iLength); iElementIndex++) {
<a name="l00847"></a>00847     dNumerator += (v1.element(iElementIndex) - m1) * (v2.element(iElementIndex) - m2);
<a name="l00848"></a>00848     d1 += (v1.element(iElementIndex) - m1) * (v1.element(iElementIndex) - m1) ;
<a name="l00849"></a>00849     d2 += (v2.element(iElementIndex) - m2) * (v2.element(iElementIndex) - m2) ;
<a name="l00850"></a>00850   }
<a name="l00851"></a>00851   <span class="keywordtype">double</span> dDenominator = sqrt(d1 * d2);
<a name="l00852"></a>00852   <span class="keywordflow">return</span> dNumerator / dDenominator;
<a name="l00853"></a>00853 }
<a name="l00854"></a>00854 
<a name="l00855"></a>00855 <span class="keywordtype">double</span> CNAnalysisMethod::norm(Matrix&amp; mx)
<a name="l00856"></a>00856 {
<a name="l00857"></a>00857   ColumnVector v = mx.AsColumn();
<a name="l00858"></a>00858   <span class="keywordtype">int</span> iLength = v.Nrows();
<a name="l00859"></a>00859   <span class="keywordtype">double</span> dSum = 0;
<a name="l00860"></a>00860   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iElementIndex = 0; (iElementIndex &lt; iLength); iElementIndex++) {
<a name="l00861"></a>00861     dSum += v.element(iElementIndex) * v.element(iElementIndex);
<a name="l00862"></a>00862   }
<a name="l00863"></a>00863   <span class="keywordflow">return</span> sqrt(dSum);
<a name="l00864"></a>00864   <span class="comment">/*</span>
<a name="l00865"></a>00865 <span class="comment">  DiagonalMatrix D;</span>
<a name="l00866"></a>00866 <span class="comment">  SVD(v, D);</span>
<a name="l00867"></a>00867 <span class="comment">  return D.Maximum();</span>
<a name="l00868"></a>00868 <span class="comment">  */</span>
<a name="l00869"></a>00869 }
<a name="l00870"></a>00870 
<a name="l00871"></a>00871 <span class="keywordtype">double</span> CNAnalysisMethod::var(Matrix&amp; mx)
<a name="l00872"></a>00872 {
<a name="l00873"></a>00873   ColumnVector v = mx.AsColumn();
<a name="l00874"></a>00874   <span class="keywordtype">int</span> iLength = v.Nrows();
<a name="l00875"></a>00875   <span class="keywordtype">double</span> dSum = 0;
<a name="l00876"></a>00876   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iElementIndex = 0; (iElementIndex &lt; iLength); iElementIndex++) {
<a name="l00877"></a>00877     dSum += v.element(iElementIndex);
<a name="l00878"></a>00878   }
<a name="l00879"></a>00879   <span class="keywordtype">double</span> dMean = (dSum / (double)iLength);
<a name="l00880"></a>00880   <span class="keywordtype">double</span> dVariance = 0.0;
<a name="l00881"></a>00881   <span class="keywordflow">if</span> (iLength &gt; 1) {
<a name="l00882"></a>00882     <span class="keywordtype">double</span> dSumOfSquares = 0.0;
<a name="l00883"></a>00883     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; (iIndex &lt; iLength); iIndex++) {
<a name="l00884"></a>00884       dSumOfSquares += ((v.element(iIndex) - dMean) * (v.element(iIndex) - dMean));
<a name="l00885"></a>00885     }
<a name="l00886"></a>00886     dVariance = dSumOfSquares / (iLength - 1);
<a name="l00887"></a>00887   }
<a name="l00888"></a>00888   <span class="keywordflow">return</span> dVariance;
<a name="l00889"></a>00889 }
<a name="l00890"></a>00890 <span class="comment"></span>
<a name="l00891"></a>00891 <span class="comment">/**</span>
<a name="l00892"></a>00892 <span class="comment"> * Get the last autosome chromosome. As defined by being the last chromosome before the X chromosome value.</span>
<a name="l00893"></a>00893 <span class="comment"> * @return int - The chromosome number</span>
<a name="l00894"></a>00894 <span class="comment"> */</span>
<a name="l00895"></a><a class="code" href="classCNAnalysisMethod.html#a1dfc63d58d6dc606f165d47de0502390">00895</a> <span class="keywordtype">int</span> <a class="code" href="classCNAnalysisMethod.html#a1dfc63d58d6dc606f165d47de0502390" title="Get the last autosome chromosome.">CNAnalysisMethod::getLastAutosomeChromosome</a>()
<a name="l00896"></a>00896 {
<a name="l00897"></a>00897   <span class="keywordtype">int</span> iLastAutosomeChromosome = 1;
<a name="l00898"></a>00898   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; (iIndex &lt; getProbeSets()-&gt;getCount()); iIndex++) {
<a name="l00899"></a>00899     <a class="code" href="classCNProbeSet.html" title="A class to store probe set data.">CNProbeSet</a>* pobjProbeSet = getProbeSets()-&gt;getAt(iIndex);
<a name="l00900"></a>00900     <span class="keywordflow">if</span> (pobjProbeSet-&gt;getChromosome() &lt; m_iXChromosome) {
<a name="l00901"></a>00901       iLastAutosomeChromosome = <a class="code" href="affy-base-types_8h.html#a4886a8f966a69949cefc46a6a3468006">Max</a>(iLastAutosomeChromosome, (<span class="keywordtype">int</span>)pobjProbeSet-&gt;getChromosome());
<a name="l00902"></a>00902     }
<a name="l00903"></a>00903   }
<a name="l00904"></a>00904   <span class="keywordflow">return</span> iLastAutosomeChromosome;
<a name="l00905"></a>00905 }
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 <span class="preprocessor">#define ELEM_TYPE double</span>
<a name="l00908"></a>00908 <span class="preprocessor"></span>
<a name="l00909"></a>00909 <span class="preprocessor">#define ELEM_SWAP(a,b) { register ELEM_TYPE t=(a);(a)=(b);(b)=t; }</span>
<a name="l00910"></a>00910 <span class="preprocessor"></span>
<a name="l00911"></a>00911 ELEM_TYPE CNAnalysisMethod::klowest_select(ELEM_TYPE data[], <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> klowest)
<a name="l00912"></a>00912 {
<a name="l00913"></a>00913 
<a name="l00914"></a>00914   <span class="keywordtype">int</span> low, high ;
<a name="l00915"></a>00915   <span class="keywordtype">int</span> partition, ll, hh;
<a name="l00916"></a>00916 
<a name="l00917"></a>00917   low = 0 ; high = n - 1 ;
<a name="l00918"></a>00918   <span class="keywordflow">for</span> (;;) {
<a name="l00919"></a>00919     <span class="keywordflow">if</span> (high &lt;= low) <span class="comment">/* One element only */</span>
<a name="l00920"></a>00920       <span class="keywordflow">return</span> data[klowest] ;
<a name="l00921"></a>00921 
<a name="l00922"></a>00922     <span class="keywordflow">if</span> (high == low + 1) { <span class="comment">/* Two elements only */</span>
<a name="l00923"></a>00923       <span class="keywordflow">if</span> (data[low] &gt; data[high])
<a name="l00924"></a>00924         ELEM_SWAP(data[low], data[high]) ;
<a name="l00925"></a>00925       <span class="keywordflow">return</span> data[klowest] ;
<a name="l00926"></a>00926     }
<a name="l00927"></a>00927 
<a name="l00928"></a>00928     <span class="comment">/* Find the partition of low and high items; swap into position low */</span>
<a name="l00929"></a>00929     partition = (low + high) / 2;
<a name="l00930"></a>00930     <span class="keywordflow">if</span> (data[partition] &gt; data[high]) {
<a name="l00931"></a>00931       ELEM_SWAP(data[partition], data[high]) ;
<a name="l00932"></a>00932     }
<a name="l00933"></a>00933     <span class="keywordflow">if</span> (data[low] &gt; data[high]) {
<a name="l00934"></a>00934       ELEM_SWAP(data[low], data[high]) ;
<a name="l00935"></a>00935     }
<a name="l00936"></a>00936     <span class="keywordflow">if</span> (data[partition] &gt; data[low]) {
<a name="l00937"></a>00937       ELEM_SWAP(data[partition], data[low]) ;
<a name="l00938"></a>00938     }
<a name="l00939"></a>00939 
<a name="l00940"></a>00940     <span class="comment">/* Swap low item (now in position partition) into position (low+1) */</span>
<a name="l00941"></a>00941     ELEM_SWAP(data[partition], data[low+1]) ;
<a name="l00942"></a>00942 
<a name="l00943"></a>00943     <span class="comment">/* Nibble from each end towards pivot, swapping items when stuck */</span>
<a name="l00944"></a>00944     ll = low + 1;
<a name="l00945"></a>00945     hh = high;
<a name="l00946"></a>00946     <span class="keywordflow">for</span> (;;) {
<a name="l00947"></a>00947       <span class="keywordflow">do</span> ll++; <span class="keywordflow">while</span> (data[low] &gt; data[ll]) ;
<a name="l00948"></a>00948       <span class="keywordflow">do</span> hh--; <span class="keywordflow">while</span> (data[hh]  &gt; data[low]) ;
<a name="l00949"></a>00949 
<a name="l00950"></a>00950       <span class="keywordflow">if</span> (hh &lt; ll)
<a name="l00951"></a>00951         <span class="keywordflow">break</span>;
<a name="l00952"></a>00952 
<a name="l00953"></a>00953       ELEM_SWAP(data[ll], data[hh]) ;
<a name="l00954"></a>00954     }
<a name="l00955"></a>00955 
<a name="l00956"></a>00956     <span class="comment">/* Swap middle item (in position low) back into correct position */</span>
<a name="l00957"></a>00957     ELEM_SWAP(data[low], data[hh]) ;
<a name="l00958"></a>00958 
<a name="l00959"></a>00959     <span class="comment">/* Re-set active partition */</span>
<a name="l00960"></a>00960     <span class="keywordflow">if</span> (hh &lt;= klowest)
<a name="l00961"></a>00961       low = ll;
<a name="l00962"></a>00962     <span class="keywordflow">if</span> (hh &gt;= klowest)
<a name="l00963"></a>00963       high = hh - 1;
<a name="l00964"></a>00964   }
<a name="l00965"></a>00965 }
<a name="l00966"></a>00966 
<a name="l00967"></a>00967 <span class="preprocessor">#undef ELEM_SWAP</span>
<a name="l00968"></a>00968 <span class="preprocessor"></span><span class="preprocessor">#undef ELEM_TYPE</span>
<a name="l00969"></a>00969 <span class="preprocessor"></span>
<a name="l00970"></a>00970 <span class="keywordtype">double</span> CNAnalysisMethod::percentile(<span class="keywordtype">double</span> prctile, <span class="keywordtype">double</span>* data, <span class="keywordtype">int</span> m)
<a name="l00971"></a>00971 {
<a name="l00972"></a>00972   <span class="keywordtype">int</span> tmp_len, nMeds;
<a name="l00973"></a>00973   <span class="keywordtype">int</span> incr, jump;
<a name="l00974"></a>00974   tmp_len = m;
<a name="l00975"></a>00975   nMeds = 1;
<a name="l00976"></a>00976   incr = 1;
<a name="l00977"></a>00977   jump = m;
<a name="l00978"></a>00978 
<a name="l00979"></a>00979   <span class="keywordtype">int</span> klowest = (int)((prctile / 100) * tmp_len - .5);
<a name="l00980"></a>00980   <span class="keywordflow">if</span> (klowest &lt; 0) {
<a name="l00981"></a>00981     klowest = 0;
<a name="l00982"></a>00982   }
<a name="l00983"></a>00983   <span class="keywordtype">double</span> dResult = 0;
<a name="l00984"></a>00984   <span class="keywordtype">double</span>* result = &amp;dResult;
<a name="l00985"></a>00985 
<a name="l00986"></a>00986   <span class="keywordtype">double</span> *tmpdata = <span class="keyword">new</span> <span class="keywordtype">double</span> [tmp_len];
<a name="l00987"></a>00987   <span class="keywordtype">int</span> indexdata = 0;
<a name="l00988"></a>00988   <span class="keywordtype">int</span> indexstart = 0;
<a name="l00989"></a>00989   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; nMeds; ++j) {
<a name="l00990"></a>00990     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; tmp_len; ++i) {
<a name="l00991"></a>00991       tmpdata[i] = data[indexdata];
<a name="l00992"></a>00992       indexdata = indexdata + incr;
<a name="l00993"></a>00993     }
<a name="l00994"></a>00994     indexstart = indexstart + jump;
<a name="l00995"></a>00995     indexdata = indexstart;
<a name="l00996"></a>00996     <span class="comment">// klowest_select returns the k-th zero-based order statistic</span>
<a name="l00997"></a>00997     <span class="keywordtype">double</span> *jresult = result + j;
<a name="l00998"></a>00998     *jresult = klowest_select(tmpdata, tmp_len, klowest);
<a name="l00999"></a>00999 
<a name="l01000"></a>01000     <span class="comment">// look for any data point with value larger than k-th order statistic</span>
<a name="l01001"></a>01001     <span class="keywordtype">double</span> next = *jresult;
<a name="l01002"></a>01002     <span class="keywordtype">int</span> nlower = -1;
<a name="l01003"></a>01003     <span class="keywordtype">int</span> k = tmp_len;
<a name="l01004"></a>01004     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; tmp_len; ++i) {
<a name="l01005"></a>01005       <span class="keywordflow">if</span> (tmpdata[i] &gt; *jresult) {
<a name="l01006"></a>01006         next = tmpdata[i];
<a name="l01007"></a>01007         k = i;
<a name="l01008"></a>01008         <span class="keywordflow">break</span>;
<a name="l01009"></a>01009       }
<a name="l01010"></a>01010       <span class="keywordflow">if</span> (tmpdata[i] &lt;= *jresult) {
<a name="l01011"></a>01011         nlower++;
<a name="l01012"></a>01012       }
<a name="l01013"></a>01013     }
<a name="l01014"></a>01014     <span class="comment">// find the data point larger than k-th order statistic</span>
<a name="l01015"></a>01015     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = k; i &lt; tmp_len; ++i) {
<a name="l01016"></a>01016       <span class="keywordflow">if</span> (tmpdata[i] &lt;= *jresult) {
<a name="l01017"></a>01017         nlower++;
<a name="l01018"></a>01018       }
<a name="l01019"></a>01019       <span class="keywordflow">if</span> ((tmpdata[i] &gt; *jresult) &amp;&amp; (tmpdata[i] &lt; next)) {
<a name="l01020"></a>01020         next = tmpdata[i];
<a name="l01021"></a>01021       }
<a name="l01022"></a>01022     }
<a name="l01023"></a>01023     <span class="keywordtype">double</span> incr = next - *jresult;
<a name="l01024"></a>01024     <span class="keywordflow">if</span> (nlower &gt; klowest) {
<a name="l01025"></a>01025       incr = 0;
<a name="l01026"></a>01026     }
<a name="l01027"></a>01027     <span class="keywordflow">if</span> (incr &gt; 0) {
<a name="l01028"></a>01028       <span class="keywordtype">double</span> factor = (prctile / 100) * tmp_len - (klowest + .5);
<a name="l01029"></a>01029       <span class="comment">// mexPrintf(&quot;p=%f klowest=%d, low=%f, high=%f, incr=%f, factor=%f\n&quot;, prctile/100, klowest, *jresult, next, incr, factor);</span>
<a name="l01030"></a>01030       *jresult = *jresult + incr * factor;
<a name="l01031"></a>01031     }
<a name="l01032"></a>01032   }
<a name="l01033"></a>01033   <span class="keyword">delete</span>[] tmpdata;
<a name="l01034"></a>01034   <span class="keywordflow">return</span> dResult;
<a name="l01035"></a>01035 }
<a name="l01036"></a>01036 
<a name="l01037"></a>01037 <span class="keywordtype">void</span> CNAnalysisMethod::calculateSummaryLOH()
<a name="l01038"></a>01038 {
<a name="l01039"></a>01039     <span class="keywordtype">int</span> iChromosomeStartPosition = m_vSegments.getAt(0)-&gt;getStartPosition();
<a name="l01040"></a>01040     <span class="keywordtype">int</span> iChromosomeEndPosition = m_vSegments.getAt(0)-&gt;getEndPosition();
<a name="l01041"></a>01041     <span class="keywordtype">int</span> iSegmentStartPosition = iChromosomeStartPosition;
<a name="l01042"></a>01042     <span class="keywordtype">int</span> iSegmentEndPosition = iChromosomeEndPosition;
<a name="l01043"></a>01043 
<a name="l01044"></a>01044     <span class="keywordtype">float</span> fLengthOfLoh=0;
<a name="l01045"></a>01045     <span class="keywordtype">float</span> fChromosomeLength=0;
<a name="l01046"></a>01046     <span class="keywordtype">float</span> fGenomeLength=0;
<a name="l01047"></a>01047     <span class="keywordtype">float</span> fSumLOH=0;
<a name="l01048"></a>01048     <span class="keywordtype">float</span> fLOH=0;
<a name="l01049"></a>01049     <span class="keywordtype">int</span> iNumberOfChromosomes=0;
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     <span class="keywordtype">char</span> cStartChromosome = m_vSegments.getAt(0)-&gt;getChromosome();
<a name="l01052"></a>01052     <span class="keywordtype">char</span> cPresentChromosome = cStartChromosome;
<a name="l01053"></a>01053 
<a name="l01054"></a>01054     <span class="keywordflow">if</span>(m_vSegments.getAt(0)-&gt;getCall() == 1)
<a name="l01055"></a>01055     {
<a name="l01056"></a>01056         fLengthOfLoh = iSegmentEndPosition - iSegmentStartPosition;
<a name="l01057"></a>01057     }  <span class="keywordflow">else</span>
<a name="l01058"></a>01058     {
<a name="l01059"></a>01059         fLengthOfLoh = 0;
<a name="l01060"></a>01060     }
<a name="l01061"></a>01061     fChromosomeLength = iSegmentEndPosition - iSegmentStartPosition;
<a name="l01062"></a>01062 
<a name="l01063"></a>01063     <span class="keywordtype">bool</span> autosomeGenomeLOHSet = <span class="keyword">false</span>;
<a name="l01064"></a>01064 
<a name="l01065"></a>01065     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iIndex=1; iIndex &lt; m_vSegments.getCount(); iIndex++){
<a name="l01066"></a>01066         <a class="code" href="classCNSegment.html" title="A class for storing Segment data.">CNSegment</a>* pobjSegment = m_vSegments.getAt(iIndex);
<a name="l01067"></a>01067         cPresentChromosome = pobjSegment-&gt;getChromosome();
<a name="l01068"></a>01068 
<a name="l01069"></a>01069         <span class="keywordflow">if</span>(cPresentChromosome != cStartChromosome){
<a name="l01070"></a>01070             fLOH= fLengthOfLoh / fChromosomeLength;
<a name="l01071"></a>01071             pair&lt;char, float&gt;  data(cStartChromosome, fLOH);
<a name="l01072"></a>01072             getExperiment()-&gt;addChromosomeSummaryData(data);
<a name="l01073"></a>01073             fGenomeLength += fChromosomeLength;
<a name="l01074"></a>01074             fSumLOH += fLengthOfLoh;
<a name="l01075"></a>01075 
<a name="l01076"></a>01076             <span class="comment">// Save genomeLOH accumulated so far</span>
<a name="l01077"></a>01077             <span class="comment">// (i.e. accumulated over all autosomes)</span>
<a name="l01078"></a>01078             <span class="keywordflow">if</span> (cPresentChromosome == m_iXChromosome)
<a name="l01079"></a>01079             {
<a name="l01080"></a>01080                 getExperiment()-&gt;setAutosomeGenomeLOH( fSumLOH / fGenomeLength );
<a name="l01081"></a>01081                 autosomeGenomeLOHSet = <span class="keyword">true</span>;
<a name="l01082"></a>01082             }
<a name="l01083"></a>01083 
<a name="l01084"></a>01084             iNumberOfChromosomes++;
<a name="l01085"></a>01085 
<a name="l01086"></a>01086             iChromosomeStartPosition = pobjSegment-&gt;getStartPosition();
<a name="l01087"></a>01087             iChromosomeEndPosition = pobjSegment-&gt;getEndPosition();
<a name="l01088"></a>01088             iSegmentStartPosition = iChromosomeStartPosition;
<a name="l01089"></a>01089             iSegmentEndPosition = iChromosomeEndPosition;
<a name="l01090"></a>01090 
<a name="l01091"></a>01091             <span class="keywordflow">if</span>(pobjSegment-&gt;getCall() == 1)
<a name="l01092"></a>01092             {
<a name="l01093"></a>01093                 fLengthOfLoh = iSegmentEndPosition - iSegmentStartPosition;
<a name="l01094"></a>01094             }  <span class="keywordflow">else</span>
<a name="l01095"></a>01095             {
<a name="l01096"></a>01096                 fLengthOfLoh = 0;
<a name="l01097"></a>01097             }
<a name="l01098"></a>01098             fChromosomeLength = iSegmentEndPosition -iSegmentStartPosition;
<a name="l01099"></a>01099             cStartChromosome = cPresentChromosome;
<a name="l01100"></a>01100 
<a name="l01101"></a>01101         } <span class="keywordflow">else</span>
<a name="l01102"></a>01102         {
<a name="l01103"></a>01103             iSegmentStartPosition = pobjSegment-&gt;getStartPosition();
<a name="l01104"></a>01104             iSegmentEndPosition = pobjSegment-&gt;getEndPosition();
<a name="l01105"></a>01105             iChromosomeEndPosition = pobjSegment-&gt;getEndPosition();
<a name="l01106"></a>01106             <span class="keywordflow">if</span>(pobjSegment-&gt;getCall() == 1)
<a name="l01107"></a>01107             {
<a name="l01108"></a>01108                 fLengthOfLoh += (iSegmentEndPosition - iSegmentStartPosition);
<a name="l01109"></a>01109             }
<a name="l01110"></a>01110             fChromosomeLength = iChromosomeEndPosition - iChromosomeStartPosition;
<a name="l01111"></a>01111         }
<a name="l01112"></a>01112     }
<a name="l01113"></a>01113     fLOH= fLengthOfLoh / fChromosomeLength;
<a name="l01114"></a>01114     pair&lt;char, float&gt;  data(cPresentChromosome, fLOH);
<a name="l01115"></a>01115     getExperiment()-&gt;addChromosomeSummaryData(data);
<a name="l01116"></a>01116     fGenomeLength += fChromosomeLength;
<a name="l01117"></a>01117     fSumLOH += fLengthOfLoh;
<a name="l01118"></a>01118     getExperiment()-&gt;setGenomeLOH(  fSumLOH / fGenomeLength );
<a name="l01119"></a>01119     <span class="keywordflow">if</span> (!autosomeGenomeLOHSet)
<a name="l01120"></a>01120     {
<a name="l01121"></a>01121         getExperiment()-&gt;setAutosomeGenomeLOH(getExperiment()-&gt;getGenomeLOH());
<a name="l01122"></a>01122     }
<a name="l01123"></a>01123     iNumberOfChromosomes++;
<a name="l01124"></a>01124     getExperiment()-&gt;setNumberOfChromosomesToReport(iNumberOfChromosomes);
<a name="l01125"></a>01125 }
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="keywordtype">void</span> CNAnalysisMethod::writeIntensities(std::string intensityFileInfix)
<a name="l01128"></a>01128 {
<a name="l01129"></a>01129 
<a name="l01130"></a>01130   <a class="code" href="classaffx_1_1File5__File.html">affx::File5_File</a> file5;
<a name="l01131"></a>01131   <a class="code" href="classaffx_1_1File5__Group.html">affx::File5_Group</a>* group5;
<a name="l01132"></a>01132   <a class="code" href="classaffx_1_1File5__Tsv.html">affx::File5_Tsv</a>* tsv5 = NULL;
<a name="l01133"></a>01133 
<a name="l01134"></a>01134   std::string analysisString = <span class="stringliteral">&quot;analysis&quot;</span>;
<a name="l01135"></a>01135   std::string strExperimentName = getExperiment()-&gt;getExperimentName();
<a name="l01136"></a>01136   std::string fileName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>),
<a name="l01137"></a>01137                                   analysisString,
<a name="l01138"></a>01138                                   strExperimentName + <span class="stringliteral">&quot;.&quot;</span> +intensityFileInfix + <span class="stringliteral">&quot;.intensities.a5&quot;</span>);
<a name="l01139"></a>01139 
<a name="l01140"></a>01140   <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(3, <span class="stringliteral">&quot;Writing intensities for &quot;</span> + fileName);
<a name="l01141"></a>01141 
<a name="l01142"></a>01142   <span class="keywordflow">try</span>{
<a name="l01143"></a>01143 
<a name="l01144"></a>01144     file5.open(fileName, affx::FILE5_CREATE | affx::FILE5_REPLACE);
<a name="l01145"></a>01145     group5 = file5.openGroup(<span class="stringliteral">&quot;Intensities&quot;</span>, affx::FILE5_REPLACE);
<a name="l01146"></a>01146     tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;Intensities&quot;</span>, affx::FILE5_REPLACE);
<a name="l01147"></a>01147     tsv5-&gt;defineColumn(0,0,<span class="stringliteral">&quot;ProbeSetID&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l01148"></a>01148     tsv5-&gt;defineColumn(0,1,<span class="stringliteral">&quot;Log2Intensity&quot;</span>, affx::FILE5_DTYPE_FLOAT);
<a name="l01149"></a>01149 
<a name="l01150"></a>01150     <a class="code" href="classCNProbe.html" title="A class for storing probe intensity data.">CNProbe</a>* pProbe;
<a name="l01151"></a>01151     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iProbeIndex=0;  iProbeIndex &lt; m_pvProbes-&gt;getCount(); iProbeIndex++)
<a name="l01152"></a>01152     {
<a name="l01153"></a>01153       pProbe = m_pvProbes-&gt;getAt(iProbeIndex);
<a name="l01154"></a>01154       tsv5-&gt;set_i(0,0, pProbe-&gt;getProbeID());
<a name="l01155"></a>01155       tsv5-&gt;set_f(0,1, (<span class="keywordtype">float</span>) (log((<span class="keywordtype">double</span>) pProbe-&gt;getIntensity()) / log(2.0)) );
<a name="l01156"></a>01156       tsv5-&gt;writeLevel(0);
<a name="l01157"></a>01157     }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159     tsv5-&gt;close();
<a name="l01160"></a>01160     <span class="keyword">delete</span> tsv5;
<a name="l01161"></a>01161     <span class="keyword">delete</span> group5;
<a name="l01162"></a>01162     file5.close();
<a name="l01163"></a>01163   }
<a name="l01164"></a>01164   <span class="keywordflow">catch</span>(...){ <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;Cannot open file &quot;</span> + fileName + <span class="stringliteral">&quot; while attempting to dump intensities to file.&quot;</span>));}
<a name="l01165"></a>01165 }
<a name="l01166"></a>01166 
<a name="l01167"></a>01167 <span class="keywordtype">void</span> CNAnalysisMethod::writeSignals(std::string signalFileInfix)
<a name="l01168"></a>01168 {
<a name="l01169"></a>01169 
<a name="l01170"></a>01170   <a class="code" href="classaffx_1_1File5__File.html">affx::File5_File</a> file5;
<a name="l01171"></a>01171   <a class="code" href="classaffx_1_1File5__Group.html">affx::File5_Group</a>* group5;
<a name="l01172"></a>01172   <a class="code" href="classaffx_1_1File5__Tsv.html">affx::File5_Tsv</a>* tsv5 = NULL;
<a name="l01173"></a>01173 
<a name="l01174"></a>01174   std::string analysisString = <span class="stringliteral">&quot;analysis&quot;</span>;
<a name="l01175"></a>01175   std::string strExperimentName = getExperiment()-&gt;getExperimentName();
<a name="l01176"></a>01176   std::string fileName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>),analysisString,
<a name="l01177"></a>01177                                   strExperimentName + <span class="stringliteral">&quot;.&quot;</span> +signalFileInfix + <span class="stringliteral">&quot;.signals.a5&quot;</span>);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179   <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(3, <span class="stringliteral">&quot;Writing signals for &quot;</span> + fileName);
<a name="l01180"></a>01180 
<a name="l01181"></a>01181   <span class="keywordflow">try</span>{
<a name="l01182"></a>01182 
<a name="l01183"></a>01183     file5.open(fileName, affx::FILE5_CREATE | affx::FILE5_REPLACE);
<a name="l01184"></a>01184     group5 = file5.openGroup(<span class="stringliteral">&quot;Signals&quot;</span>, affx::FILE5_REPLACE);
<a name="l01185"></a>01185     tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;Signals&quot;</span>, affx::FILE5_REPLACE);
<a name="l01186"></a>01186     tsv5-&gt;defineColumn(0,0,<span class="stringliteral">&quot;ProbeSetName&quot;</span>, affx::FILE5_DTYPE_STRING, 40);
<a name="l01187"></a>01187     tsv5-&gt;defineColumn(0,1,<span class="stringliteral">&quot;Chromosome&quot;</span>, affx::FILE5_DTYPE_CHAR);
<a name="l01188"></a>01188     tsv5-&gt;defineColumn(0,2,<span class="stringliteral">&quot;Position&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l01189"></a>01189     tsv5-&gt;defineColumn(0,3,<span class="stringliteral">&quot;Log2AMedianIntensity&quot;</span>, affx::FILE5_DTYPE_FLOAT);
<a name="l01190"></a>01190     tsv5-&gt;defineColumn(0,4,<span class="stringliteral">&quot;Log2BMedianIntensity&quot;</span>, affx::FILE5_DTYPE_FLOAT);
<a name="l01191"></a>01191     tsv5-&gt;defineColumn(0,5,<span class="stringliteral">&quot;Log2AAlleleSignal&quot;</span>, affx::FILE5_DTYPE_FLOAT);
<a name="l01192"></a>01192     tsv5-&gt;defineColumn(0,6,<span class="stringliteral">&quot;Log2BAlleleSignal&quot;</span>, affx::FILE5_DTYPE_FLOAT);
<a name="l01193"></a>01193 
<a name="l01194"></a>01194     <a class="code" href="classCNProbeSet.html" title="A class to store probe set data.">CNProbeSet</a>* pProbeSet;
<a name="l01195"></a>01195     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iProbeSetIndex=0;  iProbeSetIndex &lt; m_pvProbeSets-&gt;getCount(); iProbeSetIndex++)
<a name="l01196"></a>01196     {
<a name="l01197"></a>01197         pProbeSet = m_pvProbeSets-&gt;getAt(iProbeSetIndex);
<a name="l01198"></a>01198         {
<a name="l01199"></a>01199             tsv5-&gt;set_string(0,0, pProbeSet-&gt;getProbeSetName());
<a name="l01200"></a>01200             tsv5-&gt;set_c(0,1, pProbeSet-&gt;getChromosome());
<a name="l01201"></a>01201             tsv5-&gt;set_i(0,2, pProbeSet-&gt;getPosition());
<a name="l01202"></a>01202             tsv5-&gt;set_f(0,3, (<span class="keywordtype">float</span>) (log((<span class="keywordtype">double</span>) pProbeSet-&gt;getAMedianIntensity()) / log(2.0)) );
<a name="l01203"></a>01203             tsv5-&gt;set_f(0,4, (<span class="keywordtype">float</span>) (log((<span class="keywordtype">double</span>) pProbeSet-&gt;getBMedianIntensity()) / log(2.0)) );
<a name="l01204"></a>01204             tsv5-&gt;set_f(0,5, (<span class="keywordtype">float</span>) (log((<span class="keywordtype">double</span>) pProbeSet-&gt;getAAlleleSignal()) / log(2.0)) );
<a name="l01205"></a>01205             tsv5-&gt;set_f(0,6, (<span class="keywordtype">float</span>) (log((<span class="keywordtype">double</span>) pProbeSet-&gt;getBAlleleSignal()) / log(2.0)) );
<a name="l01206"></a>01206             tsv5-&gt;writeLevel(0);
<a name="l01207"></a>01207         }
<a name="l01208"></a>01208     }
<a name="l01209"></a>01209 
<a name="l01210"></a>01210     tsv5-&gt;close();
<a name="l01211"></a>01211     <span class="keyword">delete</span> tsv5;
<a name="l01212"></a>01212     <span class="keyword">delete</span> group5;
<a name="l01213"></a>01213     file5.close();
<a name="l01214"></a>01214   }
<a name="l01215"></a>01215   <span class="keywordflow">catch</span>(...){ <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;Cannot open file &quot;</span> + fileName + <span class="stringliteral">&quot; while attempting to dump intensities to file.&quot;</span>));}
<a name="l01216"></a>01216 }
<a name="l01217"></a>01217 
<a name="l01218"></a>01218 <span class="keywordtype">void</span> CNAnalysisMethod::writeMediansVectorAndMedian(std::string infix, <span class="keyword">const</span> std::vector&lt;float&gt;&amp; medians, <span class="keywordtype">float</span> grandMedian)
<a name="l01219"></a>01219 {
<a name="l01220"></a>01220   <a class="code" href="classaffx_1_1File5__File.html">affx::File5_File</a> file5;
<a name="l01221"></a>01221   <a class="code" href="classaffx_1_1File5__Group.html">affx::File5_Group</a>* group5;
<a name="l01222"></a>01222   <a class="code" href="classaffx_1_1File5__Tsv.html">affx::File5_Tsv</a>* tsv5 = NULL;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224   std::string analysisString = <span class="stringliteral">&quot;analysis&quot;</span>;
<a name="l01225"></a>01225   std::string strExperimentName = getExperiment()-&gt;getExperimentName();
<a name="l01226"></a>01226   std::string fileName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>),
<a name="l01227"></a>01227                                   analysisString,
<a name="l01228"></a>01228                                   strExperimentName + <span class="stringliteral">&quot;.&quot;</span> + infix + <span class="stringliteral">&quot;.medians.a5&quot;</span>);
<a name="l01229"></a>01229 
<a name="l01230"></a>01230   <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(3, <span class="stringliteral">&quot;Writing medians for &quot;</span> + fileName);
<a name="l01231"></a>01231 
<a name="l01232"></a>01232   <span class="keywordflow">try</span>{
<a name="l01233"></a>01233 
<a name="l01234"></a>01234     file5.open(fileName, affx::FILE5_CREATE | affx::FILE5_REPLACE);
<a name="l01235"></a>01235     group5 = file5.openGroup(<span class="stringliteral">&quot;Medians&quot;</span>, affx::FILE5_REPLACE);
<a name="l01236"></a>01236     tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;BinMedians&quot;</span>, affx::FILE5_REPLACE);
<a name="l01237"></a>01237     tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;BinMedians&quot;</span>, affx::FILE5_DTYPE_FLOAT);
<a name="l01238"></a>01238 
<a name="l01239"></a>01239     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; medians.size(); ii++)
<a name="l01240"></a>01240     {
<a name="l01241"></a>01241         tsv5-&gt;set_f(0, 0, medians[ii]);
<a name="l01242"></a>01242         tsv5-&gt;writeLevel(0);
<a name="l01243"></a>01243     }
<a name="l01244"></a>01244     tsv5-&gt;close();
<a name="l01245"></a>01245     <span class="keyword">delete</span> tsv5;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247     tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;GrandMedian&quot;</span>, affx::FILE5_REPLACE);
<a name="l01248"></a>01248     tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;GrandMedian&quot;</span>, affx::FILE5_DTYPE_FLOAT);
<a name="l01249"></a>01249     tsv5-&gt;set_f(0, 0, grandMedian);
<a name="l01250"></a>01250     tsv5-&gt;writeLevel(0);
<a name="l01251"></a>01251 
<a name="l01252"></a>01252     tsv5-&gt;close();
<a name="l01253"></a>01253     <span class="keyword">delete</span> tsv5;
<a name="l01254"></a>01254     <span class="keyword">delete</span> group5;
<a name="l01255"></a>01255     file5.close();
<a name="l01256"></a>01256   }
<a name="l01257"></a>01257   <span class="keywordflow">catch</span>(...){ <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;Cannot open file &quot;</span> + fileName + <span class="stringliteral">&quot; while attempting to dump medians to file.&quot;</span>));}
<a name="l01258"></a>01258 }
<a name="l01259"></a>01259 
<a name="l01260"></a>01260 <span class="keywordtype">void</span> CNAnalysisMethod::writeMediansVector(std::string infix, <span class="keyword">const</span> std::vector&lt;float&gt;&amp; medians)
<a name="l01261"></a>01261 {
<a name="l01262"></a>01262   <a class="code" href="classaffx_1_1File5__File.html">affx::File5_File</a> file5;
<a name="l01263"></a>01263   <a class="code" href="classaffx_1_1File5__Group.html">affx::File5_Group</a>* group5;
<a name="l01264"></a>01264   <a class="code" href="classaffx_1_1File5__Tsv.html">affx::File5_Tsv</a>* tsv5 = NULL;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266   <span class="comment">// Self preservation</span>
<a name="l01267"></a>01267   <span class="comment">// TODO: Fix this.</span>
<a name="l01268"></a>01268   <span class="keywordflow">if</span> (getExperiment() == NULL) <span class="keywordflow">return</span>;
<a name="l01269"></a>01269 
<a name="l01270"></a>01270   std::string analysisString = <span class="stringliteral">&quot;analysis&quot;</span>;
<a name="l01271"></a>01271   std::string strExperimentName = getExperiment()-&gt;getExperimentName();
<a name="l01272"></a>01272   std::string fileName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>),
<a name="l01273"></a>01273                                   analysisString,
<a name="l01274"></a>01274                                   strExperimentName + <span class="stringliteral">&quot;.&quot;</span> + infix + <span class="stringliteral">&quot;.medians.a5&quot;</span>);
<a name="l01275"></a>01275 
<a name="l01276"></a>01276   <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(3, <span class="stringliteral">&quot;Writing medians for &quot;</span> + fileName);
<a name="l01277"></a>01277 
<a name="l01278"></a>01278   <span class="keywordflow">try</span>{
<a name="l01279"></a>01279 
<a name="l01280"></a>01280     file5.open(fileName, affx::FILE5_CREATE | affx::FILE5_REPLACE);
<a name="l01281"></a>01281     group5 = file5.openGroup(<span class="stringliteral">&quot;Medians&quot;</span>, affx::FILE5_REPLACE);
<a name="l01282"></a>01282     tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;BinMedians&quot;</span>, affx::FILE5_REPLACE);
<a name="l01283"></a>01283     tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;BinMedians&quot;</span>, affx::FILE5_DTYPE_FLOAT);
<a name="l01284"></a>01284 
<a name="l01285"></a>01285     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; medians.size(); ii++)
<a name="l01286"></a>01286     {
<a name="l01287"></a>01287         tsv5-&gt;set_f(0, 0, medians[ii]);
<a name="l01288"></a>01288         tsv5-&gt;writeLevel(0);
<a name="l01289"></a>01289     }
<a name="l01290"></a>01290     tsv5-&gt;close();
<a name="l01291"></a>01291     <span class="keyword">delete</span> tsv5;
<a name="l01292"></a>01292     <span class="keyword">delete</span> group5;
<a name="l01293"></a>01293     file5.close();
<a name="l01294"></a>01294   }
<a name="l01295"></a>01295   <span class="keywordflow">catch</span>(...){ <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;Cannot open file &quot;</span> + fileName + <span class="stringliteral">&quot; while attempting to dump medians to file.&quot;</span>));}
<a name="l01296"></a>01296 }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298 <span class="keywordtype">void</span> CNAnalysisMethod::writeSignalsTsv(std::string signalFileInfix, <a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>* pvLocalProbeSets)
<a name="l01299"></a>01299 {
<a name="l01300"></a>01300     std::string analysisString = <span class="stringliteral">&quot;analysis&quot;</span>;
<a name="l01301"></a>01301     std::string strExperimentName = getExperiment()-&gt;getExperimentName();
<a name="l01302"></a>01302     std::string fileName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>) , analysisString , strExperimentName)  + <span class="stringliteral">&quot;.&quot;</span> + signalFileInfix + <span class="stringliteral">&quot;.signal.txt&quot;</span>;
<a name="l01303"></a>01303 
<a name="l01304"></a>01304     <a class="code" href="classaffx_1_1TsvFile.html" title="A class for reading and writing Tab Seperated Value (TSV) files. /// See the TsvFile format document ...">affx::TsvFile</a> *tsv = <span class="keyword">new</span> <a class="code" href="classaffx_1_1TsvFile.html" title="A class for reading and writing Tab Seperated Value (TSV) files. /// See the TsvFile format document ...">affx::TsvFile</a>;
<a name="l01305"></a>01305     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#a607cbaf58e6e0772ef7d2aaee277c552" title="open the file for writing in &amp;quot;v2&amp;quot; format. ///">writeTsv</a>(fileName);
<a name="l01306"></a>01306 
<a name="l01307"></a>01307     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#aadc22863a63b9c6588b0f2dc61875809" title="User methods.">defineColumn</a>(0,0,<span class="stringliteral">&quot;ProbeSetName&quot;</span>, affx::TSV_TYPE_STRING);
<a name="l01308"></a>01308     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#aadc22863a63b9c6588b0f2dc61875809" title="User methods.">defineColumn</a>(0,1,<span class="stringliteral">&quot;Chromosome&quot;</span>, affx::TSV_TYPE_INT);
<a name="l01309"></a>01309     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#aadc22863a63b9c6588b0f2dc61875809" title="User methods.">defineColumn</a>(0,2,<span class="stringliteral">&quot;Position&quot;</span>, affx::TSV_TYPE_INT);
<a name="l01310"></a>01310     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#aadc22863a63b9c6588b0f2dc61875809" title="User methods.">defineColumn</a>(0,3,<span class="stringliteral">&quot;Log2AMedianIntensity&quot;</span>, affx::TSV_TYPE_FLOAT);
<a name="l01311"></a>01311     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#aadc22863a63b9c6588b0f2dc61875809" title="User methods.">defineColumn</a>(0,4,<span class="stringliteral">&quot;Log2BMedianIntensity&quot;</span>, affx::TSV_TYPE_FLOAT);
<a name="l01312"></a>01312     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#aadc22863a63b9c6588b0f2dc61875809" title="User methods.">defineColumn</a>(0,5,<span class="stringliteral">&quot;Log2AAlleleSignal&quot;</span>, affx::TSV_TYPE_FLOAT);
<a name="l01313"></a>01313     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#aadc22863a63b9c6588b0f2dc61875809" title="User methods.">defineColumn</a>(0,6,<span class="stringliteral">&quot;Log2BAlleleSignal&quot;</span>, affx::TSV_TYPE_FLOAT);
<a name="l01314"></a>01314 
<a name="l01315"></a>01315     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; (iIndex &lt; pvLocalProbeSets-&gt;getCount()); iIndex++)
<a name="l01316"></a>01316     {
<a name="l01317"></a>01317         <a class="code" href="classCNProbeSet.html" title="A class to store probe set data.">CNProbeSet</a>* pProbeSet = getProbeSets()-&gt;getAt(iIndex);
<a name="l01318"></a>01318         tsv-&gt;set(0,0,pProbeSet-&gt;getProbeSetName());
<a name="l01319"></a>01319         tsv-&gt;set(0,1,pProbeSet-&gt;getChromosome());
<a name="l01320"></a>01320         tsv-&gt;set(0,2,pProbeSet-&gt;getPosition());
<a name="l01321"></a>01321         tsv-&gt;set(0,3,(<span class="keywordtype">float</span>) (log((<span class="keywordtype">double</span>) pProbeSet-&gt;getAMedianIntensity()) / log(2.0)));
<a name="l01322"></a>01322         tsv-&gt;set(0,4,(<span class="keywordtype">float</span>) (log((<span class="keywordtype">double</span>) pProbeSet-&gt;getBMedianIntensity()) / log(2.0)));
<a name="l01323"></a>01323         tsv-&gt;set(0,5,(<span class="keywordtype">float</span>) (log((<span class="keywordtype">double</span>) pProbeSet-&gt;getAAlleleSignal()) / log(2.0)));
<a name="l01324"></a>01324         tsv-&gt;set(0,6,(<span class="keywordtype">float</span>) (log((<span class="keywordtype">double</span>) pProbeSet-&gt;getBAlleleSignal()) / log(2.0)));
<a name="l01325"></a>01325         tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#a2a459be42bea9ea3f180773370ec0de7" title="Write a level of data to the file. ///.">writeLevel</a>(0);
<a name="l01326"></a>01326     }
<a name="l01327"></a>01327     <span class="keyword">delete</span> tsv;
<a name="l01328"></a>01328 }
<a name="l01329"></a>01329 
<a name="l01330"></a>01330 
<a name="l01331"></a>01331 <span class="keywordtype">void</span> CNAnalysisMethod::writeLog2RatiosTsv(std::string l2rFileInfix, <a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>* pvLocalProbeSets)
<a name="l01332"></a>01332 {
<a name="l01333"></a>01333     std::string analysisString = <span class="stringliteral">&quot;analysis&quot;</span>;
<a name="l01334"></a>01334     std::string strExperimentName = getExperiment()-&gt;getExperimentName();
<a name="l01335"></a>01335     std::string fileName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>), analysisString , strExperimentName) + <span class="stringliteral">&quot;.&quot;</span> + l2rFileInfix + <span class="stringliteral">&quot;.l2r.txt&quot;</span>;
<a name="l01336"></a>01336 
<a name="l01337"></a>01337     <a class="code" href="classaffx_1_1TsvFile.html" title="A class for reading and writing Tab Seperated Value (TSV) files. /// See the TsvFile format document ...">affx::TsvFile</a> *tsv = <span class="keyword">new</span> <a class="code" href="classaffx_1_1TsvFile.html" title="A class for reading and writing Tab Seperated Value (TSV) files. /// See the TsvFile format document ...">affx::TsvFile</a>;
<a name="l01338"></a>01338     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#a607cbaf58e6e0772ef7d2aaee277c552" title="open the file for writing in &amp;quot;v2&amp;quot; format. ///">writeTsv</a>(fileName);
<a name="l01339"></a>01339 
<a name="l01340"></a>01340     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#aadc22863a63b9c6588b0f2dc61875809" title="User methods.">defineColumn</a>(0,0,<span class="stringliteral">&quot;ProbeSetName&quot;</span>, affx::TSV_TYPE_STRING);
<a name="l01341"></a>01341     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#aadc22863a63b9c6588b0f2dc61875809" title="User methods.">defineColumn</a>(0,1,<span class="stringliteral">&quot;Chromosome&quot;</span>, affx::TSV_TYPE_INT);
<a name="l01342"></a>01342     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#aadc22863a63b9c6588b0f2dc61875809" title="User methods.">defineColumn</a>(0,2,<span class="stringliteral">&quot;Position&quot;</span>, affx::TSV_TYPE_INT);
<a name="l01343"></a>01343     tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#aadc22863a63b9c6588b0f2dc61875809" title="User methods.">defineColumn</a>(0,3,<span class="stringliteral">&quot;Log2Ratio&quot;</span>, affx::TSV_TYPE_INT);
<a name="l01344"></a>01344 
<a name="l01345"></a>01345     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; (iIndex &lt; pvLocalProbeSets-&gt;getCount()); iIndex++)
<a name="l01346"></a>01346     {
<a name="l01347"></a>01347         <a class="code" href="classCNProbeSet.html" title="A class to store probe set data.">CNProbeSet</a>* p = pvLocalProbeSets-&gt;getAt(iIndex);
<a name="l01348"></a>01348         tsv-&gt;set(0,0,p-&gt;getProbeSetName());
<a name="l01349"></a>01349         tsv-&gt;set(0,1,p-&gt;getChromosome());
<a name="l01350"></a>01350         tsv-&gt;set(0,2,p-&gt;getPosition());
<a name="l01351"></a>01351         tsv-&gt;set(0,3,p-&gt;getLog2Ratio());
<a name="l01352"></a>01352         tsv-&gt;<a class="code" href="classaffx_1_1TsvFile.html#a2a459be42bea9ea3f180773370ec0de7" title="Write a level of data to the file. ///.">writeLevel</a>(0);
<a name="l01353"></a>01353     }
<a name="l01354"></a>01354     <span class="keyword">delete</span> tsv;
<a name="l01355"></a>01355 }
<a name="l01356"></a>01356 
<a name="l01357"></a>01357 
<a name="l01358"></a>01358 <span class="keywordtype">void</span> CNAnalysisMethod::writeLog2Ratios(std::string l2rFileInfix)
<a name="l01359"></a>01359 {
<a name="l01360"></a>01360   <a class="code" href="classaffx_1_1File5__File.html">affx::File5_File</a> file5;
<a name="l01361"></a>01361   <a class="code" href="classaffx_1_1File5__Group.html">affx::File5_Group</a>* group5;
<a name="l01362"></a>01362   <a class="code" href="classaffx_1_1File5__Tsv.html">affx::File5_Tsv</a>* tsv5 = NULL;
<a name="l01363"></a>01363 
<a name="l01364"></a>01364   <span class="comment">// Self preservation</span>
<a name="l01365"></a>01365   <span class="comment">// TODO: Fix this.</span>
<a name="l01366"></a>01366   <span class="keywordflow">if</span> (getExperiment() == NULL) <span class="keywordflow">return</span>;
<a name="l01367"></a>01367 
<a name="l01368"></a>01368   std::string analysisString = <span class="stringliteral">&quot;analysis&quot;</span>;
<a name="l01369"></a>01369   std::string strExperimentName = getExperiment()-&gt;getExperimentName();
<a name="l01370"></a>01370   std::string fileName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>),
<a name="l01371"></a>01371                                   analysisString,
<a name="l01372"></a>01372                                   strExperimentName + <span class="stringliteral">&quot;.&quot;</span> + l2rFileInfix + <span class="stringliteral">&quot;.l2r.a5&quot;</span>);
<a name="l01373"></a>01373   
<a name="l01374"></a>01374   std::string dirName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>), analysisString);  
<a name="l01375"></a>01375 
<a name="l01376"></a>01376 
<a name="l01377"></a>01377   <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(3, <span class="stringliteral">&quot;Writing Log2Ratios for &quot;</span> + fileName);
<a name="l01378"></a>01378 
<a name="l01379"></a>01379   <span class="keywordflow">try</span>{
<a name="l01380"></a>01380     <span class="keywordflow">if</span>(!Fs::dirExists(dirName))
<a name="l01381"></a>01381     {
<a name="l01382"></a>01382         <a class="code" href="classFs.html#abf363360d88071c2f4a93a7e50d61c9f" title="Make one directory. ///.">Fs::mkdir</a>(dirName);
<a name="l01383"></a>01383     }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385     file5.open(fileName, affx::FILE5_CREATE | affx::FILE5_REPLACE);
<a name="l01386"></a>01386     group5 = file5.openGroup(<span class="stringliteral">&quot;Signals&quot;</span>, affx::FILE5_REPLACE);
<a name="l01387"></a>01387     tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;Signals&quot;</span>, affx::FILE5_REPLACE);
<a name="l01388"></a>01388     tsv5-&gt;defineColumn(0,0,<span class="stringliteral">&quot;ProbeSetName&quot;</span>, affx::FILE5_DTYPE_STRING,40);
<a name="l01389"></a>01389     tsv5-&gt;defineColumn(0,1,<span class="stringliteral">&quot;Chromosome&quot;</span>, affx::FILE5_DTYPE_CHAR);
<a name="l01390"></a>01390     tsv5-&gt;defineColumn(0,2,<span class="stringliteral">&quot;Position&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l01391"></a>01391     tsv5-&gt;defineColumn(0,3,<span class="stringliteral">&quot;Log2Ratio&quot;</span>, affx::FILE5_DTYPE_FLOAT);
<a name="l01392"></a>01392 
<a name="l01393"></a>01393     <a class="code" href="classCNProbeSet.html" title="A class to store probe set data.">CNProbeSet</a>* pProbeSet;
<a name="l01394"></a>01394     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iProbeSetIndex=0;  iProbeSetIndex &lt; m_pvProbeSets-&gt;getCount(); iProbeSetIndex++)
<a name="l01395"></a>01395     {
<a name="l01396"></a>01396       pProbeSet = m_pvProbeSets-&gt;getAt(iProbeSetIndex);
<a name="l01397"></a>01397       tsv5-&gt;set_string(0,0, pProbeSet-&gt;getProbeSetName());
<a name="l01398"></a>01398       tsv5-&gt;set_c(0,1, pProbeSet-&gt;getChromosome());
<a name="l01399"></a>01399       tsv5-&gt;set_i(0,2, pProbeSet-&gt;getPosition());
<a name="l01400"></a>01400       tsv5-&gt;set_f(0,3, pProbeSet-&gt;getLog2Ratio());
<a name="l01401"></a>01401       tsv5-&gt;writeLevel(0);
<a name="l01402"></a>01402     }
<a name="l01403"></a>01403 
<a name="l01404"></a>01404     tsv5-&gt;close();
<a name="l01405"></a>01405     <span class="keyword">delete</span> tsv5;
<a name="l01406"></a>01406     <span class="keyword">delete</span> group5;
<a name="l01407"></a>01407     file5.close();
<a name="l01408"></a>01408   }
<a name="l01409"></a>01409   <span class="keywordflow">catch</span>(...){ <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;Cannot open file &quot;</span> + fileName + <span class="stringliteral">&quot; while attempting to dump log2 ratios to file.&quot;</span>));}
<a name="l01410"></a>01410 }
<a name="l01411"></a>01411 
<a name="l01412"></a>01412 
<a name="l01413"></a>01413 <span class="keywordtype">void</span> CNAnalysisMethod::writeSmoothedLog2Ratios(std::string l2rFileInfix, <a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>* vProbeSets)
<a name="l01414"></a>01414 {
<a name="l01415"></a>01415   <a class="code" href="classaffx_1_1File5__File.html">affx::File5_File</a> file5;
<a name="l01416"></a>01416   <a class="code" href="classaffx_1_1File5__Group.html">affx::File5_Group</a>* group5;
<a name="l01417"></a>01417   <a class="code" href="classaffx_1_1File5__Tsv.html">affx::File5_Tsv</a>* tsv5 = NULL;
<a name="l01418"></a>01418 
<a name="l01419"></a>01419   <span class="comment">// Self preservation</span>
<a name="l01420"></a>01420   <span class="comment">// TODO: Fix this.</span>
<a name="l01421"></a>01421   <span class="keywordflow">if</span> (getExperiment() == NULL) <span class="keywordflow">return</span>;
<a name="l01422"></a>01422 
<a name="l01423"></a>01423   std::string analysisString = <span class="stringliteral">&quot;analysis&quot;</span>;
<a name="l01424"></a>01424   std::string strExperimentName = getExperiment()-&gt;getExperimentName();
<a name="l01425"></a>01425   std::string fileName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>),
<a name="l01426"></a>01426                                   analysisString,
<a name="l01427"></a>01427                                   strExperimentName + <span class="stringliteral">&quot;.&quot;</span> + l2rFileInfix + <span class="stringliteral">&quot;.l2r.a5&quot;</span>);
<a name="l01428"></a>01428   
<a name="l01429"></a>01429   std::string dirName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>), analysisString);  
<a name="l01430"></a>01430 
<a name="l01431"></a>01431 
<a name="l01432"></a>01432   <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(3, <span class="stringliteral">&quot;Writing smoothed Log2Ratios for &quot;</span> + fileName);
<a name="l01433"></a>01433 
<a name="l01434"></a>01434   <span class="keywordflow">try</span>{
<a name="l01435"></a>01435     <span class="keywordflow">if</span>(!Fs::dirExists(dirName))
<a name="l01436"></a>01436     {
<a name="l01437"></a>01437         <a class="code" href="classFs.html#abf363360d88071c2f4a93a7e50d61c9f" title="Make one directory. ///.">Fs::mkdir</a>(dirName);
<a name="l01438"></a>01438     }
<a name="l01439"></a>01439 
<a name="l01440"></a>01440     file5.open(fileName, affx::FILE5_CREATE | affx::FILE5_REPLACE);
<a name="l01441"></a>01441     group5 = file5.openGroup(<span class="stringliteral">&quot;Signals&quot;</span>, affx::FILE5_REPLACE);
<a name="l01442"></a>01442     tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;Signals&quot;</span>, affx::FILE5_REPLACE);
<a name="l01443"></a>01443     tsv5-&gt;defineColumn(0,0,<span class="stringliteral">&quot;ProbeSetName&quot;</span>, affx::FILE5_DTYPE_STRING,40);
<a name="l01444"></a>01444     tsv5-&gt;defineColumn(0,1,<span class="stringliteral">&quot;Chromosome&quot;</span>, affx::FILE5_DTYPE_CHAR);
<a name="l01445"></a>01445     tsv5-&gt;defineColumn(0,2,<span class="stringliteral">&quot;Position&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l01446"></a>01446     tsv5-&gt;defineColumn(0,3,<span class="stringliteral">&quot;SmoothedLog2Ratio&quot;</span>, affx::FILE5_DTYPE_FLOAT);
<a name="l01447"></a>01447 
<a name="l01448"></a>01448     <a class="code" href="classCNProbeSet.html" title="A class to store probe set data.">CNProbeSet</a>* pProbeSet;
<a name="l01449"></a>01449     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iProbeSetIndex=0;  iProbeSetIndex &lt; vProbeSets-&gt;getCount(); iProbeSetIndex++)
<a name="l01450"></a>01450     {
<a name="l01451"></a>01451       pProbeSet = vProbeSets-&gt;getAt(iProbeSetIndex);
<a name="l01452"></a>01452       tsv5-&gt;set_string(0,0, pProbeSet-&gt;getProbeSetName());
<a name="l01453"></a>01453       tsv5-&gt;set_c(0,1, pProbeSet-&gt;getChromosome());
<a name="l01454"></a>01454       tsv5-&gt;set_i(0,2, pProbeSet-&gt;getPosition());
<a name="l01455"></a>01455       tsv5-&gt;set_f(0,3, pProbeSet-&gt;getSmoothedLog2Ratio());
<a name="l01456"></a>01456       tsv5-&gt;writeLevel(0);
<a name="l01457"></a>01457     }
<a name="l01458"></a>01458 
<a name="l01459"></a>01459     tsv5-&gt;close();
<a name="l01460"></a>01460     <span class="keyword">delete</span> tsv5;
<a name="l01461"></a>01461     <span class="keyword">delete</span> group5;
<a name="l01462"></a>01462     file5.close();
<a name="l01463"></a>01463   }
<a name="l01464"></a>01464   <span class="keywordflow">catch</span>(...){ <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;Cannot open file &quot;</span> + fileName + <span class="stringliteral">&quot; while attempting to dump smoothed log2 ratios to file.&quot;</span>));}
<a name="l01465"></a>01465 }
<a name="l01466"></a>01466 
<a name="l01467"></a>01467 
<a name="l01468"></a>01468 <span class="keywordtype">void</span> CNAnalysisMethod::computeSCAR(std::vector&lt;float&gt;&amp; vSCAR)
<a name="l01469"></a>01469 {
<a name="l01470"></a>01470     <span class="keywordtype">float</span> fSCAR;
<a name="l01471"></a>01471 
<a name="l01472"></a>01472     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; (iIndex &lt; (int)getProbeSets()-&gt;size()); iIndex++)
<a name="l01473"></a>01473     {
<a name="l01474"></a>01474         <a class="code" href="classCNProbeSet.html" title="A class to store probe set data.">CNProbeSet</a>* pobjProbeSet = getProbeSets()-&gt;at(iIndex);
<a name="l01475"></a>01475         pobjProbeSet-&gt;setLoh(numeric_limits&lt;float&gt;::quiet_NaN());
<a name="l01476"></a>01476         fSCAR = numeric_limits&lt;float&gt;::quiet_NaN();
<a name="l01477"></a>01477 
<a name="l01478"></a>01478         <span class="comment">// We attempt to calculate SCAR values for all ProbeSets designated as SNP.</span>
<a name="l01479"></a>01479         <span class="keywordflow">if</span>(pobjProbeSet-&gt;processAsSNP())
<a name="l01480"></a>01480         {
<a name="l01481"></a>01481             <span class="keywordflow">if</span>(pobjProbeSet-&gt;getAAlleleSignal() == 0.0 || pobjProbeSet-&gt;getBAlleleSignal() == 0.0){
<a name="l01482"></a>01482                 <a class="code" href="classVerbose.html#a34e1d936178741eeb78de93c5497e1b8" title="Print a warning message.">Verbose::warn</a>(1, <span class="stringliteral">&quot;CNAnalysisMethodLOHCyto2:: Invalid A or B allele signals were found for the ProbeSet &quot;</span> + pobjProbeSet-&gt;getProbeSetName());
<a name="l01483"></a>01483                 vSCAR[iIndex] = CN_INVALID_DOUBLE;
<a name="l01484"></a>01484                 pobjProbeSet-&gt;setValidSCARExists(<span class="keyword">false</span>);
<a name="l01485"></a>01485                 <span class="keywordflow">continue</span>;
<a name="l01486"></a>01486             }
<a name="l01487"></a>01487             <span class="keywordflow">if</span>(pobjProbeSet-&gt;getMuAA() == CN_INVALID_DOUBLE || pobjProbeSet-&gt;getMuAB() == CN_INVALID_DOUBLE || pobjProbeSet-&gt;getMuBB() == CN_INVALID_DOUBLE)
<a name="l01488"></a>01488             {
<a name="l01489"></a>01489                 <a class="code" href="classVerbose.html#a34e1d936178741eeb78de93c5497e1b8" title="Print a warning message.">Verbose::warn</a>(1, <span class="stringliteral">&quot;CNAnalysisMethodLOHCyto2:: Invalid snp-reference parameters for probe set &quot;</span> + pobjProbeSet-&gt;getProbeSetName() + <span class="stringliteral">&quot;. LOH computations will be done without this probe set.&quot;</span>);
<a name="l01490"></a>01490                 vSCAR[iIndex] = CN_INVALID_DOUBLE;
<a name="l01491"></a>01491                 pobjProbeSet-&gt;setValidSCARExists(<span class="keyword">false</span>);
<a name="l01492"></a>01492                 <span class="keywordflow">continue</span>;
<a name="l01493"></a>01493             }
<a name="l01494"></a>01494 
<a name="l01495"></a>01495             fSCAR = (
<a name="l01496"></a>01496                       2.0*( <a class="code" href="Util_8h.html#a18af743c2cec4baeee9ffb27999ddaad" title="Log base two.">log2</a>((<span class="keywordtype">float</span>)pobjProbeSet-&gt;getAAlleleSignal()/(float)pobjProbeSet-&gt;getBAlleleSignal()) - pobjProbeSet-&gt;getMuAB() )
<a name="l01497"></a>01497                     )
<a name="l01498"></a>01498                     /
<a name="l01499"></a>01499                     (
<a name="l01500"></a>01500                       fabs( pobjProbeSet-&gt;getMuAA() - pobjProbeSet-&gt;getMuAB() )
<a name="l01501"></a>01501                       +
<a name="l01502"></a>01502                       fabs( pobjProbeSet-&gt;getMuBB() - pobjProbeSet-&gt;getMuAB() )
<a name="l01503"></a>01503                     );
<a name="l01504"></a>01504             <span class="keywordflow">if</span>(fSCAR &lt; -4.0) fSCAR = -4.0;
<a name="l01505"></a>01505             <span class="keywordflow">if</span>(fSCAR &gt; 4.0) fSCAR = 4.0;
<a name="l01506"></a>01506 
<a name="l01507"></a>01507 
<a name="l01508"></a>01508             vSCAR[iIndex] = fSCAR;
<a name="l01509"></a>01509             pobjProbeSet-&gt;setValidSCARExists(<span class="keyword">true</span>);
<a name="l01510"></a>01510         } <span class="keywordflow">else</span>
<a name="l01511"></a>01511         {
<a name="l01512"></a>01512             vSCAR[iIndex] = CN_INVALID_DOUBLE;
<a name="l01513"></a>01513             pobjProbeSet-&gt;setValidSCARExists(<span class="keyword">false</span>);
<a name="l01514"></a>01514         }
<a name="l01515"></a>01515         pobjProbeSet-&gt;setSCAR(fSCAR);
<a name="l01516"></a>01516     }
<a name="l01517"></a>01517 }
<a name="l01518"></a>01518 
<a name="l01519"></a>01519 <span class="keywordtype">void</span> CNAnalysisMethod::calculateWindows( vector&lt;pair&lt;int, int&gt; &gt;&amp; windowBds,
<a name="l01520"></a>01520                                          vector&lt;pair&lt;int, int&gt; &gt;&amp; stepWindowBds,
<a name="l01521"></a>01521                                          <span class="keyword">const</span> pair&lt;int, int&gt;&amp; chrBound,
<a name="l01522"></a>01522                                          <span class="keywordtype">int</span> iStep,
<a name="l01523"></a>01523                                          <span class="keywordtype">int</span> iWindow
<a name="l01524"></a>01524                                          )
<a name="l01525"></a>01525 {
<a name="l01526"></a>01526     <span class="keywordtype">int</span> chrStart = chrBound.first;
<a name="l01527"></a>01527     <span class="keywordtype">int</span> chrEnd   = chrBound.second - 1;
<a name="l01528"></a>01528     <span class="keywordtype">int</span> N        = chrEnd - chrStart + 1;
<a name="l01529"></a>01529     <span class="keywordtype">float</span> fk     = float(N - iWindow)/iStep;
<a name="l01530"></a>01530     <span class="keywordtype">int</span> numWin   = max(1, <span class="keywordtype">int</span>(std::floor(fk)) + 1);    <span class="comment">// must have at least one window</span>
<a name="l01531"></a>01531     <span class="keywordtype">int</span> <a class="code" href="snp_8label_8cpp.html#ad748ef26c031cf6086e3a490afd3a47f" title="difference in cumulative sums: i.e.">delta</a>    = N - iWindow - iStep*(numWin - 1);
<a name="l01532"></a>01532     <span class="keywordtype">int</span> eps      = delta/2;
<a name="l01533"></a>01533     <span class="keywordtype">int</span> mm       = (iWindow - iStep)/2;
<a name="l01534"></a>01534     <span class="keywordtype">int</span> nn       = iWindow - mm - iStep;
<a name="l01535"></a>01535 
<a name="l01536"></a>01536     <span class="keywordtype">int</span> winSize = iWindow - 1;
<a name="l01537"></a>01537     <span class="keywordflow">if</span> (fk &lt; 1.0 || fk &gt;= 2.0) {
<a name="l01538"></a>01538         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; numWin; j++) {
<a name="l01539"></a>01539             <span class="keywordtype">int</span> left = chrStart + j*iStep + eps;
<a name="l01540"></a>01540             windowBds.push_back(make_pair(left, left + winSize));
<a name="l01541"></a>01541             stepWindowBds.push_back(make_pair(left + mm, left + winSize - nn));
<a name="l01542"></a>01542         }
<a name="l01543"></a>01543         <span class="comment">// Extend first and last windows to cover entire chromosome</span>
<a name="l01544"></a>01544         windowBds[0].first = chrStart;
<a name="l01545"></a>01545         windowBds[numWin - 1].second = chrEnd;
<a name="l01546"></a>01546         stepWindowBds[0].first = chrStart;
<a name="l01547"></a>01547         stepWindowBds[numWin - 1].second = chrEnd;
<a name="l01548"></a>01548     }
<a name="l01549"></a>01549     <span class="keywordflow">else</span> {
<a name="l01550"></a>01550         <span class="comment">// Set up 2 equal windows even if numWin == 1</span>
<a name="l01551"></a>01551         windowBds.push_back(make_pair(chrStart, chrStart + winSize + eps));
<a name="l01552"></a>01552         windowBds.push_back(make_pair(chrEnd - winSize - eps, chrEnd));
<a name="l01553"></a>01553         stepWindowBds.push_back(make_pair(chrStart, chrStart + N/2 - 1));
<a name="l01554"></a>01554         stepWindowBds.push_back(make_pair(chrStart + N/2, chrEnd));
<a name="l01555"></a>01555     }
<a name="l01556"></a>01556 }
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 <span class="keywordtype">void</span> CNAnalysisMethod::calculateWeights( <a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>* probeSets,
<a name="l01559"></a>01559                                          vector&lt;double&gt;&amp; vValsToProcess,
<a name="l01560"></a>01560                                          vector&lt;double&gt;&amp; weights,
<a name="l01561"></a>01561                                          <span class="keyword">const</span> pair&lt;int, int&gt;&amp; windowBds,
<a name="l01562"></a>01562                                          <span class="keywordtype">bool</span> symmetry
<a name="l01563"></a>01563                                          )
<a name="l01564"></a>01564 {
<a name="l01565"></a>01565     <span class="keyword">const</span> <span class="keywordtype">bool</span> isCyto2 = m_pEngine-&gt;<a class="code" href="classOptions.html#a3c98038375042f9b230b3e4e2151fe00" title="Get the boolean value of an option.">getOptBool</a>(<span class="stringliteral">&quot;cyto2&quot;</span>);
<a name="l01566"></a>01566     <span class="keywordtype">double</span> dSumReplicateCounts = 0;
<a name="l01567"></a>01567     <span class="keywordtype">int</span> sizeMax = windowBds.second - windowBds.first + 1;
<a name="l01568"></a>01568     <span class="keywordflow">if</span> (symmetry) {
<a name="l01569"></a>01569         <span class="comment">// Twice the size because we are adding mirror images.</span>
<a name="l01570"></a>01570         vValsToProcess.resize(2*sizeMax);
<a name="l01571"></a>01571         weights.resize(2*sizeMax);
<a name="l01572"></a>01572 
<a name="l01573"></a>01573         <span class="keywordtype">int</span> k = 0;
<a name="l01574"></a>01574         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = windowBds.first; i &lt;= windowBds.second; i++) {
<a name="l01575"></a>01575             dSumReplicateCounts += probeSets-&gt;getAt(i)-&gt;getReplicateCount();
<a name="l01576"></a>01576 
<a name="l01577"></a>01577             <span class="keywordflow">if</span> (isCyto2) {
<a name="l01578"></a>01578                 vValsToProcess[k] = probeSets-&gt;getAt(i)-&gt;getSCAR();
<a name="l01579"></a>01579             }
<a name="l01580"></a>01580             <span class="keywordflow">else</span> {
<a name="l01581"></a>01581                 vValsToProcess[k] = probeSets-&gt;getAt(i)-&gt;getAllelicDifference();
<a name="l01582"></a>01582             }
<a name="l01583"></a>01583             vValsToProcess[k+sizeMax] = -vValsToProcess[k];   <span class="comment">// the mirror image</span>
<a name="l01584"></a>01584             k++;
<a name="l01585"></a>01585         }
<a name="l01586"></a>01586         k = 0;
<a name="l01587"></a>01587         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = windowBds.first; i &lt;= windowBds.second; i++) {
<a name="l01588"></a>01588             <span class="keywordflow">if</span> (dSumReplicateCounts == 0) {
<a name="l01589"></a>01589                 weights[k] = 1.0;
<a name="l01590"></a>01590             }
<a name="l01591"></a>01591             <span class="keywordflow">else</span> {
<a name="l01592"></a>01592                 weights[k] = probeSets-&gt;getAt(i)-&gt;getReplicateCount()/dSumReplicateCounts;
<a name="l01593"></a>01593             }
<a name="l01594"></a>01594             weights[k+sizeMax] = weights[k];
<a name="l01595"></a>01595             k++;
<a name="l01596"></a>01596         }
<a name="l01597"></a>01597     }
<a name="l01598"></a>01598     <span class="keywordflow">else</span> {
<a name="l01599"></a>01599         vValsToProcess.resize(sizeMax);
<a name="l01600"></a>01600         weights.resize(sizeMax);
<a name="l01601"></a>01601 
<a name="l01602"></a>01602         <span class="keywordtype">int</span> k = 0;
<a name="l01603"></a>01603         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = windowBds.first; i &lt;= windowBds.second; i++) {
<a name="l01604"></a>01604             dSumReplicateCounts += probeSets-&gt;getAt(i)-&gt;getReplicateCount();
<a name="l01605"></a>01605 
<a name="l01606"></a>01606             <span class="keywordflow">if</span> (isCyto2) {
<a name="l01607"></a>01607                 vValsToProcess[k] = probeSets-&gt;getAt(i)-&gt;getSCAR();
<a name="l01608"></a>01608             }
<a name="l01609"></a>01609             <span class="keywordflow">else</span> {
<a name="l01610"></a>01610                 vValsToProcess[k] = probeSets-&gt;getAt(i)-&gt;getAllelicDifference();
<a name="l01611"></a>01611             }
<a name="l01612"></a>01612             k++;
<a name="l01613"></a>01613         }
<a name="l01614"></a>01614         k = 0;
<a name="l01615"></a>01615         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = windowBds.first; i &lt;= windowBds.second; i++) {
<a name="l01616"></a>01616             <span class="keywordflow">if</span> (dSumReplicateCounts == 0) {
<a name="l01617"></a>01617                 weights[k] = 1.0;
<a name="l01618"></a>01618             }
<a name="l01619"></a>01619             <span class="keywordflow">else</span> {
<a name="l01620"></a>01620                 weights[k] = probeSets-&gt;getAt(i)-&gt;getReplicateCount()/dSumReplicateCounts;
<a name="l01621"></a>01621             }
<a name="l01622"></a>01622             k++;
<a name="l01623"></a>01623         }
<a name="l01624"></a>01624     }
<a name="l01625"></a>01625 }
<a name="l01626"></a>01626 
<a name="l01627"></a>01627 <span class="keywordtype">int</span> CNAnalysisMethod::findpeaks(    vector&lt;int&gt; &amp;valleys,
<a name="l01628"></a>01628                                     vector&lt;int&gt; &amp;peaks,
<a name="l01629"></a>01629                                     vector&lt;double&gt; &amp;y,
<a name="l01630"></a>01630                                     <span class="keywordtype">double</span> delta,
<a name="l01631"></a>01631                                     vector&lt;double&gt; &amp;x
<a name="l01632"></a>01632                                     )
<a name="l01633"></a>01633 {
<a name="l01634"></a>01634 
<a name="l01635"></a>01635     <span class="comment">// findpeaks: Detect peaks and valleys in y = f(x), x is ordered low to high</span>
<a name="l01636"></a>01636     <span class="comment">//       findpeaks(valleys, peaks, y, delta, x) the indices of x corresponding</span>
<a name="l01637"></a>01637     <span class="comment">//         to valleys is returned in valleys, the indices of x corresponding to</span>
<a name="l01638"></a>01638     <span class="comment">//       to peaks is returned in peaks.</span>
<a name="l01639"></a>01639     <span class="comment">//       A point is considered a maximum peak if it has the maximal</span>
<a name="l01640"></a>01640     <span class="comment">//       value, and was preceded (to the left) by less than delta</span>
<a name="l01641"></a>01641 
<a name="l01642"></a>01642     <span class="keywordflow">if</span> ((y.size() &lt;= 3) || (x.size() != y.size()) || (delta &lt;= 0))
<a name="l01643"></a>01643     {
<a name="l01644"></a>01644         <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;The allele-peaks analysis method has failed. Inconsistent input data found in findpeaks().&quot;</span>));
<a name="l01645"></a>01645     }
<a name="l01646"></a>01646 
<a name="l01647"></a>01647     <span class="keywordtype">double</span> mn = numeric_limits&lt;double&gt;::infinity();
<a name="l01648"></a>01648     <span class="keywordtype">double</span> mx = -numeric_limits&lt;double&gt;::infinity();
<a name="l01649"></a>01649 
<a name="l01650"></a>01650         <span class="keywordtype">bool</span> lookformax = <span class="keyword">true</span>;
<a name="l01651"></a>01651 
<a name="l01652"></a>01652     <span class="keywordtype">int</span> imax = 0;
<a name="l01653"></a>01653     <span class="keywordtype">int</span> imin = 0;
<a name="l01654"></a>01654 
<a name="l01655"></a>01655     <span class="keywordtype">int</span> npeak = 0;
<a name="l01656"></a>01656 
<a name="l01657"></a>01657     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;y.size(); ++i){
<a name="l01658"></a>01658         <span class="keywordtype">double</span> v = y[i];
<a name="l01659"></a>01659         <span class="keywordflow">if</span> (v&gt;mx) {
<a name="l01660"></a>01660             mx = v;
<a name="l01661"></a>01661             imax = i;
<a name="l01662"></a>01662         }
<a name="l01663"></a>01663         <span class="keywordflow">if</span> (v&lt;mn) {
<a name="l01664"></a>01664             mn = v;
<a name="l01665"></a>01665             imin = i;
<a name="l01666"></a>01666         }
<a name="l01667"></a>01667         <span class="keywordflow">if</span> (lookformax) {
<a name="l01668"></a>01668             <span class="keywordflow">if</span> (v &lt; (mx - delta)){
<a name="l01669"></a>01669                 peaks.push_back(imax);
<a name="l01670"></a>01670                 npeak++;
<a name="l01671"></a>01671                 mn = v;
<a name="l01672"></a>01672                 imin = i;
<a name="l01673"></a>01673                 lookformax = <span class="keyword">false</span>;
<a name="l01674"></a>01674             }
<a name="l01675"></a>01675         } <span class="keywordflow">else</span> {
<a name="l01676"></a>01676             <span class="keywordflow">if</span> (v &gt; (mn + delta)){
<a name="l01677"></a>01677                 valleys.push_back(imin);
<a name="l01678"></a>01678                 mx = v;
<a name="l01679"></a>01679                 imax = i;
<a name="l01680"></a>01680                 lookformax = <span class="keyword">true</span>;
<a name="l01681"></a>01681             }
<a name="l01682"></a>01682         }
<a name="l01683"></a>01683     }
<a name="l01684"></a>01684     <span class="keywordflow">return</span>(npeak);
<a name="l01685"></a>01685 }
<a name="l01686"></a>01686 
<a name="l01687"></a>01687 <span class="comment"></span>
<a name="l01688"></a>01688 <span class="comment">/**</span>
<a name="l01689"></a>01689 <span class="comment">  * For each probe set store maximum number of peaks</span>
<a name="l01690"></a>01690 <span class="comment">  * over all windows containing this probe set.</span>
<a name="l01691"></a>01691 <span class="comment">  */</span>
<a name="l01692"></a><a class="code" href="classCNAnalysisMethod.html#ae4bf7eeb934b7da4f8e9b3a105422be9">01692</a> <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethod.html#ae4bf7eeb934b7da4f8e9b3a105422be9" title="For each probe set store maximum number of peaks over all windows containing this probe set...">CNAnalysisMethod::findMaxPeaks</a>( <a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>* probeSets,
<a name="l01693"></a>01693                                      <span class="keyword">const</span> vector&lt;pair&lt;int, int&gt; &gt;&amp; windowBds,
<a name="l01694"></a>01694                                      <span class="keyword">const</span> vector&lt;vector&lt;double&gt; &gt;&amp; peaks
<a name="l01695"></a>01695                                      )
<a name="l01696"></a>01696 {
<a name="l01697"></a>01697     <span class="keywordtype">int</span> size = windowBds.size();
<a name="l01698"></a>01698     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = windowBds[0].first; i &lt;= windowBds[size - 1].second; i++) {
<a name="l01699"></a>01699         probeSets-&gt;getAt(i)-&gt;setMaxPeaks(0);
<a name="l01700"></a>01700     }
<a name="l01701"></a>01701     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = windowBds[0].first; i &lt;= windowBds[0].second; i++) {
<a name="l01702"></a>01702         probeSets-&gt;getAt(i)-&gt;setMaxPeaks(peaks[0].size());
<a name="l01703"></a>01703     }
<a name="l01704"></a>01704     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> win = 1; win &lt; windowBds.size(); win++) {
<a name="l01705"></a>01705         <span class="keywordtype">int</span> curNumPeaks = peaks[win].size();
<a name="l01706"></a>01706         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = windowBds[win].first; i &lt;= windowBds[win].second; i++) {
<a name="l01707"></a>01707             <span class="keywordflow">if</span> (probeSets-&gt;getAt(i)-&gt;getMaxPeaks() &lt; curNumPeaks) {
<a name="l01708"></a>01708                 probeSets-&gt;getAt(i)-&gt;setMaxPeaks(curNumPeaks);
<a name="l01709"></a>01709             }
<a name="l01710"></a>01710         }
<a name="l01711"></a>01711     }
<a name="l01712"></a>01712 }
<a name="l01713"></a>01713 
<a name="l01714"></a>01714 
<a name="l01715"></a>01715 <span class="keywordtype">int</span> CNAnalysisMethod::findcutoffInd(<span class="keyword">const</span> vector&lt;float&gt;&amp; snpqc)
<a name="l01716"></a>01716 {
<a name="l01717"></a>01717     <span class="keywordflow">if</span> (snpqc.empty()) {
<a name="l01718"></a>01718         <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;CNAnalysisMethodAllelePeaks: empty vector snpqc in findcutoffInd()&quot;</span>);
<a name="l01719"></a>01719     }
<a name="l01720"></a>01720     <span class="keywordtype">float</span> SNPQC = getExperiment()-&gt;getSNPQC();
<a name="l01721"></a>01721 
<a name="l01722"></a>01722     vector&lt;float&gt;::const_iterator iter = std::upper_bound(snpqc.begin(), snpqc.end(), SNPQC);
<a name="l01723"></a>01723 
<a name="l01724"></a>01724     <span class="keywordflow">if</span> (iter == snpqc.begin()) {
<a name="l01725"></a>01725         iter++;
<a name="l01726"></a>01726     }
<a name="l01727"></a>01727     <span class="keywordflow">return</span> iter - snpqc.begin() - 1;
<a name="l01728"></a>01728 }
<a name="l01729"></a>01729 
<a name="l01730"></a>01730 <span class="keywordtype">void</span> CNAnalysisMethod::shrinkToPeaks(<a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>* probeSets, <a class="code" href="structCNAnalysisMethod_1_1PeakShrinkOverride.html">CNAnalysisMethod::PeakShrinkOverride</a> *paramOverride)
<a name="l01731"></a>01731 {
<a name="l01732"></a>01732     <span class="keyword">const</span> <span class="keywordtype">bool</span> keepIntermediateData = m_pEngine-&gt;<a class="code" href="classOptions.html#a3c98038375042f9b230b3e4e2151fe00" title="Get the boolean value of an option.">getOptBool</a>(<span class="stringliteral">&quot;keep-intermediate-data&quot;</span>);
<a name="l01733"></a>01733     <span class="keyword">const</span> <span class="keywordtype">bool</span> isCytoScanHD = m_pEngine-&gt;<a class="code" href="classOptions.html#a3c98038375042f9b230b3e4e2151fe00" title="Get the boolean value of an option.">getOptBool</a>(<span class="stringliteral">&quot;cytoscan-hd&quot;</span>);
<a name="l01734"></a>01734     <span class="keyword">const</span> <span class="keywordtype">bool</span> isCyto2 = m_pEngine-&gt;<a class="code" href="classOptions.html#a3c98038375042f9b230b3e4e2151fe00" title="Get the boolean value of an option.">getOptBool</a>(<span class="stringliteral">&quot;cyto2&quot;</span>);
<a name="l01735"></a>01735     <span class="keyword">const</span> <span class="keywordtype">bool</span> useKdensity = m_pEngine-&gt;<a class="code" href="classOptions.html#a3c98038375042f9b230b3e4e2151fe00" title="Get the boolean value of an option.">getOptBool</a>(<span class="stringliteral">&quot;use-old-kdensity-function&quot;</span>);
<a name="l01736"></a>01736     <span class="keyword">const</span> <span class="keywordtype">int</span> noCovariateIndex = -1;
<a name="l01737"></a>01737 
<a name="l01738"></a>01738     <span class="comment">// set the parameters to the member values (the default)</span>
<a name="l01739"></a>01739     <span class="keywordtype">int</span> iStep = m_iStep;
<a name="l01740"></a>01740     <span class="keywordtype">int</span> iWindow = m_iWindow;
<a name="l01741"></a>01741     <span class="keywordtype">int</span> iPointCount = m_iPointCount;
<a name="l01742"></a>01742     <span class="keywordtype">double</span> dBandwidth = m_dBandwidth;
<a name="l01743"></a>01743     <span class="keywordtype">double</span> dCutoff = m_dCutoff;
<a name="l01744"></a>01744     <span class="keywordtype">double</span> dCleanThreshold = m_dCleanThreshold;
<a name="l01745"></a>01745     <span class="keywordtype">bool</span> bSymmetry = m_bSymmetry;
<a name="l01746"></a>01746 
<a name="l01747"></a>01747     <span class="keywordtype">int</span> iCovariateIndex = noCovariateIndex;   <span class="comment">// used for intermediate data output</span>
<a name="l01748"></a>01748 
<a name="l01749"></a>01749     <span class="keywordtype">bool</span> saveAllelePeaksFlag = <span class="keyword">false</span>;
<a name="l01750"></a>01750 
<a name="l01751"></a>01751     <span class="comment">// reset to the override if supplied</span>
<a name="l01752"></a>01752     <span class="keywordflow">if</span> (paramOverride)
<a name="l01753"></a>01753     {
<a name="l01754"></a>01754         iStep           = paramOverride-&gt;m_iStep_override;
<a name="l01755"></a>01755         iWindow         = paramOverride-&gt;m_iWindow_override;
<a name="l01756"></a>01756         iPointCount     = paramOverride-&gt;m_iPointCount_override;
<a name="l01757"></a>01757         dBandwidth      = paramOverride-&gt;m_dBandwidth_override;
<a name="l01758"></a>01758         dCutoff         = paramOverride-&gt;m_dCutoff_override;
<a name="l01759"></a>01759         dCleanThreshold = paramOverride-&gt;m_dCleanThreshold_override;
<a name="l01760"></a>01760         bSymmetry       = paramOverride-&gt;m_bSymmetry_override;
<a name="l01761"></a>01761         iCovariateIndex = paramOverride-&gt;m_iCovariateIndex;
<a name="l01762"></a>01762         saveAllelePeaksFlag = <span class="keyword">true</span>;
<a name="l01763"></a>01763         m_vCoarseAllelePeaks.resize(probeSets-&gt;size());
<a name="l01764"></a>01764     }
<a name="l01765"></a>01765 
<a name="l01766"></a>01766     <span class="comment">// For intermediate testing</span>
<a name="l01767"></a>01767     vector&lt;pair&lt;int, int&gt; &gt; peakWindows;
<a name="l01768"></a>01768     vector&lt;pair&lt;int, int&gt; &gt; stepWindows;
<a name="l01769"></a>01769     vector&lt;pair&lt;int, double&gt; &gt; closestPeak;
<a name="l01770"></a>01770     vector&lt;pair&lt;pair&lt;int, int&gt;, vector&lt;double&gt; &gt; &gt; peakSets;
<a name="l01771"></a>01771     vector&lt;pair&lt;int, double&gt; &gt; processedValues;
<a name="l01772"></a>01772     apParameters apParametersValues;
<a name="l01773"></a>01773     cutoffShrinkage cutoffShrinkageValues;
<a name="l01774"></a>01774     <span class="comment">//</span>
<a name="l01775"></a>01775 
<a name="l01776"></a>01776     vector&lt;double&gt; vValsToProcess;
<a name="l01777"></a>01777     vector&lt;double&gt; weights;
<a name="l01778"></a>01778     vector&lt;double&gt; density(iPointCount);
<a name="l01779"></a>01779     vector&lt;double&gt; xi(iPointCount);
<a name="l01780"></a>01780     vector&lt;double&gt; vPeakLocations(iPointCount);
<a name="l01781"></a>01781     vector&lt;int&gt; chromosomes;
<a name="l01782"></a>01782 
<a name="l01783"></a>01783     <span class="keywordtype">int</span> cutoffIndFLD3 = findcutoffInd(m_vThreePeakFLD_X);
<a name="l01784"></a>01784     <span class="keywordtype">int</span> cutoffIndFLD4 = findcutoffInd(m_vFourPeakFLD_X);
<a name="l01785"></a>01785     <span class="keywordtype">int</span> cutoffIndShrink3 = findcutoffInd(m_vThreePeakShrink_X);
<a name="l01786"></a>01786     <span class="keywordtype">int</span> cutoffIndShrink4 = findcutoffInd(m_vFourPeakShrink_X);
<a name="l01787"></a>01787 
<a name="l01788"></a>01788     <span class="comment">// For deep regression</span>
<a name="l01789"></a>01789     cutoffShrinkageValues.FLD3threshold = m_vThreePeakFLD_Y[cutoffIndFLD3];
<a name="l01790"></a>01790     cutoffShrinkageValues.FLD4threshold = m_vFourPeakFLD_Y[cutoffIndFLD4];
<a name="l01791"></a>01791     cutoffShrinkageValues.shrinkage3 = m_vThreePeakShrink_Y[cutoffIndShrink3];
<a name="l01792"></a>01792     cutoffShrinkageValues.shrinkage4 = m_vFourPeakShrink_Y[cutoffIndShrink4];
<a name="l01793"></a>01793     cutoffShrinkageValues.SNPQC = getExperiment()-&gt;getSNPQC();
<a name="l01794"></a>01794 
<a name="l01795"></a>01795     apParametersValues.window = iWindow;
<a name="l01796"></a>01796     apParametersValues.step = iStep;
<a name="l01797"></a>01797     apParametersValues.densityPointCount = iPointCount;  <span class="comment">// presumed &gt;= CNAnalysisMethod::allelePeakCount</span>
<a name="l01798"></a>01798     apParametersValues.peaksCutoff = dCutoff;
<a name="l01799"></a>01799     apParametersValues.cleanThreshold = dCleanThreshold;
<a name="l01800"></a>01800     apParametersValues.bandwidthFactor = dBandwidth;
<a name="l01801"></a>01801     apParametersValues.symmetry = bSymmetry;
<a name="l01802"></a>01802     apParametersValues.covariateIndex = iCovariateIndex;
<a name="l01803"></a>01803     <span class="comment">//</span>
<a name="l01804"></a>01804 
<a name="l01805"></a>01805     vector&lt;bool&gt; filteredProbeSets(probeSets-&gt;getCount(), <span class="keyword">false</span>);
<a name="l01806"></a>01806 
<a name="l01807"></a>01807     <span class="comment">// Collect the chromosomes and sort them</span>
<a name="l01808"></a>01808     <span class="keywordflow">for</span> (map&lt;<span class="keywordtype">int</span>, pair&lt;int, int&gt; &gt;::iterator it = m_chrBounds.begin();
<a name="l01809"></a>01809          it != m_chrBounds.end();
<a name="l01810"></a>01810          ++it)
<a name="l01811"></a>01811     {
<a name="l01812"></a>01812         chromosomes.push_back(it-&gt;first);
<a name="l01813"></a>01813     }
<a name="l01814"></a>01814     sort(chromosomes.begin(), chromosomes.end());
<a name="l01815"></a>01815 
<a name="l01816"></a>01816     <span class="keyword">const</span> <span class="keywordtype">bool</span> useOldDensity = isCyto2 || useKdensity;
<a name="l01817"></a>01817     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> chrInd = 0; chrInd &lt; chromosomes.size(); chrInd++) {
<a name="l01818"></a>01818         vector&lt;pair&lt;int, int&gt; &gt; windowBds;
<a name="l01819"></a>01819         vector&lt;pair&lt;int, int&gt; &gt; stepWindowBds;
<a name="l01820"></a>01820         calculateWindows(windowBds, stepWindowBds, m_chrBounds[chromosomes[chrInd]], iStep, iWindow);
<a name="l01821"></a>01821 
<a name="l01822"></a>01822         vector&lt;vector&lt;double&gt; &gt; peaks(windowBds.size());
<a name="l01823"></a>01823 
<a name="l01824"></a>01824         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> winInd = 0; winInd &lt; windowBds.size(); winInd++)
<a name="l01825"></a>01825         {
<a name="l01826"></a>01826             <span class="keywordtype">bool</span> symmetrySetting;
<a name="l01827"></a>01827             <span class="keywordflow">if</span> (useOldDensity) {
<a name="l01828"></a>01828                 symmetrySetting = bSymmetry;
<a name="l01829"></a>01829                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> z = 0; z &lt; m_iPointCount; z++) {
<a name="l01830"></a>01830                     density[z] = 0;
<a name="l01831"></a>01831                 }
<a name="l01832"></a>01832             }
<a name="l01833"></a>01833             <span class="keywordflow">else</span> {
<a name="l01834"></a>01834                 <span class="comment">// don&#39;t symmetrise by brute force, it&#39;s done more efficiently in fitDensityCurve()</span>
<a name="l01835"></a>01835                 symmetrySetting = <span class="keyword">false</span>;
<a name="l01836"></a>01836             }
<a name="l01837"></a>01837             calculateWeights(probeSets, vValsToProcess, weights, windowBds[winInd], symmetrySetting);
<a name="l01838"></a>01838 
<a name="l01839"></a>01839             <span class="keywordtype">double</span> wsum = 0;
<a name="l01840"></a>01840             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;weights.size(); ++k) {
<a name="l01841"></a>01841                 wsum += weights[k];
<a name="l01842"></a>01842             }
<a name="l01843"></a>01843             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;weights.size(); ++k) {
<a name="l01844"></a>01844                 weights[k] = weights[k]/wsum;
<a name="l01845"></a>01845             }
<a name="l01846"></a>01846 
<a name="l01847"></a>01847             <span class="comment">// call bandwidth calculation</span>
<a name="l01848"></a>01848             <span class="keywordtype">double</span> bw = bwnrd(vValsToProcess, dBandwidth);
<a name="l01849"></a>01849 
<a name="l01850"></a>01850             <span class="keywordflow">if</span> (useOldDensity) {
<a name="l01851"></a>01851                 <a class="code" href="classCNAnalysisMethod.html#a778159232b3c60eae22ab65041c8b0db" title="kernel density() with an normal kernel">kdensity</a>(vValsToProcess, density, xi, weights, bw);
<a name="l01852"></a>01852             }
<a name="l01853"></a>01853             <span class="keywordflow">else</span> {
<a name="l01854"></a>01854                 fitDensityCurve(vValsToProcess, weights, xi, density, iPointCount, bw, bSymmetry);
<a name="l01855"></a>01855             }
<a name="l01856"></a>01856 
<a name="l01857"></a>01857             <span class="comment">// compute overall signal</span>
<a name="l01858"></a>01858             vector&lt;double&gt; sqdensity(density.size());
<a name="l01859"></a>01859             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;density.size(); ++k) {
<a name="l01860"></a>01860                 sqdensity[k] = density[k] * density[k];
<a name="l01861"></a>01861             }
<a name="l01862"></a>01862             <span class="keywordtype">double</span> overallSignal = trapzoid(xi, sqdensity);
<a name="l01863"></a>01863 
<a name="l01864"></a>01864             <span class="comment">// find the peaks in (xi, density) and return in peaks</span>
<a name="l01865"></a>01865             vector&lt;int&gt; peakIndex;
<a name="l01866"></a>01866             vector&lt;int&gt; valleyIndex;
<a name="l01867"></a>01867             <span class="keywordtype">int</span> npeak1 = findpeaks(valleyIndex, peakIndex, density, 0.046*overallSignal, xi);
<a name="l01868"></a>01868 
<a name="l01869"></a>01869             <span class="keywordtype">int</span> nData = vValsToProcess.size();
<a name="l01870"></a>01870             <span class="keywordtype">int</span> npeak = 0;
<a name="l01871"></a>01871 
<a name="l01872"></a>01872             <span class="comment">// trim off any peaks in extremes of data</span>
<a name="l01873"></a>01873             <span class="keywordflow">if</span> (npeak1 &gt; 0) {
<a name="l01874"></a>01874                 <span class="comment">// calculate lower percentile</span>
<a name="l01875"></a>01875                 <span class="keywordtype">double</span> *tmpdata = <span class="keyword">new</span> <span class="keywordtype">double</span>[nData];
<a name="l01876"></a>01876                 <span class="keywordtype">int</span> nLow = (int)(dCutoff*nData - 0.5);
<a name="l01877"></a>01877                 <span class="keywordflow">if</span> (nLow &lt; 0){
<a name="l01878"></a>01878                     nLow = 0;
<a name="l01879"></a>01879                 }
<a name="l01880"></a>01880                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nData; ++i){
<a name="l01881"></a>01881                     tmpdata[i] = vValsToProcess[i];
<a name="l01882"></a>01882                 }
<a name="l01883"></a>01883                 <span class="keywordtype">double</span> percentileLower = klowest_select(tmpdata, nData, nLow);
<a name="l01884"></a>01884 
<a name="l01885"></a>01885                 <span class="comment">// calculate upper percentile</span>
<a name="l01886"></a>01886                 <span class="keywordtype">int</span> nHigh = (int)((1-dCutoff)*nData - 0.5);
<a name="l01887"></a>01887                 <span class="keywordflow">if</span> (nHigh &lt; 0){
<a name="l01888"></a>01888                     nHigh = 0;
<a name="l01889"></a>01889                 }
<a name="l01890"></a>01890                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nData; ++i){
<a name="l01891"></a>01891                     tmpdata[i] = vValsToProcess[i];
<a name="l01892"></a>01892                 }
<a name="l01893"></a>01893                 <span class="keywordtype">double</span> percentileUpper = klowest_select(tmpdata, nData, nHigh);
<a name="l01894"></a>01894                 <span class="keyword">delete</span> [] tmpdata;
<a name="l01895"></a>01895 
<a name="l01896"></a>01896                 <span class="comment">// ignore any peaks outside this range</span>
<a name="l01897"></a>01897                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;peakIndex.size(); ++i){
<a name="l01898"></a>01898                     <span class="keywordflow">if</span> ((xi[peakIndex[i]]&gt;=percentileLower) &amp;&amp; (xi[peakIndex[i]]&lt;=percentileUpper)){
<a name="l01899"></a>01899                         vPeakLocations[npeak++] = xi[peakIndex[i]];
<a name="l01900"></a>01900                     }
<a name="l01901"></a>01901                 }
<a name="l01902"></a>01902             }
<a name="l01903"></a>01903             <span class="keywordtype">int</span> iPeakCount = npeak;
<a name="l01904"></a>01904             <span class="keywordtype">int</span> maxAllelePeakCount = allelePeakCount;
<a name="l01905"></a>01905             <span class="keywordflow">if</span> (isCytoScanHD) {
<a name="l01906"></a>01906                 maxAllelePeakCount = CytoScanHDAllelePeakCount;
<a name="l01907"></a>01907             }
<a name="l01908"></a>01908 
<a name="l01909"></a>01909             <span class="keywordflow">if</span> (iPeakCount &gt; maxAllelePeakCount) {
<a name="l01910"></a>01910                 iPeakCount = maxAllelePeakCount;
<a name="l01911"></a>01911             }
<a name="l01912"></a>01912             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iAllelePeakIndex = 0; (iAllelePeakIndex &lt; iPeakCount); iAllelePeakIndex++)
<a name="l01913"></a>01913             {
<a name="l01914"></a>01914                 <span class="keywordflow">if</span> (vPeakLocations[iAllelePeakIndex] &lt; -iMaxPeak) {
<a name="l01915"></a>01915                     vPeakLocations[iAllelePeakIndex] = -iMaxPeak;
<a name="l01916"></a>01916                 }
<a name="l01917"></a>01917                 <span class="keywordflow">if</span> (vPeakLocations[iAllelePeakIndex] &gt; iMaxPeak) {
<a name="l01918"></a>01918                     vPeakLocations[iAllelePeakIndex] = iMaxPeak;
<a name="l01919"></a>01919                 }
<a name="l01920"></a>01920             }
<a name="l01921"></a>01921 
<a name="l01922"></a>01922             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iPeakCount; i++) {
<a name="l01923"></a>01923                 peaks[winInd].push_back(vPeakLocations[i]);
<a name="l01924"></a>01924             }
<a name="l01925"></a>01925         }
<a name="l01926"></a>01926         <a class="code" href="classCNAnalysisMethod.html#ae4bf7eeb934b7da4f8e9b3a105422be9" title="For each probe set store maximum number of peaks over all windows containing this probe set...">findMaxPeaks</a>(probeSets, windowBds, peaks);
<a name="l01927"></a>01927 
<a name="l01928"></a>01928         <span class="keywordtype">int</span> chrStart = m_chrBounds[chromosomes[chrInd]].first;
<a name="l01929"></a>01929         <span class="keywordtype">int</span> chrEnd   = m_chrBounds[chromosomes[chrInd]].second - 1;
<a name="l01930"></a>01930         <span class="keywordtype">float</span> cutoff3 = m_vThreePeakFLD_Y[cutoffIndFLD3];
<a name="l01931"></a>01931         <span class="keywordtype">float</span> cutoff4 = m_vFourPeakFLD_Y[cutoffIndFLD4];
<a name="l01932"></a>01932 
<a name="l01933"></a>01933         filterCutOff(probeSets, chrStart, chrEnd, cutoff3, cutoff4, filteredProbeSets);
<a name="l01934"></a>01934         filterNoMansLand(probeSets, filteredProbeSets, stepWindowBds, peaks);
<a name="l01935"></a>01935         filterShrinkTowardPeaks(
<a name="l01936"></a>01936                         probeSets,
<a name="l01937"></a>01937                         filteredProbeSets,
<a name="l01938"></a>01938                         stepWindowBds,
<a name="l01939"></a>01939                         peaks,
<a name="l01940"></a>01940                         m_vThreePeakShrink_Y[cutoffIndShrink3],
<a name="l01941"></a>01941                         m_vFourPeakShrink_Y[cutoffIndShrink4],
<a name="l01942"></a>01942                         closestPeak,
<a name="l01943"></a>01943                         processedValues,
<a name="l01944"></a>01944                         saveAllelePeaksFlag
<a name="l01945"></a>01945                         );
<a name="l01946"></a>01946 
<a name="l01947"></a>01947         <span class="keywordflow">if</span> (keepIntermediateData) {
<a name="l01948"></a>01948             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> winInd = 0; winInd &lt; windowBds.size(); winInd++) {
<a name="l01949"></a>01949                 peakWindows.push_back(make_pair(windowBds[winInd].first, windowBds[winInd].second));
<a name="l01950"></a>01950                 stepWindows.push_back(make_pair(stepWindowBds[winInd].first, stepWindowBds[winInd].second));
<a name="l01951"></a>01951 
<a name="l01952"></a>01952                 pair&lt;int, int&gt; window = make_pair(windowBds[winInd].first, windowBds[winInd].second);
<a name="l01953"></a>01953                 peakSets.push_back(make_pair(window, peaks[winInd]));
<a name="l01954"></a>01954             }
<a name="l01955"></a>01955         }
<a name="l01956"></a>01956     }
<a name="l01957"></a>01957 
<a name="l01958"></a>01958     <span class="keywordflow">if</span> (keepIntermediateData) {
<a name="l01959"></a>01959                         writeIntermediateData(
<a name="l01960"></a>01960                                             probeSets,
<a name="l01961"></a>01961                                             filteredProbeSets,
<a name="l01962"></a>01962                                             peakWindows,
<a name="l01963"></a>01963                                             stepWindows,
<a name="l01964"></a>01964                                             closestPeak,
<a name="l01965"></a>01965                                             peakSets,
<a name="l01966"></a>01966                                             processedValues,
<a name="l01967"></a>01967                                             apParametersValues,
<a name="l01968"></a>01968                                             cutoffShrinkageValues
<a name="l01969"></a>01969                         );
<a name="l01970"></a>01970     }
<a name="l01971"></a>01971 }
<a name="l01972"></a>01972 
<a name="l01973"></a>01973 <span class="keywordtype">void</span> CNAnalysisMethod::writeIntermediateData(
<a name="l01974"></a>01974                                         <a class="code" href="classCNProbeSetArray.html" title="A vector of ProbeSet Pointers.">CNProbeSetArray</a>* probeSets,
<a name="l01975"></a>01975                                         <span class="keyword">const</span> vector&lt;bool&gt;&amp; filteredProbeSets,
<a name="l01976"></a>01976                                         <span class="keyword">const</span> vector&lt;pair&lt;int, int&gt; &gt;&amp; peakWindows,
<a name="l01977"></a>01977                                         <span class="keyword">const</span> vector&lt;pair&lt;int, int&gt; &gt;&amp; stepWindows,
<a name="l01978"></a>01978                                         <span class="keyword">const</span> vector&lt;pair&lt;int, double&gt; &gt;&amp; closestPeak,
<a name="l01979"></a>01979                                         <span class="keyword">const</span> vector&lt;pair&lt;pair&lt;int, int&gt;, vector&lt;double&gt; &gt; &gt;&amp; peakSets,
<a name="l01980"></a>01980                                         <span class="keyword">const</span> vector&lt;pair&lt;int, double&gt; &gt;&amp; processedValues,
<a name="l01981"></a>01981                                         <span class="keyword">const</span> apParameters&amp; apParametersValues,
<a name="l01982"></a>01982                                         <span class="keyword">const</span> cutoffShrinkage&amp; cutoffShrinkageValues
<a name="l01983"></a>01983                                         )
<a name="l01984"></a>01984 {
<a name="l01985"></a>01985     <span class="keyword">const</span> <span class="keywordtype">string</span> covarPrefix = <span class="stringliteral">&quot;.crude&quot;</span>;   <span class="comment">// for &quot;crude allele peaks&quot;</span>
<a name="l01986"></a>01986 
<a name="l01987"></a>01987     <span class="comment">// insert covariate index into the file name if the index is valid</span>
<a name="l01988"></a>01988     <span class="keyword">const</span> <span class="keywordtype">bool</span> useCovariateInFileName = apParametersValues.covariateIndex &gt;= 0;
<a name="l01989"></a>01989 
<a name="l01990"></a>01990     <a class="code" href="classaffx_1_1File5__File.html">affx::File5_File</a> file5;
<a name="l01991"></a>01991     <a class="code" href="classaffx_1_1File5__Group.html">affx::File5_Group</a>* group5;
<a name="l01992"></a>01992     <a class="code" href="classaffx_1_1File5__Tsv.html">affx::File5_Tsv</a>* tsv5 = NULL;
<a name="l01993"></a>01993 
<a name="l01994"></a>01994     std::string analysisString = <span class="stringliteral">&quot;analysis&quot;</span>;
<a name="l01995"></a>01995     std::string strExperimentName = getExperiment()-&gt;getExperimentName();
<a name="l01996"></a>01996     std::string fileName;
<a name="l01997"></a>01997     <span class="keywordflow">if</span> (useCovariateInFileName)
<a name="l01998"></a>01998     {
<a name="l01999"></a>01999         std::string covariateStr = <span class="stringliteral">&quot;.covar&quot;</span> + <a class="code" href="classConvert.html#ab3aa97a2e8dbdd6fae18517ff287d812" title="Make a string from an integer.">Convert::toString</a>(apParametersValues.covariateIndex);
<a name="l02000"></a>02000         fileName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>), analysisString,
<a name="l02001"></a>02001                                         strExperimentName + covariateStr + covarPrefix + <span class="stringliteral">&quot;.allelepeaks.a5&quot;</span>);
<a name="l02002"></a>02002     }
<a name="l02003"></a>02003     <span class="keywordflow">else</span> {
<a name="l02004"></a>02004         fileName = <a class="code" href="classFs.html#af44351abee4cbc47f94b83cb2f62899f" title="join strings with the path sep. /// while we would want people to keep the path with FsPath...">Fs::join</a>(getEngine()-&gt;getOpt(<span class="stringliteral">&quot;out-dir&quot;</span>), analysisString,
<a name="l02005"></a>02005                                         strExperimentName + <span class="stringliteral">&quot;.allelepeaks.a5&quot;</span>);
<a name="l02006"></a>02006     }
<a name="l02007"></a>02007 
<a name="l02008"></a>02008     <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(3, <span class="stringliteral">&quot;Writing intermediate data for &quot;</span> + fileName);
<a name="l02009"></a>02009 
<a name="l02010"></a>02010     <span class="keywordflow">try</span> {
<a name="l02011"></a>02011         file5.open(fileName, affx::FILE5_CREATE | affx::FILE5_REPLACE);
<a name="l02012"></a>02012         group5 = file5.openGroup(<span class="stringliteral">&quot;AllelePeaks&quot;</span>, affx::FILE5_REPLACE);
<a name="l02013"></a>02013 
<a name="l02014"></a>02014         tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;AllelePeaks&quot;</span>, affx::FILE5_REPLACE);
<a name="l02015"></a>02015         tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;ProbeSetName&quot;</span>, affx::FILE5_DTYPE_STRING, 20);
<a name="l02016"></a>02016         tsv5-&gt;defineColumn(0, 1, <span class="stringliteral">&quot;Chromosome&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02017"></a>02017         tsv5-&gt;defineColumn(0, 2, <span class="stringliteral">&quot;Position&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02018"></a>02018         <span class="keywordflow">if</span> (useCovariateInFileName)
<a name="l02019"></a>02019         {
<a name="l02020"></a>02020             tsv5-&gt;defineColumn(0, 3, <span class="stringliteral">&quot;AllelePeak&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02021"></a>02021         }
<a name="l02022"></a>02022         <span class="keywordflow">else</span> {
<a name="l02023"></a>02023             tsv5-&gt;defineColumn(0, 3, <span class="stringliteral">&quot;AllelePeaks0&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02024"></a>02024             tsv5-&gt;defineColumn(0, 4, <span class="stringliteral">&quot;AllelePeaks1&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02025"></a>02025         }
<a name="l02026"></a>02026 
<a name="l02027"></a>02027         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; probeSets-&gt;getCount(); i++) {
<a name="l02028"></a>02028             <span class="keywordflow">if</span> (filteredProbeSets[i]) {
<a name="l02029"></a>02029                 tsv5-&gt;set_string(0, 0, probeSets-&gt;getAt(i)-&gt;getProbeSetName());
<a name="l02030"></a>02030                 tsv5-&gt;set_i(0, 1, probeSets-&gt;getAt(i)-&gt;getChromosome());
<a name="l02031"></a>02031                 tsv5-&gt;set_i(0, 2, probeSets-&gt;getAt(i)-&gt;getPosition());
<a name="l02032"></a>02032                 <span class="keywordflow">if</span> (useCovariateInFileName)
<a name="l02033"></a>02033                 {
<a name="l02034"></a>02034                     tsv5-&gt;set_d(0, 3, m_vCoarseAllelePeaks[i]);
<a name="l02035"></a>02035                 }
<a name="l02036"></a>02036                 <span class="keywordflow">else</span> {
<a name="l02037"></a>02037                     tsv5-&gt;set_i(0, 3, probeSets-&gt;getAt(i)-&gt;getAllelePeaks1());
<a name="l02038"></a>02038                     tsv5-&gt;set_i(0, 4, probeSets-&gt;getAt(i)-&gt;getAllelePeaks2());
<a name="l02039"></a>02039                 }
<a name="l02040"></a>02040                 tsv5-&gt;writeLevel(0);
<a name="l02041"></a>02041             }
<a name="l02042"></a>02042         }
<a name="l02043"></a>02043         tsv5-&gt;close();
<a name="l02044"></a>02044         <span class="keyword">delete</span> tsv5;
<a name="l02045"></a>02045 
<a name="l02046"></a>02046         tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;PeakWindows&quot;</span>, affx::FILE5_REPLACE);
<a name="l02047"></a>02047         tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;StartProbesetID&quot;</span>, affx::FILE5_DTYPE_STRING, 20);
<a name="l02048"></a>02048         tsv5-&gt;defineColumn(0, 1, <span class="stringliteral">&quot;StartChromosome&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02049"></a>02049         tsv5-&gt;defineColumn(0, 2, <span class="stringliteral">&quot;StartPosition&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02050"></a>02050         tsv5-&gt;defineColumn(0, 3, <span class="stringliteral">&quot;EndProbesetID&quot;</span>, affx::FILE5_DTYPE_STRING, 20);
<a name="l02051"></a>02051         tsv5-&gt;defineColumn(0, 4, <span class="stringliteral">&quot;EndChromosome&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02052"></a>02052         tsv5-&gt;defineColumn(0, 5, <span class="stringliteral">&quot;EndPosition&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02053"></a>02053 
<a name="l02054"></a>02054         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; peakWindows.size(); i++) {
<a name="l02055"></a>02055             <span class="keywordtype">int</span> startInd = peakWindows[i].first;
<a name="l02056"></a>02056             <span class="keywordtype">int</span> endInd   = peakWindows[i].second;
<a name="l02057"></a>02057             tsv5-&gt;set_string(0, 0, probeSets-&gt;getAt(startInd)-&gt;getProbeSetName());
<a name="l02058"></a>02058             tsv5-&gt;set_i(0, 1, probeSets-&gt;getAt(startInd)-&gt;getChromosome());
<a name="l02059"></a>02059             tsv5-&gt;set_i(0, 2, probeSets-&gt;getAt(startInd)-&gt;getPosition());
<a name="l02060"></a>02060             tsv5-&gt;set_string(0, 3, probeSets-&gt;getAt(endInd)-&gt;getProbeSetName());
<a name="l02061"></a>02061             tsv5-&gt;set_i(0, 4, probeSets-&gt;getAt(endInd)-&gt;getChromosome());
<a name="l02062"></a>02062             tsv5-&gt;set_i(0, 5, probeSets-&gt;getAt(endInd)-&gt;getPosition());
<a name="l02063"></a>02063             tsv5-&gt;writeLevel(0);
<a name="l02064"></a>02064         }
<a name="l02065"></a>02065         tsv5-&gt;close();
<a name="l02066"></a>02066         <span class="keyword">delete</span> tsv5;
<a name="l02067"></a>02067 
<a name="l02068"></a>02068         tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;StepWindows&quot;</span>, affx::FILE5_REPLACE);
<a name="l02069"></a>02069         tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;StartProbesetID&quot;</span>, affx::FILE5_DTYPE_STRING, 20);
<a name="l02070"></a>02070         tsv5-&gt;defineColumn(0, 1, <span class="stringliteral">&quot;StartChromosome&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02071"></a>02071         tsv5-&gt;defineColumn(0, 2, <span class="stringliteral">&quot;StartPosition&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02072"></a>02072         tsv5-&gt;defineColumn(0, 3, <span class="stringliteral">&quot;EndProbesetID&quot;</span>, affx::FILE5_DTYPE_STRING, 20);
<a name="l02073"></a>02073         tsv5-&gt;defineColumn(0, 4, <span class="stringliteral">&quot;EndChromosome&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02074"></a>02074         tsv5-&gt;defineColumn(0, 5, <span class="stringliteral">&quot;EndPosition&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02075"></a>02075 
<a name="l02076"></a>02076         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; stepWindows.size(); i++) {
<a name="l02077"></a>02077             <span class="keywordtype">int</span> startInd = stepWindows[i].first;
<a name="l02078"></a>02078             <span class="keywordtype">int</span> endInd   = stepWindows[i].second;
<a name="l02079"></a>02079             tsv5-&gt;set_string(0, 0, probeSets-&gt;getAt(startInd)-&gt;getProbeSetName());
<a name="l02080"></a>02080             tsv5-&gt;set_i(0, 1, probeSets-&gt;getAt(startInd)-&gt;getChromosome());
<a name="l02081"></a>02081             tsv5-&gt;set_i(0, 2, probeSets-&gt;getAt(startInd)-&gt;getPosition());
<a name="l02082"></a>02082             tsv5-&gt;set_string(0, 3, probeSets-&gt;getAt(endInd)-&gt;getProbeSetName());
<a name="l02083"></a>02083             tsv5-&gt;set_i(0, 4, probeSets-&gt;getAt(endInd)-&gt;getChromosome());
<a name="l02084"></a>02084             tsv5-&gt;set_i(0, 5, probeSets-&gt;getAt(endInd)-&gt;getPosition());
<a name="l02085"></a>02085             tsv5-&gt;writeLevel(0);
<a name="l02086"></a>02086         }
<a name="l02087"></a>02087         tsv5-&gt;close();
<a name="l02088"></a>02088         <span class="keyword">delete</span> tsv5;
<a name="l02089"></a>02089 
<a name="l02090"></a>02090         tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;ClosestPeak&quot;</span>, affx::FILE5_REPLACE);
<a name="l02091"></a>02091         tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;ProbesetID&quot;</span>, affx::FILE5_DTYPE_STRING, 20);
<a name="l02092"></a>02092         tsv5-&gt;defineColumn(0, 1, <span class="stringliteral">&quot;Chromosome&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02093"></a>02093         tsv5-&gt;defineColumn(0, 2, <span class="stringliteral">&quot;Position&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02094"></a>02094         tsv5-&gt;defineColumn(0, 3, <span class="stringliteral">&quot;ClosestPeak&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02095"></a>02095 
<a name="l02096"></a>02096         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; closestPeak.size(); i++) {
<a name="l02097"></a>02097             <span class="keywordtype">int</span> index = closestPeak[i].first;
<a name="l02098"></a>02098             tsv5-&gt;set_string(0, 0, probeSets-&gt;getAt(index)-&gt;getProbeSetName());
<a name="l02099"></a>02099             tsv5-&gt;set_i(0, 1, probeSets-&gt;getAt(index)-&gt;getChromosome());
<a name="l02100"></a>02100             tsv5-&gt;set_i(0, 2, probeSets-&gt;getAt(index)-&gt;getPosition());
<a name="l02101"></a>02101             tsv5-&gt;set_d(0, 3, closestPeak[i].second);
<a name="l02102"></a>02102             tsv5-&gt;writeLevel(0);
<a name="l02103"></a>02103         }
<a name="l02104"></a>02104         tsv5-&gt;close();
<a name="l02105"></a>02105         <span class="keyword">delete</span> tsv5;
<a name="l02106"></a>02106 
<a name="l02107"></a>02107         tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;CutoffShrinkages&quot;</span>, affx::FILE5_REPLACE);
<a name="l02108"></a>02108         tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;FLD3Threshold&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02109"></a>02109         tsv5-&gt;defineColumn(0, 1, <span class="stringliteral">&quot;FLD4Threshold&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02110"></a>02110         tsv5-&gt;defineColumn(0, 2, <span class="stringliteral">&quot;Shrinkage3&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02111"></a>02111         tsv5-&gt;defineColumn(0, 3, <span class="stringliteral">&quot;Shrinkage4&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02112"></a>02112         tsv5-&gt;defineColumn(0, 4, <span class="stringliteral">&quot;SNPQC&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02113"></a>02113 
<a name="l02114"></a>02114         tsv5-&gt;set_d(0, 0, cutoffShrinkageValues.FLD3threshold);
<a name="l02115"></a>02115         tsv5-&gt;set_d(0, 1, cutoffShrinkageValues.FLD4threshold);
<a name="l02116"></a>02116         tsv5-&gt;set_d(0, 2, cutoffShrinkageValues.shrinkage3);
<a name="l02117"></a>02117         tsv5-&gt;set_d(0, 3, cutoffShrinkageValues.shrinkage4);
<a name="l02118"></a>02118         tsv5-&gt;set_d(0, 4, cutoffShrinkageValues.SNPQC);
<a name="l02119"></a>02119         tsv5-&gt;writeLevel(0);
<a name="l02120"></a>02120 
<a name="l02121"></a>02121         tsv5-&gt;close();
<a name="l02122"></a>02122         <span class="keyword">delete</span> tsv5;
<a name="l02123"></a>02123 
<a name="l02124"></a>02124         tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;MaxPeak&quot;</span>, affx::FILE5_REPLACE);
<a name="l02125"></a>02125         tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;ProbesetID&quot;</span>, affx::FILE5_DTYPE_STRING, 20);
<a name="l02126"></a>02126         tsv5-&gt;defineColumn(0, 1, <span class="stringliteral">&quot;Chromosome&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02127"></a>02127         tsv5-&gt;defineColumn(0, 2, <span class="stringliteral">&quot;Position&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02128"></a>02128         tsv5-&gt;defineColumn(0, 3, <span class="stringliteral">&quot;MaxPeak&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02129"></a>02129 
<a name="l02130"></a>02130         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; probeSets-&gt;getCount(); i++) {
<a name="l02131"></a>02131             tsv5-&gt;set_string(0, 0, probeSets-&gt;getAt(i)-&gt;getProbeSetName());
<a name="l02132"></a>02132             tsv5-&gt;set_i(0, 1, probeSets-&gt;getAt(i)-&gt;getChromosome());
<a name="l02133"></a>02133             tsv5-&gt;set_i(0, 2, probeSets-&gt;getAt(i)-&gt;getPosition());
<a name="l02134"></a>02134             tsv5-&gt;set_i(0, 3, probeSets-&gt;getAt(i)-&gt;getMaxPeaks());
<a name="l02135"></a>02135             tsv5-&gt;writeLevel(0);
<a name="l02136"></a>02136         }
<a name="l02137"></a>02137         tsv5-&gt;close();
<a name="l02138"></a>02138         <span class="keyword">delete</span> tsv5;
<a name="l02139"></a>02139 
<a name="l02140"></a>02140         tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;Parameters&quot;</span>, affx::FILE5_REPLACE);
<a name="l02141"></a>02141         tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;Window&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02142"></a>02142         tsv5-&gt;defineColumn(0, 1, <span class="stringliteral">&quot;Step&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02143"></a>02143         tsv5-&gt;defineColumn(0, 2, <span class="stringliteral">&quot;BandwidthFactor&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02144"></a>02144         tsv5-&gt;defineColumn(0, 3, <span class="stringliteral">&quot;DensityPointCount&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02145"></a>02145         tsv5-&gt;defineColumn(0, 4, <span class="stringliteral">&quot;PeaksCutoff&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02146"></a>02146         tsv5-&gt;defineColumn(0, 5, <span class="stringliteral">&quot;CleanThreshold&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02147"></a>02147         tsv5-&gt;defineColumn(0, 6, <span class="stringliteral">&quot;Symmetry&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02148"></a>02148 
<a name="l02149"></a>02149         tsv5-&gt;set_i(0, 0, apParametersValues.window);
<a name="l02150"></a>02150         tsv5-&gt;set_i(0, 1, apParametersValues.step);
<a name="l02151"></a>02151         tsv5-&gt;set_d(0, 2, apParametersValues.bandwidthFactor);
<a name="l02152"></a>02152         tsv5-&gt;set_i(0, 3, apParametersValues.densityPointCount);
<a name="l02153"></a>02153         tsv5-&gt;set_d(0, 4, apParametersValues.peaksCutoff);
<a name="l02154"></a>02154         tsv5-&gt;set_d(0, 5, apParametersValues.cleanThreshold);
<a name="l02155"></a>02155         <span class="keywordtype">int</span> sFlag = apParametersValues.symmetry ? 1 : 0;
<a name="l02156"></a>02156         tsv5-&gt;set_i(0, 6, sFlag);
<a name="l02157"></a>02157         tsv5-&gt;writeLevel(0);
<a name="l02158"></a>02158 
<a name="l02159"></a>02159         tsv5-&gt;close();
<a name="l02160"></a>02160         <span class="keyword">delete</span> tsv5;
<a name="l02161"></a>02161 
<a name="l02162"></a>02162         tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;PeakSets&quot;</span>, affx::FILE5_REPLACE);
<a name="l02163"></a>02163         tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;StartProbesetID&quot;</span>, affx::FILE5_DTYPE_STRING, 20);
<a name="l02164"></a>02164         tsv5-&gt;defineColumn(0, 1, <span class="stringliteral">&quot;StartChromosome&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02165"></a>02165         tsv5-&gt;defineColumn(0, 2, <span class="stringliteral">&quot;StartPosition&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02166"></a>02166         tsv5-&gt;defineColumn(0, 3, <span class="stringliteral">&quot;EndProbesetID&quot;</span>, affx::FILE5_DTYPE_STRING, 20);
<a name="l02167"></a>02167         tsv5-&gt;defineColumn(0, 4, <span class="stringliteral">&quot;EndChromosome&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02168"></a>02168         tsv5-&gt;defineColumn(0, 5, <span class="stringliteral">&quot;EndPosition&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02169"></a>02169         tsv5-&gt;defineColumn(0, 6, <span class="stringliteral">&quot;Peak1&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02170"></a>02170         tsv5-&gt;defineColumn(0, 7, <span class="stringliteral">&quot;Peak2&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02171"></a>02171         tsv5-&gt;defineColumn(0, 8, <span class="stringliteral">&quot;Peak3&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02172"></a>02172         tsv5-&gt;defineColumn(0, 9, <span class="stringliteral">&quot;Peak4&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02173"></a>02173         tsv5-&gt;defineColumn(0, 10, <span class="stringliteral">&quot;Peak5&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02174"></a>02174         tsv5-&gt;defineColumn(0, 11, <span class="stringliteral">&quot;Peak6&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02175"></a>02175 
<a name="l02176"></a>02176         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; peakSets.size(); j++) {
<a name="l02177"></a>02177             <span class="keywordtype">int</span> startInd = peakSets[j].first.first;
<a name="l02178"></a>02178             <span class="keywordtype">int</span> endInd   = peakSets[j].first.second;
<a name="l02179"></a>02179             tsv5-&gt;set_string(0, 0, probeSets-&gt;getAt(startInd)-&gt;getProbeSetName());
<a name="l02180"></a>02180             tsv5-&gt;set_i(0, 1, probeSets-&gt;getAt(startInd)-&gt;getChromosome());
<a name="l02181"></a>02181             tsv5-&gt;set_i(0, 2, probeSets-&gt;getAt(startInd)-&gt;getPosition());
<a name="l02182"></a>02182             tsv5-&gt;set_string(0, 3, probeSets-&gt;getAt(endInd)-&gt;getProbeSetName());
<a name="l02183"></a>02183             tsv5-&gt;set_i(0, 4, probeSets-&gt;getAt(endInd)-&gt;getChromosome());
<a name="l02184"></a>02184             tsv5-&gt;set_i(0, 5, probeSets-&gt;getAt(endInd)-&gt;getPosition());
<a name="l02185"></a>02185 
<a name="l02186"></a>02186             <span class="keywordtype">int</span> peakInd;
<a name="l02187"></a>02187             <span class="keywordflow">for</span> (peakInd = 0; peakInd &lt; peakSets[j].second.size(); peakInd++) {
<a name="l02188"></a>02188                 tsv5-&gt;set_d(0, 6 + peakInd, peakSets[j].second[peakInd]);
<a name="l02189"></a>02189             }
<a name="l02190"></a>02190             <span class="keywordflow">for</span> ( ; peakInd &lt; 6; peakInd++) {
<a name="l02191"></a>02191                 tsv5-&gt;set_d(0, 6 + peakInd, numeric_limits&lt;double&gt;::quiet_NaN());
<a name="l02192"></a>02192             }
<a name="l02193"></a>02193             tsv5-&gt;writeLevel(0);
<a name="l02194"></a>02194         }
<a name="l02195"></a>02195         tsv5-&gt;close();
<a name="l02196"></a>02196         <span class="keyword">delete</span> tsv5;
<a name="l02197"></a>02197 
<a name="l02198"></a>02198         tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;ProcessedValues&quot;</span>, affx::FILE5_REPLACE);
<a name="l02199"></a>02199         tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;ProbesetID&quot;</span>, affx::FILE5_DTYPE_STRING, 20);
<a name="l02200"></a>02200         tsv5-&gt;defineColumn(0, 1, <span class="stringliteral">&quot;Chromosome&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02201"></a>02201         tsv5-&gt;defineColumn(0, 2, <span class="stringliteral">&quot;Position&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02202"></a>02202         tsv5-&gt;defineColumn(0, 3, <span class="stringliteral">&quot;Value&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02203"></a>02203 
<a name="l02204"></a>02204         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; processedValues.size(); i++) {
<a name="l02205"></a>02205             <span class="keywordtype">int</span> index = processedValues[i].first;
<a name="l02206"></a>02206             tsv5-&gt;set_string(0, 0, probeSets-&gt;getAt(index)-&gt;getProbeSetName());
<a name="l02207"></a>02207             tsv5-&gt;set_i(0, 1, probeSets-&gt;getAt(index)-&gt;getChromosome());
<a name="l02208"></a>02208             tsv5-&gt;set_i(0, 2, probeSets-&gt;getAt(index)-&gt;getPosition());
<a name="l02209"></a>02209             tsv5-&gt;set_d(0, 3, processedValues[i].second);
<a name="l02210"></a>02210             tsv5-&gt;writeLevel(0);
<a name="l02211"></a>02211         }
<a name="l02212"></a>02212         tsv5-&gt;close();
<a name="l02213"></a>02213         <span class="keyword">delete</span> tsv5;
<a name="l02214"></a>02214 
<a name="l02215"></a>02215         tsv5 = group5-&gt;openTsv(<span class="stringliteral">&quot;SCARs&quot;</span>, affx::FILE5_REPLACE);
<a name="l02216"></a>02216         tsv5-&gt;defineColumn(0, 0, <span class="stringliteral">&quot;ProbesetID&quot;</span>, affx::FILE5_DTYPE_STRING, 20);
<a name="l02217"></a>02217         tsv5-&gt;defineColumn(0, 1, <span class="stringliteral">&quot;Chromosome&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02218"></a>02218         tsv5-&gt;defineColumn(0, 2, <span class="stringliteral">&quot;Position&quot;</span>, affx::FILE5_DTYPE_INT);
<a name="l02219"></a>02219         tsv5-&gt;defineColumn(0, 3, <span class="stringliteral">&quot;SCAR&quot;</span>, affx::FILE5_DTYPE_DOUBLE);
<a name="l02220"></a>02220 
<a name="l02221"></a>02221         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; probeSets-&gt;getCount(); i++) {
<a name="l02222"></a>02222             tsv5-&gt;set_string(0, 0, probeSets-&gt;getAt(i)-&gt;getProbeSetName());
<a name="l02223"></a>02223             tsv5-&gt;set_i(0, 1, probeSets-&gt;getAt(i)-&gt;getChromosome());
<a name="l02224"></a>02224             tsv5-&gt;set_i(0, 2, probeSets-&gt;getAt(i)-&gt;getPosition());
<a name="l02225"></a>02225             tsv5-&gt;set_d(0, 3, probeSets-&gt;getAt(i)-&gt;getSCAR());
<a name="l02226"></a>02226             tsv5-&gt;writeLevel(0);
<a name="l02227"></a>02227         }
<a name="l02228"></a>02228         tsv5-&gt;close();
<a name="l02229"></a>02229         <span class="keyword">delete</span> tsv5;
<a name="l02230"></a>02230 
<a name="l02231"></a>02231         <span class="keyword">delete</span> group5;
<a name="l02232"></a>02232         file5.close();
<a name="l02233"></a>02233     }
<a name="l02234"></a>02234     <span class="keywordflow">catch</span>(...){ <span class="keywordflow">throw</span>(<a class="code" href="classExcept.html" title="General purpose exception error for error handling.">Except</a>(<span class="stringliteral">&quot;Cannot open file &quot;</span> + fileName + <span class="stringliteral">&quot; while attempting to dump allele peaks data to file.&quot;</span>));}
<a name="l02235"></a>02235 }
<a name="l02236"></a>02236 
<a name="l02237"></a>02237 
<a name="l02238"></a>02238 
<a name="l02239"></a>02239 
<a name="l02240"></a>02240 <span class="keywordtype">double</span> CNAnalysisMethod::assignConfidenceSigmoidal(     <span class="keywordtype">int</span> iHetsInSegment,
<a name="l02241"></a>02241                                                         <span class="keywordtype">int</span> iNumberInSegment,
<a name="l02242"></a>02242                                                         <span class="keywordtype">double</span> dHetRate,
<a name="l02243"></a>02243                                                         <span class="keywordtype">double</span> dPError,
<a name="l02244"></a>02244                                                         <span class="keywordtype">int</span> iShift,
<a name="l02245"></a>02245                                                         <span class="keywordtype">int</span> iMinSegmentSize)
<a name="l02246"></a>02246 {
<a name="l02247"></a>02247 
<a name="l02248"></a>02248 
<a name="l02249"></a>02249     <span class="keywordflow">if</span>(iNumberInSegment &lt; iMinSegmentSize)
<a name="l02250"></a>02250     {
<a name="l02251"></a>02251         <span class="keywordflow">return</span> 0.0;
<a name="l02252"></a>02252     }
<a name="l02253"></a>02253     <span class="keywordflow">else</span>
<a name="l02254"></a>02254     {
<a name="l02255"></a>02255         <span class="keywordtype">double</span> dScaleMin = 1.0/(exp(shiftValue(0.0, iShift)) + 1);
<a name="l02256"></a>02256         <span class="keywordtype">double</span> dScaleMax = 1.0/(exp(shiftValue(1.0, iShift)) + 1);
<a name="l02257"></a>02257 
<a name="l02258"></a>02258         <span class="keywordtype">double</span> dLinearValue = max(min(1.0,( 1.0-( (((<span class="keywordtype">double</span>)iHetsInSegment/(<span class="keywordtype">double</span>)iNumberInSegment) - dPError) / (dHetRate- dPError) )) ),0.0);
<a name="l02259"></a>02259 
<a name="l02260"></a>02260         <span class="keywordtype">double</span> dTempValue1 =  1.0/(exp( shiftValue(dLinearValue, iShift) ) + 1.0) ;
<a name="l02261"></a>02261         <span class="keywordtype">double</span> dTempValue2 = dTempValue1 - dScaleMin;
<a name="l02262"></a>02262         <span class="keywordtype">double</span> dTempValue3 = dTempValue2 * ( 1.0/ (dScaleMax -dScaleMin) );
<a name="l02263"></a>02263 
<a name="l02264"></a>02264         <span class="keywordflow">return</span> dTempValue3;
<a name="l02265"></a>02265 
<a name="l02266"></a>02266     }
<a name="l02267"></a>02267 }
<a name="l02268"></a>02268 
<a name="l02269"></a>02269 
<a name="l02270"></a>02270 
<a name="l02271"></a>02271 <span class="keywordtype">double</span> CNAnalysisMethod::shiftValue(    <span class="keywordtype">double</span> ecks,
<a name="l02272"></a>02272                                         <span class="keywordtype">int</span> iShift)
<a name="l02273"></a>02273 {
<a name="l02274"></a>02274     <span class="keywordtype">double</span> dValue=0.0;
<a name="l02275"></a>02275     dValue = 10 - (ecks*20) + iShift;
<a name="l02276"></a>02276     <span class="keywordflow">return</span> dValue;
<a name="l02277"></a>02277 }
<a name="l02278"></a>02278 
<a name="l02279"></a>02279 <span class="keywordtype">float</span> CNAnalysisMethod::getConfidenceThreshold(<span class="keyword">const</span> std::string&amp; brlmmpStr)
<a name="l02280"></a>02280 {
<a name="l02281"></a>02281     <span class="keyword">const</span> <span class="keywordtype">float</span> defaultConfThreshold = 0.05;   <span class="comment">// JPB perhaps this should go somewhere else</span>
<a name="l02282"></a>02282 
<a name="l02283"></a>02283     <span class="keywordflow">if</span> (brlmmpStr.empty()) {
<a name="l02284"></a>02284         <span class="keywordflow">return</span> defaultConfThreshold;
<a name="l02285"></a>02285     }
<a name="l02286"></a>02286     <span class="keywordtype">string</span> name;
<a name="l02287"></a>02287     map&lt;string, string&gt; param;
<a name="l02288"></a>02288     <a class="code" href="classSelfCreate.html#afb6e01b234ac33a843cd92cd192e30de" title="Take a string of from &amp;quot;name.param1=value1.param2=value2&amp;quot; and populate the name and paramMap...">SelfCreate::fillInNameParam</a>(brlmmpStr, name, param);
<a name="l02289"></a>02289     map&lt;string, string&gt;::iterator iter;
<a name="l02290"></a>02290     <span class="keywordflow">if</span> ((iter = param.find(<span class="stringliteral">&quot;MS&quot;</span>)) != param.end()) {
<a name="l02291"></a>02291         <span class="keywordflow">return</span> <a class="code" href="AffxConv_8cpp.html#a4e40c31006c5b45e47ea0240921b98b2" title="Converts a string with commas into a double.">getDouble</a>(iter-&gt;second);
<a name="l02292"></a>02292     }
<a name="l02293"></a>02293 
<a name="l02294"></a>02294     <span class="keywordflow">return</span> defaultConfThreshold;
<a name="l02295"></a>02295 }
<a name="l02296"></a>02296 
<a name="l02297"></a>02297 <span class="keywordtype">void</span> CNAnalysisMethod::resetAllelePeakInitialValues()
<a name="l02298"></a>02298 {
<a name="l02299"></a>02299     <span class="keywordtype">int</span> iNumberOfProbeSets=CNAnalysisMethod::getProbeSets()-&gt;getCount();
<a name="l02300"></a>02300     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex&lt;iNumberOfProbeSets; iIndex++)
<a name="l02301"></a>02301     {
<a name="l02302"></a>02302         CNAnalysisMethod::getProbeSets()-&gt;getAt(iIndex)-&gt;setAllelePeaks1(0);
<a name="l02303"></a>02303         CNAnalysisMethod::getProbeSets()-&gt;getAt(iIndex)-&gt;setAllelePeaks2(0);
<a name="l02304"></a>02304     }
<a name="l02305"></a>02305 }
<a name="l02306"></a>02306 
<a name="l02307"></a>02307 
<a name="l02308"></a>02308 <span class="comment">// Fit density curve to specified values[] and weights[] using Gaussian kernel</span>
<a name="l02309"></a>02309 <span class="comment">// with specified bandwidth.</span>
<a name="l02310"></a>02310 <span class="comment">//</span>
<a name="l02311"></a>02311 <span class="comment">// Rather than calculating the density curve directly (which is a time-consuming</span>
<a name="l02312"></a>02312 <span class="comment">// operation) the function uses a known fact that the density curve formula</span>
<a name="l02313"></a>02313 <span class="comment">// happens to be equal to the Fourier transform of an easily computed expression</span>
<a name="l02314"></a>02314 <span class="comment">// involving the given input data. This speeds things up considerably thanks to</span>
<a name="l02315"></a>02315 <span class="comment">// the FFT.</span>
<a name="l02316"></a>02316 <span class="comment">//</span>
<a name="l02317"></a>02317 <span class="comment">// Input:</span>
<a name="l02318"></a>02318 <span class="comment">//      values - sample data to fit density curve to,</span>
<a name="l02319"></a>02319 <span class="comment">//      weights - their multiplicities (must sum up to 1),</span>
<a name="l02320"></a>02320 <span class="comment">//      numPoints - number of points to evaluate the density at,</span>
<a name="l02321"></a>02321 <span class="comment">//      bandwidth - bandwidth of the (Gaussian) kernel,</span>
<a name="l02322"></a>02322 <span class="comment">//      symmetry - whether to symmetrise the data:</span>
<a name="l02323"></a>02323 <span class="comment">//               = true, means symmetrise,</span>
<a name="l02324"></a>02324 <span class="comment">//               = false, means leave the data as is.</span>
<a name="l02325"></a>02325 <span class="comment">// Output:</span>
<a name="l02326"></a>02326 <span class="comment">//      xi - the domain coordinates of the density curve,</span>
<a name="l02327"></a>02327 <span class="comment">//      density - corresponding values at xi points.</span>
<a name="l02328"></a>02328 <span class="comment">//</span>
<a name="l02329"></a>02329 <span class="keywordtype">void</span> CNAnalysisMethod::fitDensityCurve( <span class="keyword">const</span> std::vector&lt;double&gt;&amp; values,
<a name="l02330"></a>02330                                         <span class="keyword">const</span> std::vector&lt;double&gt;&amp; weights,
<a name="l02331"></a>02331                                         std::vector&lt;double&gt;&amp; xi,
<a name="l02332"></a>02332                                         std::vector&lt;double&gt;&amp; density,
<a name="l02333"></a>02333                                         <span class="keywordtype">int</span> numPoints,
<a name="l02334"></a>02334                                         <span class="keywordtype">double</span> bandwidth,
<a name="l02335"></a>02335                                         <span class="keywordtype">bool</span> symmetry
<a name="l02336"></a>02336                                         )
<a name="l02337"></a>02337 {
<a name="l02338"></a>02338     <span class="keywordflow">if</span> (numPoints &lt;= 1) {
<a name="l02339"></a>02339         <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;Number of density coordinate points must be greater than 1&quot;</span>);
<a name="l02340"></a>02340     }
<a name="l02341"></a>02341 
<a name="l02342"></a>02342     <span class="keyword">const</span> <span class="keywordtype">double</span> pi = 3.14159265358979323846;
<a name="l02343"></a>02343     <span class="keyword">const</span> <span class="keywordtype">double</span> enlargeBy = 7.0 * bandwidth;
<a name="l02344"></a>02344     <span class="keyword">const</span> <span class="keywordtype">double</span> margin = 4.0 * bandwidth;
<a name="l02345"></a>02345 
<a name="l02346"></a>02346     <span class="comment">// pretend all values[] are shifted inside the interval [0, RR]</span>
<a name="l02347"></a>02347     <span class="comment">// with extra headroom (enlargeBy) on both sides</span>
<a name="l02348"></a>02348     <span class="keywordtype">double</span> minv = *std::min_element(values.begin(), values.end());
<a name="l02349"></a>02349     <span class="keywordtype">double</span> maxv = *std::max_element(values.begin(), values.end());
<a name="l02350"></a>02350     <span class="keywordtype">double</span> offset;
<a name="l02351"></a>02351     <span class="keywordtype">double</span> RR;
<a name="l02352"></a>02352     <span class="keywordflow">if</span> (symmetry) {
<a name="l02353"></a>02353         <span class="keywordflow">if</span> (std::fabs(minv) &lt; std::fabs(maxv)) {
<a name="l02354"></a>02354             offset = maxv + enlargeBy;
<a name="l02355"></a>02355             RR = maxv + enlargeBy + offset;
<a name="l02356"></a>02356         } <span class="keywordflow">else</span> {
<a name="l02357"></a>02357             offset = std::fabs(minv) + enlargeBy;
<a name="l02358"></a>02358             RR = std::fabs(minv) + enlargeBy + offset;
<a name="l02359"></a>02359         }
<a name="l02360"></a>02360     } <span class="keywordflow">else</span> {
<a name="l02361"></a>02361         offset = -(minv - enlargeBy);
<a name="l02362"></a>02362         RR = maxv + enlargeBy + offset;
<a name="l02363"></a>02363     }
<a name="l02364"></a>02364     
<a name="l02365"></a>02365     <span class="comment">// find nearest power of 2 larger than numPoints (for the FFT)</span>
<a name="l02366"></a>02366     <span class="keywordtype">int</span> nearPow2 = 1;
<a name="l02367"></a>02367     <span class="keywordflow">while</span> (nearPow2 &lt; numPoints) {
<a name="l02368"></a>02368         nearPow2 *= 2;
<a name="l02369"></a>02369     }
<a name="l02370"></a>02370 
<a name="l02371"></a>02371     <span class="keywordtype">double</span> delta = (2.0*RR)/(2*nearPow2 - 1);
<a name="l02372"></a>02372 
<a name="l02373"></a>02373     <span class="comment">// distribute weights[] proportionally along nearPow2 points</span>
<a name="l02374"></a>02374     <span class="comment">// spread uniformly across [0, RR]</span>
<a name="l02375"></a>02375     std::vector&lt;double&gt; densityRe(2*nearPow2, 0.0);
<a name="l02376"></a>02376     <span class="keywordtype">double</span> delta1 = RR/(nearPow2 - 1);
<a name="l02377"></a>02377     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iIndex = 0; iIndex &lt; values.size(); iIndex++)
<a name="l02378"></a>02378     {
<a name="l02379"></a>02379         <span class="keywordtype">double</span> curValue = values[iIndex] + offset;
<a name="l02380"></a>02380         <span class="keywordtype">int</span> intval = (int)std::floor(curValue/delta1);
<a name="l02381"></a>02381  
<a name="l02382"></a>02382         <span class="comment">// NB: intval &lt; nearPow2 - 1 (always)</span>
<a name="l02383"></a>02383         <span class="keywordtype">double</span> tt = (curValue - intval*delta1)/delta1;
<a name="l02384"></a>02384         densityRe[intval] += (1.0 - tt) * weights[iIndex];
<a name="l02385"></a>02385         densityRe[intval + 1] += tt * weights[iIndex];
<a name="l02386"></a>02386     }
<a name="l02387"></a>02387     <span class="comment">// pad with zeros to double the sampling rate</span>
<a name="l02388"></a>02388     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = nearPow2; ii &lt; 2*nearPow2; ii++)
<a name="l02389"></a>02389     {
<a name="l02390"></a>02390         densityRe[ii] = 0.0;
<a name="l02391"></a>02391     }
<a name="l02392"></a>02392     std::vector&lt;double&gt; densityIm(2*nearPow2, 0.0);
<a name="l02393"></a>02393 
<a name="l02394"></a>02394     <span class="comment">// calculate sum_i(weights[i] * exp(2 pi i t values[i]),</span>
<a name="l02395"></a>02395     <span class="comment">// for t = m/(nearPow2 * delta), m = 0 ... (nearPow2 - 1).</span>
<a name="l02396"></a>02396     <span class="comment">// Trick: this amounts to doing the inverse FFT on densityRe[]</span>
<a name="l02397"></a>02397     <span class="comment">//</span>
<a name="l02398"></a>02398     doFourierTransform(densityRe, densityIm, +1);
<a name="l02399"></a>02399 
<a name="l02400"></a>02400     <span class="comment">// plug the desired kernel function into the inverse FFT ,</span>
<a name="l02401"></a>02401     <span class="comment">// Remember that what&#39;s needed in the end is not f(t) but</span>
<a name="l02402"></a>02402     <span class="comment">// f(t*bandwidth). This means the kernel here must be supplied</span>
<a name="l02403"></a>02403     <span class="comment">// as kernel(x/bandwidth)/bandwidth</span>
<a name="l02404"></a>02404     <span class="comment">//</span>
<a name="l02405"></a>02405     std::vector&lt;double&gt; kernel(2*nearPow2);
<a name="l02406"></a>02406     <span class="keywordtype">double</span> arg = 0.0;
<a name="l02407"></a>02407     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; nearPow2; ii++) {
<a name="l02408"></a>02408         kernel[ii] = std::exp(-(arg/bandwidth)*(arg/bandwidth)/2.0) / std::sqrt(2.0 * pi)/bandwidth;
<a name="l02409"></a>02409         arg += delta;
<a name="l02410"></a>02410     }
<a name="l02411"></a>02411     arg = -nearPow2*delta;
<a name="l02412"></a>02412     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = nearPow2; ii &lt; 2*nearPow2; ii++) {
<a name="l02413"></a>02413         kernel[ii] = std::exp(-(arg/bandwidth)*(arg/bandwidth)/2.0) / std::sqrt(2.0 * pi)/bandwidth;
<a name="l02414"></a>02414         arg += delta;
<a name="l02415"></a>02415     }
<a name="l02416"></a>02416     std::vector&lt;double&gt; kernelIm(2*nearPow2, 0.0);    <span class="comment">// dummy</span>
<a name="l02417"></a>02417 
<a name="l02418"></a>02418     doFourierTransform(kernel, kernelIm, +1);
<a name="l02419"></a>02419 
<a name="l02420"></a>02420     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; 2*nearPow2; ii++) {
<a name="l02421"></a>02421         densityRe[ii] *= kernel[ii];
<a name="l02422"></a>02422         densityIm[ii] *= kernel[ii];
<a name="l02423"></a>02423     }
<a name="l02424"></a>02424 
<a name="l02425"></a>02425     <span class="comment">// FFT the result - this gives the desired distribution</span>
<a name="l02426"></a>02426     <span class="comment">// densityIm[] should come out identically zero</span>
<a name="l02427"></a>02427     <span class="comment">// densityRe[] should come out nonnegative, with second half identically zero</span>
<a name="l02428"></a>02428     <span class="comment">//</span>
<a name="l02429"></a>02429     doFourierTransform(densityRe, densityIm, -1);
<a name="l02430"></a>02430 
<a name="l02431"></a>02431     <span class="comment">// multiply the result by 1/(2 * nearPow2) to match the true</span>
<a name="l02432"></a>02432     <span class="comment">// Fourier transform (so the density integrates to 1)</span>
<a name="l02433"></a>02433     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nearPow2; i++) {
<a name="l02434"></a>02434         densityRe[i] /= 2 * nearPow2;
<a name="l02435"></a>02435     }
<a name="l02436"></a>02436 
<a name="l02437"></a>02437     <span class="comment">// interpolate from nearPow2 points to numPoints over the interval</span>
<a name="l02438"></a>02438     <span class="comment">// shrunk by margin on both sides</span>
<a name="l02439"></a>02439     <span class="keywordtype">double</span> eps = (RR - 2.0*margin)/(numPoints - 1);
<a name="l02440"></a>02440     density.resize(numPoints);
<a name="l02441"></a>02441     <span class="keywordtype">double</span> curValue = margin;
<a name="l02442"></a>02442     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; numPoints; ii++)
<a name="l02443"></a>02443     {
<a name="l02444"></a>02444         <span class="keywordtype">int</span> intval = (int)std::floor(curValue/delta1);
<a name="l02445"></a>02445         <span class="keywordtype">double</span> tt = (curValue - intval*delta1)/delta1;
<a name="l02446"></a>02446 
<a name="l02447"></a>02447         <span class="comment">// note intval+1 is within range because of the shrinking</span>
<a name="l02448"></a>02448         density[ii] = (1.0 - tt) * densityRe[intval] + tt * densityRe[intval + 1];
<a name="l02449"></a>02449         curValue += eps;
<a name="l02450"></a>02450     }
<a name="l02451"></a>02451 
<a name="l02452"></a>02452     <span class="comment">// symmetrise the density if needed</span>
<a name="l02453"></a>02453     <span class="keywordflow">if</span> (symmetry) {
<a name="l02454"></a>02454         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; numPoints/2; ii++) {
<a name="l02455"></a>02455             <span class="keywordtype">double</span> tmp = (density[ii] + density[numPoints - ii - 1])/2.0;
<a name="l02456"></a>02456             density[ii] = density[numPoints - ii - 1] = tmp;
<a name="l02457"></a>02457         }
<a name="l02458"></a>02458     }
<a name="l02459"></a>02459 
<a name="l02460"></a>02460     <span class="comment">// set the xi coordinates</span>
<a name="l02461"></a>02461     xi.resize(numPoints);
<a name="l02462"></a>02462     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; numPoints; ii++) {
<a name="l02463"></a>02463         xi[ii] = margin + ii*eps - offset;
<a name="l02464"></a>02464     }
<a name="l02465"></a>02465 }
<a name="l02466"></a>02466 
<a name="l02467"></a>02467 <span class="keywordtype">int</span> CNAnalysisMethod::reverseBits(<span class="keywordtype">int</span> ii, <span class="keywordtype">int</span> nbits)
<a name="l02468"></a>02468 {
<a name="l02469"></a>02469     <span class="keywordtype">int</span> k = 0;
<a name="l02470"></a>02470     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nbits; i++) {
<a name="l02471"></a>02471         <span class="keywordtype">int</span> j = ii/2;
<a name="l02472"></a>02472         k += k;
<a name="l02473"></a>02473         k += ii - 2*j;
<a name="l02474"></a>02474         ii = j;
<a name="l02475"></a>02475     }
<a name="l02476"></a>02476     <span class="keywordflow">return</span> k;
<a name="l02477"></a>02477 }
<a name="l02478"></a>02478 
<a name="l02479"></a>02479 <span class="keywordtype">void</span> CNAnalysisMethod::doBitReverseOrder(vector&lt;double&gt;&amp; vec)
<a name="l02480"></a>02480 {
<a name="l02481"></a>02481     <span class="keywordtype">int</span> nbits = 1;
<a name="l02482"></a>02482     <span class="keywordtype">int</span> N = vec.size();
<a name="l02483"></a>02483     <span class="keywordflow">while</span> ((N /= 2) != 1)
<a name="l02484"></a>02484     {
<a name="l02485"></a>02485         nbits++;
<a name="l02486"></a>02486     }
<a name="l02487"></a>02487     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; vec.size() - 1; i++) {
<a name="l02488"></a>02488         <span class="keywordtype">int</span> rIndex = reverseBits(i, nbits);
<a name="l02489"></a>02489         <span class="keywordflow">if</span> (rIndex &gt; i) {
<a name="l02490"></a>02490             std::swap( vec[i], vec[rIndex] );
<a name="l02491"></a>02491         }
<a name="l02492"></a>02492     }
<a name="l02493"></a>02493 }
<a name="l02494"></a>02494 
<a name="l02495"></a>02495 <span class="comment">// Fast Fourier Transform, requires input vectors&#39; length = 2^k.</span>
<a name="l02496"></a>02496 <span class="comment">// Performs the transform in-place, overwriting re[] and im[].</span>
<a name="l02497"></a>02497 <span class="comment">// Input:</span>
<a name="l02498"></a>02498 <span class="comment">//      re - real part of the input</span>
<a name="l02499"></a>02499 <span class="comment">//      im - imagianry part of the input</span>
<a name="l02500"></a>02500 <span class="comment">//      expSign - sign of the exponent of the FFT kernel:</span>
<a name="l02501"></a>02501 <span class="comment">//              = -1 means do the forward transform,</span>
<a name="l02502"></a>02502 <span class="comment">//              = +1 means do the inverse transform.</span>
<a name="l02503"></a>02503 <span class="comment">// Output:</span>
<a name="l02504"></a>02504 <span class="comment">//      re - real part of the output</span>
<a name="l02505"></a>02505 <span class="comment">//      im - imaginary part of the output</span>
<a name="l02506"></a>02506 <span class="comment">//</span>
<a name="l02507"></a>02507 <span class="keywordtype">void</span> CNAnalysisMethod::doFourierTransform(vector&lt;double&gt;&amp; re, vector&lt;double&gt;&amp; im, <span class="keywordtype">int</span> expSign)
<a name="l02508"></a>02508 {
<a name="l02509"></a>02509     <span class="keyword">const</span> <span class="keywordtype">double</span> pi = 3.14159265358979323846;
<a name="l02510"></a>02510 
<a name="l02511"></a>02511     doBitReverseOrder(re);
<a name="l02512"></a>02512     doBitReverseOrder(im);
<a name="l02513"></a>02513 
<a name="l02514"></a>02514     <span class="keywordtype">int</span> N = re.size();       <span class="comment">// must be a power of 2, equal to im.size()</span>
<a name="l02515"></a>02515 
<a name="l02516"></a>02516     <span class="keywordtype">int</span> iStep;
<a name="l02517"></a>02517     <span class="keywordtype">double</span> exponent = expSign * pi;
<a name="l02518"></a>02518     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> len = 1; len &lt; N; len = iStep) {
<a name="l02519"></a>02519         iStep = 2*len;
<a name="l02520"></a>02520         <span class="keywordtype">double</span> twiddle_re = cos(exponent/len);
<a name="l02521"></a>02521         <span class="keywordtype">double</span> twiddle_im = sin(exponent/len);
<a name="l02522"></a>02522         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; i += iStep) {
<a name="l02523"></a>02523             <span class="keywordtype">double</span> arg_re = 1.0;
<a name="l02524"></a>02524             <span class="keywordtype">double</span> arg_im = 0.0;
<a name="l02525"></a>02525             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i; j &lt; i + len; j++) {
<a name="l02526"></a>02526                 <span class="keywordtype">double</span> oddRe = arg_re * re[j + len] - arg_im * im[j + len];
<a name="l02527"></a>02527                 <span class="keywordtype">double</span> oddIm = arg_re * im[j + len] + arg_im * re[j + len];
<a name="l02528"></a>02528 
<a name="l02529"></a>02529                 <span class="comment">// butterfly</span>
<a name="l02530"></a>02530                 re[j + len] = re[j] - oddRe;
<a name="l02531"></a>02531                 im[j + len] = im[j] - oddIm;
<a name="l02532"></a>02532                 re[j] += oddRe;
<a name="l02533"></a>02533                 im[j] += oddIm;
<a name="l02534"></a>02534 
<a name="l02535"></a>02535                 <span class="comment">// twiddle update</span>
<a name="l02536"></a>02536                 <span class="keywordtype">double</span> tmp = arg_re;
<a name="l02537"></a>02537                 arg_re = arg_re * twiddle_re - arg_im * twiddle_im;
<a name="l02538"></a>02538                 arg_im = tmp    * twiddle_im + arg_im * twiddle_re;
<a name="l02539"></a>02539             }
<a name="l02540"></a>02540         }
<a name="l02541"></a>02541     }
<a name="l02542"></a>02542 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2016 12:58:55 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
