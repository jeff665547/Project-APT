<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: birdseed-v1/FitSNPGaussiansPriors3.v1.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_719784939364239bc32a7df5a3944084.html">birdseed-v1</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>FitSNPGaussiansPriors3.v1.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00002"></a>00002 <span class="comment"></span><span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// Copyright (C) 2007 The Broad Institute and Affymetrix, Inc.</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// This program is free software; you can redistribute it and/or modify </span>
<a name="l00006"></a>00006 <span class="comment">// it under the terms of the GNU General Public License (version 2) as </span>
<a name="l00007"></a>00007 <span class="comment">// published by the Free Software Foundation.</span>
<a name="l00008"></a>00008 <span class="comment">// </span>
<a name="l00009"></a>00009 <span class="comment">// This program is distributed in the hope that it will be useful, </span>
<a name="l00010"></a>00010 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<a name="l00011"></a>00011 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU </span>
<a name="l00012"></a>00012 <span class="comment">// General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment">// </span>
<a name="l00014"></a>00014 <span class="comment">// You should have received a copy of the GNU General Public License </span>
<a name="l00015"></a>00015 <span class="comment">// along with this program;if not, write to the </span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// Free Software Foundation, Inc., </span>
<a name="l00018"></a>00018 <span class="comment">// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00019"></a>00019 <span class="comment">//</span><span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">//</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;birdseed-v1/FitSNPGaussiansPriors3.h&quot;</span>
<a name="l00024"></a>00024 <span class="comment">//</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;birdseed-dev/Matrix.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;broadutil/APTUtil.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;broadutil/BroadUtil.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="SelfCreate_8h.html" title="Small interface for functions that know how to make an instance of themselves given a map of key...">chipstream/SelfCreate.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="SelfDoc_8h.html" title="Small interface to for algorithmic classes that can explain themselves.">chipstream/SelfDoc.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="PgOptions_8h.html" title="Classes for reading program command line options.">util/PgOptions.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="comment">//</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="keyword">using namespace </span>std;
<a name="l00040"></a>00040 <span class="keyword">using namespace </span>birdseed::v1;
<a name="l00041"></a>00041 <span class="keyword">using namespace </span>birdseed::dev;
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="comment">// See below for documentation of these parameters.</span>
<a name="l00044"></a>00044 <span class="keyword">static</span> <span class="keywordtype">double</span> std_slope;
<a name="l00045"></a>00045 <span class="keyword">static</span> <span class="keywordtype">double</span> epsilon;
<a name="l00046"></a>00046 <span class="keyword">static</span> <span class="keywordtype">double</span> eps;
<a name="l00047"></a>00047 <span class="keyword">static</span> <span class="keywordtype">double</span> var_start;
<a name="l00048"></a>00048 <span class="keyword">static</span> <span class="keywordtype">double</span> cluster_distance_ratio_cutoff;
<a name="l00049"></a>00049 <span class="comment">// TODO: Consider removing this, and removing tempmeandist, and lambda3</span>
<a name="l00050"></a>00050 <span class="keyword">static</span> <span class="keywordtype">double</span> mean_dist2;
<a name="l00051"></a>00051 <span class="keyword">static</span> <span class="keywordtype">double</span> lambda3;
<a name="l00052"></a>00052 <span class="keyword">static</span> <span class="keywordtype">double</span> merged_cluster_threshold;
<a name="l00053"></a>00053 <span class="keyword">static</span> <span class="keywordtype">double</span> small_cluster_weight_threshold;
<a name="l00054"></a>00054 <span class="keyword">static</span> <span class="keywordtype">double</span> expected_wingspan_ratio;
<a name="l00055"></a>00055 <span class="keyword">static</span> <span class="keywordtype">double</span> low_hom_weight_fraction;
<a name="l00056"></a>00056 <span class="keyword">static</span> <span class="keywordtype">double</span> low_hom_sample_inflation;
<a name="l00057"></a>00057 <span class="keyword">static</span> <span class="keywordtype">double</span> starting_cluster_weight;
<a name="l00058"></a>00058 <span class="keyword">static</span> <span class="keywordtype">size_t</span> max_iter;
<a name="l00059"></a>00059 <span class="keyword">static</span> <span class="keywordtype">double</span> min_covar;
<a name="l00060"></a>00060 <span class="keyword">static</span> <span class="keywordtype">double</span> max_covar1;
<a name="l00061"></a>00061 <span class="keyword">static</span> <span class="keywordtype">double</span> max_covar2;
<a name="l00062"></a>00062 <span class="keyword">static</span> <span class="keywordtype">double</span> covar_floor_decay;
<a name="l00063"></a>00063 <span class="keyword">static</span> <span class="keywordtype">double</span> low_covar_threshold;
<a name="l00064"></a>00064 <span class="keyword">static</span> <span class="keywordtype">double</span> wing_length_delta_penalty;
<a name="l00065"></a>00065 <span class="keyword">static</span> <span class="keywordtype">double</span> small_cluster_penalty;
<a name="l00066"></a>00066 <span class="keyword">static</span> <span class="keywordtype">double</span> unbalanced_wingspan_penalty;
<a name="l00067"></a>00067 <span class="keyword">static</span> <span class="keywordtype">double</span> low_covar_penalty;
<a name="l00068"></a>00068 <span class="keyword">static</span> <span class="keywordtype">double</span> bic_weight;
<a name="l00069"></a>00069 <span class="comment">// Not static because used by GenotypeCaller</span>
<a name="l00070"></a>00070 <span class="keywordtype">double</span> birdseed::v1::final_weight_min;
<a name="l00071"></a>00071 <span class="keyword">static</span> <span class="keywordtype">double</span> cluster_variance_regularization_factor;
<a name="l00072"></a>00072 <span class="keyword">static</span> <span class="keywordtype">double</span> var_mult;
<a name="l00073"></a>00073 <span class="keyword">static</span> <span class="keywordtype">bool</span>  allow_unlikely_clusters;
<a name="l00074"></a>00074 <span class="keyword">static</span> <span class="keywordtype">double</span> hom_hom_penalty;
<a name="l00075"></a>00075 <span class="keyword">static</span> <span class="keywordtype">double</span> mono_het_penalty;
<a name="l00076"></a>00076 <span class="keyword">static</span> <span class="keywordtype">double</span> two_cluster_low_observation_penalty_factor;
<a name="l00077"></a>00077 <span class="comment">// This is not static because GenotypeCaller uses it.</span>
<a name="l00078"></a>00078 <span class="keywordtype">double</span> birdseed::v1::relative_distance_confidence_weight;
<a name="l00079"></a>00079 <span class="keyword">static</span> <span class="keywordtype">double</span> std_inflection_point;
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> special = <span class="keyword">true</span>;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#define log(value) log((double)value)</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>
<a name="l00087"></a>00087 <span class="preprocessor">#ifdef __sun__</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span><span class="preprocessor">#define log(value) log((double)value)</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span>
<a name="l00091"></a>00091 <span class="comment">// This class translates between the local parameters in this file and PgOptions world.</span>
<a name="l00092"></a>00092 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00093"></a>00093 <span class="keyword">class </span><a class="code" href="classOptionSpec.html">OptionSpec</a>
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095   <span class="keyword">public</span>:
<a name="l00096"></a>00096     T *targetVariable;
<a name="l00097"></a>00097     <a class="code" href="classPgOpt.html" title="///">PgOpt</a> pgOpt;
<a name="l00098"></a>00098     <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a> selfDocOpt;
<a name="l00099"></a>00099   <a class="code" href="classOptionSpec.html">OptionSpec</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *longName, T *targetVariable, T defaultValue, <span class="keyword">const</span> <span class="keywordtype">char</span> *defaultValueAsString, <span class="keyword">const</span> <span class="keywordtype">char</span> *helpDoc, <a class="code" href="classPgOpt.html#a2d7a96bff0c8aed58fbb2520f37a2248" title="Types of allowed options.">PgOpt::PgOptType_t</a> optType, <span class="keywordtype">bool</span> makeSelfDocOpt):
<a name="l00100"></a>00100         targetVariable(targetVariable),
<a name="l00101"></a>00101         pgOpt()
<a name="l00102"></a>00102     {
<a name="l00103"></a>00103         pgOpt.m_shortName = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00104"></a>00104         pgOpt.m_longName = longName;
<a name="l00105"></a>00105         pgOpt.m_type = optType;
<a name="l00106"></a>00106         pgOpt.m_help = helpDoc;
<a name="l00107"></a>00107         pgOpt.m_defaultValue = defaultValueAsString;
<a name="l00108"></a>00108         *targetVariable = defaultValue;
<a name="l00109"></a>00109         <span class="keywordflow">if</span> (makeSelfDocOpt) {
<a name="l00110"></a>00110             selfDocOpt.name = longName;
<a name="l00111"></a>00111             selfDocOpt.value = defaultValueAsString;
<a name="l00112"></a>00112             selfDocOpt.defaultVal = defaultValueAsString;
<a name="l00113"></a>00113             selfDocOpt.minVal = <span class="stringliteral">&quot;NA&quot;</span>;
<a name="l00114"></a>00114             selfDocOpt.maxVal = <span class="stringliteral">&quot;NA&quot;</span>;
<a name="l00115"></a>00115             selfDocOpt.descript = helpDoc;
<a name="l00116"></a>00116             <span class="keywordflow">switch</span> (optType) {
<a name="l00117"></a>00117             <span class="keywordflow">case</span> PgOpt::BOOL_OPT:
<a name="l00118"></a>00118                 selfDocOpt.type = SelfDoc::Opt::Boolean;
<a name="l00119"></a>00119                 <span class="keywordflow">break</span>;
<a name="l00120"></a>00120             <span class="keywordflow">case</span> PgOpt::INT_OPT:
<a name="l00121"></a>00121                 selfDocOpt.type = SelfDoc::Opt::Integer;
<a name="l00122"></a>00122                 <span class="keywordflow">break</span>;
<a name="l00123"></a>00123             <span class="keywordflow">case</span> PgOpt::DOUBLE_OPT:
<a name="l00124"></a>00124                 selfDocOpt.type = SelfDoc::Opt::Double;
<a name="l00125"></a>00125                 <span class="keywordflow">break</span>;
<a name="l00126"></a>00126             <span class="keywordflow">default</span>:
<a name="l00127"></a>00127                 <span class="keywordflow">throw</span> <a class="code" href="classBroadException.html">BroadException</a>(<span class="stringliteral">&quot;Unrecognized option type&quot;</span>, __FILE__, __LINE__);
<a name="l00128"></a>00128                 <span class="keywordflow">break</span>;
<a name="l00129"></a>00129             }
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131     }
<a name="l00132"></a>00132 };
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="preprocessor">#define DEFINE_OPTION(TYPE, VAR_NAME, DEFAULT_VALUE, HELP_DOC, OPT_TYPE, MAKE_SELF_DOC) \</span>
<a name="l00135"></a>00135 <span class="preprocessor">    OptionSpec&lt;TYPE&gt;(#VAR_NAME, &amp;VAR_NAME, DEFAULT_VALUE, #DEFAULT_VALUE, HELP_DOC, OPT_TYPE, MAKE_SELF_DOC)</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span><span class="preprocessor">#define DEFINE_DOUBLE_OPTION(VAR_NAME, DEFAULT_VALUE, HELP_DOC, MAKE_SELF_DOC) DEFINE_OPTION(double, VAR_NAME, DEFAULT_VALUE, HELP_DOC, PgOpt::DOUBLE_OPT, MAKE_SELF_DOC)</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span>
<a name="l00138"></a>00138 <span class="keyword">static</span> <a class="code" href="classOptionSpec.html">OptionSpec&lt;double&gt;</a> doubleOptions[] = {
<a name="l00139"></a>00139     DEFINE_DOUBLE_OPTION(std_slope, 0.062, <span class="stringliteral">&quot;expected slope of cluster standard deviation versus cluster mean intensity.&quot;</span>, <span class="keyword">true</span>),
<a name="l00140"></a>00140     DEFINE_DOUBLE_OPTION(epsilon, 0.001, <span class="stringliteral">&quot;tolerance at which to stop optimizing cluster locations.&quot;</span>, <span class="keyword">true</span>),
<a name="l00141"></a>00141     DEFINE_DOUBLE_OPTION(eps, 0.00000000000000022204, <span class="stringliteral">&quot;a very small number.&quot;</span>, <span class="keyword">true</span>),
<a name="l00142"></a>00142     DEFINE_DOUBLE_OPTION(var_start, 1.1, <span class="stringliteral">&quot;intialize the variances to be var_start times the expected.&quot;</span>, <span class="keyword">true</span>),
<a name="l00143"></a>00143     DEFINE_DOUBLE_OPTION(cluster_distance_ratio_cutoff, 0.85, <span class="stringliteral">&quot;the ratio of adjacent cluster means in each direction must exceed this value.&quot;</span>, <span class="keyword">true</span>),
<a name="l00144"></a>00144     DEFINE_DOUBLE_OPTION(merged_cluster_threshold, .025, <span class="stringliteral">&quot;if two cluster means get this close to each other, consider them merged, and stop trying EM.&quot;</span>, <span class="keyword">true</span>),
<a name="l00145"></a>00145     DEFINE_DOUBLE_OPTION(small_cluster_weight_threshold, 0.01, <span class="stringliteral">&quot;if k==3, any weight&lt;small_cluster_weight_threshold, penalize ll with small_cluster_penalty.&quot;</span>, <span class="keyword">true</span>),
<a name="l00146"></a>00146         DEFINE_DOUBLE_OPTION(low_hom_weight_fraction, 0.5, <span class="stringliteral">&quot;Hom cluster should not have low weight.&quot;</span>, <span class="keyword">true</span>),
<a name="l00147"></a>00147         DEFINE_DOUBLE_OPTION(low_hom_sample_inflation, 100, <span class="stringliteral">&quot;Hom cluster should not have low weight.  Sample inflation factor.&quot;</span>, <span class="keyword">true</span>),
<a name="l00148"></a>00148         DEFINE_DOUBLE_OPTION(starting_cluster_weight,0.05, <span class="stringliteral">&quot;Starting weight for uninitialized clusters.&quot;</span>, <span class="keyword">true</span>),
<a name="l00149"></a>00149     DEFINE_DOUBLE_OPTION(small_cluster_penalty, 10.0, <span class="stringliteral">&quot;how much to penalize small clusters when k=3.&quot;</span>, <span class="keyword">true</span>),
<a name="l00150"></a>00150     DEFINE_DOUBLE_OPTION(expected_wingspan_ratio, 1.15, <span class="stringliteral">&quot;penalize ll if ratio of wing lengths is above this number.&quot;</span>, <span class="keyword">true</span>),
<a name="l00151"></a>00151     DEFINE_DOUBLE_OPTION(unbalanced_wingspan_penalty, 5.0, <span class="stringliteral">&quot;how much to penalize differences from expected_wingspan_ratio.&quot;</span>, <span class="keyword">true</span>),
<a name="l00152"></a>00152     DEFINE_DOUBLE_OPTION(min_covar, -0.7, <span class="stringliteral">&quot;don&#39;t let covar get lower than this.&quot;</span>, <span class="keyword">true</span>),
<a name="l00153"></a>00153         DEFINE_DOUBLE_OPTION(max_covar1, 0.9, <span class="stringliteral">&quot;covar1 not larger than this.&quot;</span>, <span class="keyword">true</span>),
<a name="l00154"></a>00154         DEFINE_DOUBLE_OPTION(max_covar2, 0.95,<span class="stringliteral">&quot;covar2 not larger than this.&quot;</span>, <span class="keyword">true</span>),
<a name="l00155"></a>00155         DEFINE_DOUBLE_OPTION(covar_floor_decay,8,<span class="stringliteral">&quot;Covariance decays over this iteration scale. Default &quot;</span>, <span class="keyword">true</span>),
<a name="l00156"></a>00156     DEFINE_DOUBLE_OPTION(low_covar_threshold, 1.0, <span class="stringliteral">&quot;penalize covariances below this number.&quot;</span>, <span class="keyword">true</span>),
<a name="l00157"></a>00157     DEFINE_DOUBLE_OPTION(low_covar_penalty, 15.0, <span class="stringliteral">&quot;how much to penalize covar below low_covar_threshold.&quot;</span>, <span class="keyword">true</span>),
<a name="l00158"></a>00158     DEFINE_DOUBLE_OPTION(wing_length_delta_penalty, 50.0, <span class="stringliteral">&quot;how much to penalize differences from the prior.&quot;</span>, <span class="keyword">true</span>),
<a name="l00159"></a>00159     DEFINE_DOUBLE_OPTION(bic_weight, 1.0, <span class="stringliteral">&quot;how much to penalize higher-order k&#39;s.&quot;</span>, <span class="keyword">true</span>),
<a name="l00160"></a>00160     DEFINE_DOUBLE_OPTION(final_weight_min, 0.333, <span class="stringliteral">&quot;After calculating clusters, ensure all weights are &gt;= this.&quot;</span>, <span class="keyword">true</span>),
<a name="l00161"></a>00161     DEFINE_DOUBLE_OPTION(cluster_variance_regularization_factor, 1.0, <span class="stringliteral">&quot;How much cluster variances are regularized to look like each other.&quot;</span>, <span class="keyword">true</span>),
<a name="l00162"></a>00162     DEFINE_DOUBLE_OPTION(var_mult, 1.2, <span class="stringliteral">&quot;Multiply the variance for missing clusters by this value squared.&quot;</span>, <span class="keyword">true</span>),
<a name="l00163"></a>00163     DEFINE_DOUBLE_OPTION(hom_hom_penalty, 2.1, <span class="stringliteral">&quot;Multiply the average distance between clusters and priors in 2-cluster model by this, when trying to fit clusters to hom priors.&quot;</span>, <span class="keyword">true</span>),
<a name="l00164"></a>00164 
<a name="l00165"></a>00165     DEFINE_DOUBLE_OPTION(mono_het_penalty, 10, <span class="stringliteral">&quot;Multiply the distance squared between cluster and prior in 1-cluster model by this, when trying to fit single cluster to AB prior.&quot;</span>, <span class="keyword">true</span>),
<a name="l00166"></a>00166     DEFINE_DOUBLE_OPTION(two_cluster_low_observation_penalty_factor, 1000000, <span class="stringliteral">&quot;When penalizing an alignment of two-cluster model, use this factor to place a floor on penalty when number of prior observations for a prior is low.&quot;</span>, <span class="keyword">true</span>),
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     DEFINE_DOUBLE_OPTION(relative_distance_confidence_weight, 0.8, <span class="stringliteral">&quot;How much to weight confidence factor determined by comparing probability of best match vs. probability of second best match. Confidence factor determined by measuring distance of sample from cluster center is weighted by 1-this value.&quot;</span>, <span class="keyword">true</span>),
<a name="l00169"></a>00169     DEFINE_DOUBLE_OPTION(std_inflection_point, 4.0, <span class="stringliteral">&quot;Factor in determination of confidence based on distance of sample from cluster center.&quot;</span>, <span class="keyword">true</span>),
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     DEFINE_DOUBLE_OPTION(mean_dist2, 1.25, <span class="stringliteral">&quot;if two means get this close, penalize ll by 3k*log(n)/2;.&quot;</span>, <span class="keyword">true</span>),
<a name="l00172"></a>00172     DEFINE_DOUBLE_OPTION(lambda3, 15.0, <span class="stringliteral">&quot;how much to penalize differences from mean_dist2.&quot;</span>, <span class="keyword">true</span>)
<a name="l00173"></a>00173 };
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="keyword">static</span> <a class="code" href="classOptionSpec.html">OptionSpec&lt;size_t&gt;</a> size_tOptions[] = {
<a name="l00176"></a>00176     DEFINE_OPTION(<span class="keywordtype">size_t</span>, max_iter, 50, <span class="stringliteral">&quot;if it reaches more than max_iter/k iterations, just stop.&quot;</span>, PgOpt::INT_OPT, <span class="keyword">true</span>)
<a name="l00177"></a>00177 };
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="keyword">static</span> <a class="code" href="classOptionSpec.html">OptionSpec&lt;bool&gt;</a> boolOptions[] = {
<a name="l00180"></a>00180     DEFINE_OPTION(<span class="keywordtype">bool</span>, allow_unlikely_clusters, <span class="keyword">true</span>, <span class="stringliteral">&quot;Allow 2-cluster model to match to AA &amp;&amp; BB priors, and allow 1-cluster model to match AB prior.&quot;</span>, PgOpt::BOOL_OPT, <span class="keyword">true</span>)
<a name="l00181"></a>00181 };
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="keyword">static</span> <a class="code" href="classPgOpt.html" title="///">PgOpt</a> *pgOptions[ARRAY_LEN(doubleOptions) + ARRAY_LEN(size_tOptions) + ARRAY_LEN(boolOptions) + 1];
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="comment">// This class is here merely to get some static initializer code run, so that parameters get</span>
<a name="l00187"></a>00187 <span class="comment">// their default values, and the PgOpt array is initialized.</span>
<a name="l00188"></a>00188 <span class="keyword">static</span> <span class="keyword">class </span>PgOptionCreator
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190   <span class="keyword">public</span>:
<a name="l00191"></a>00191     PgOptionCreator()
<a name="l00192"></a>00192     {
<a name="l00193"></a>00193         <a class="code" href="classPgOpt.html" title="///">PgOpt</a> **p = pgOptions;
<a name="l00194"></a>00194         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(doubleOptions); ++i) {
<a name="l00195"></a>00195             *p++ = &amp;doubleOptions[i].pgOpt;
<a name="l00196"></a>00196         }
<a name="l00197"></a>00197         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(size_tOptions); ++i) {
<a name="l00198"></a>00198             *p++ = &amp;size_tOptions[i].pgOpt;
<a name="l00199"></a>00199         }
<a name="l00200"></a>00200         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(boolOptions); ++i) {
<a name="l00201"></a>00201             *p++ = &amp;boolOptions[i].pgOpt;
<a name="l00202"></a>00202         }
<a name="l00203"></a>00203         *p = NULL;
<a name="l00204"></a>00204     }
<a name="l00205"></a>00205 } theOptionCreator;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <a class="code" href="classPgOpt.html" title="///">PgOpt</a> **birdseed::v1::getAlgorithmicOpts()
<a name="l00208"></a>00208 {
<a name="l00209"></a>00209     <span class="keywordflow">return</span> pgOptions;
<a name="l00210"></a>00210 }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="keywordtype">void</span> birdseed::v1::setAlgorithmicParameters(CONSTHACK <a class="code" href="classPgOptions.html">PgOptions</a> &amp;opts)
<a name="l00213"></a>00213 {
<a name="l00214"></a>00214     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(doubleOptions); ++i) {
<a name="l00215"></a>00215         *doubleOptions[i].targetVariable = opts.getDouble(doubleOptions[i].pgOpt.m_longName);
<a name="l00216"></a>00216     }
<a name="l00217"></a>00217     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(size_tOptions); ++i) {
<a name="l00218"></a>00218         *size_tOptions[i].targetVariable = opts.getInt(size_tOptions[i].pgOpt.m_longName);
<a name="l00219"></a>00219     }
<a name="l00220"></a>00220     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(boolOptions); ++i) {
<a name="l00221"></a>00221         *boolOptions[i].targetVariable = opts.getBool(boolOptions[i].pgOpt.m_longName);
<a name="l00222"></a>00222     }
<a name="l00223"></a>00223 }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="keywordtype">void</span> birdseed::v1::getSelfDocOptions(vector&lt;SelfDoc::Opt&gt; *opts)
<a name="l00226"></a>00226 {
<a name="l00227"></a>00227     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(doubleOptions); ++i) {
<a name="l00228"></a>00228         <span class="keywordflow">if</span> (!doubleOptions[i].selfDocOpt.name.empty()) {
<a name="l00229"></a>00229             opts-&gt;push_back(doubleOptions[i].selfDocOpt);
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231     }
<a name="l00232"></a>00232     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(size_tOptions); ++i) {
<a name="l00233"></a>00233         <span class="keywordflow">if</span> (!size_tOptions[i].selfDocOpt.name.empty()) {
<a name="l00234"></a>00234             opts-&gt;push_back(size_tOptions[i].selfDocOpt);
<a name="l00235"></a>00235         }
<a name="l00236"></a>00236     }
<a name="l00237"></a>00237     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(boolOptions); ++i) {
<a name="l00238"></a>00238         <span class="keywordflow">if</span> (!boolOptions[i].selfDocOpt.name.empty()) {
<a name="l00239"></a>00239             opts-&gt;push_back(boolOptions[i].selfDocOpt);
<a name="l00240"></a>00240         }
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242 }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 <span class="keywordtype">void</span> birdseed::v1::setSelfDocOptions(<a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a> *doc, CONSTHACK std::map&lt;std::string,std::string&gt; &amp;param)
<a name="l00245"></a>00245 {
<a name="l00246"></a>00246     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(doubleOptions); ++i) {
<a name="l00247"></a>00247         <span class="keywordflow">if</span> (!doubleOptions[i].selfDocOpt.name.empty()) {
<a name="l00248"></a>00248             SelfCreate::fillInValue(*doubleOptions[i].targetVariable, doubleOptions[i].selfDocOpt.name, param, *doc);
<a name="l00249"></a>00249         }
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(size_tOptions); ++i) {
<a name="l00252"></a>00252         <span class="keywordflow">if</span> (!size_tOptions[i].selfDocOpt.name.empty()) {
<a name="l00253"></a>00253             <span class="keywordtype">int</span> value;
<a name="l00254"></a>00254             SelfCreate::fillInValue(value, size_tOptions[i].selfDocOpt.name, param, *doc);
<a name="l00255"></a>00255             *size_tOptions[i].targetVariable = value;
<a name="l00256"></a>00256         }
<a name="l00257"></a>00257     }
<a name="l00258"></a>00258     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ARRAY_LEN(boolOptions); ++i) {
<a name="l00259"></a>00259         <span class="keywordflow">if</span> (!boolOptions[i].selfDocOpt.name.empty()) {
<a name="l00260"></a>00260             SelfCreate::fillInValue(*boolOptions[i].targetVariable, boolOptions[i].selfDocOpt.name, param, *doc);
<a name="l00261"></a>00261         }
<a name="l00262"></a>00262     }
<a name="l00263"></a>00263 }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 
<a name="l00266"></a>00266 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> diploidNumGaussians[] = {1, 2, 3, 3};
<a name="l00267"></a>00267 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> lenDiploidNumGaussians = ARRAY_SIZE(diploidNumGaussians);
<a name="l00268"></a>00268 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> haploidNumGaussians[] = {1, 2};
<a name="l00269"></a>00269 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> lenHaploidNumGaussians = ARRAY_SIZE(haploidNumGaussians);
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="keyword">static</span> <span class="keywordtype">int</span> verbosity = 0;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="keywordtype">void</span> birdseed::v1::setFitSNPGaussiansVerbosity(<span class="keywordtype">int</span> verbose)
<a name="l00274"></a>00274 {
<a name="l00275"></a>00275     verbosity = verbose;
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="keyword">static</span> <span class="keywordtype">double</span> computeStdInterceptPrior(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors, <span class="keywordtype">size_t</span> whichAllele)
<a name="l00279"></a>00279 {
<a name="l00280"></a>00280     <span class="keywordtype">double</span> numerator = 0.0;
<a name="l00281"></a>00281     <span class="keywordtype">size_t</span> denominator = 0;
<a name="l00282"></a>00282     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; priors.getNumPriors(); ++i) {
<a name="l00283"></a>00283         denominator += priors.getPrior(i).m_numObservations;
<a name="l00284"></a>00284         numerator += priors.getPrior(i).m_numObservations *
<a name="l00285"></a>00285             (sqrt(priors.getPrior(i).m_covarMatrix[whichAllele][whichAllele]) - std_slope * priors.getPrior(i).m_mean[whichAllele]);
<a name="l00286"></a>00286     }
<a name="l00287"></a>00287     <span class="keywordflow">return</span> numerator / denominator;
<a name="l00288"></a>00288 }
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 <span class="keyword">static</span> <span class="keywordtype">double</span> determinant(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> &amp;mat)
<a name="l00291"></a>00291 {
<a name="l00292"></a>00292     <span class="keywordflow">return</span> mat[1][1]*mat[0][0] - mat[1][0]*mat[0][1];
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="keyword">static</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> invert(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> &amp;inMatrix)
<a name="l00296"></a>00296 {
<a name="l00297"></a>00297     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> outMatrix;
<a name="l00298"></a>00298     <span class="keywordtype">double</span> det = determinant(inMatrix);
<a name="l00299"></a>00299     outMatrix[0][0] = inMatrix[1][1] / det;
<a name="l00300"></a>00300     outMatrix[1][1] = inMatrix[0][0] / det;
<a name="l00301"></a>00301     outMatrix[0][1] = -inMatrix[0][1] / det;
<a name="l00302"></a>00302     outMatrix[1][0] = -inMatrix[1][0] / det;
<a name="l00303"></a>00303     <span class="keywordflow">return</span> outMatrix;
<a name="l00304"></a>00304 }
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 <span class="keyword">template</span>&lt;<span class="keyword">class</span> MATRIX, <span class="keyword">class</span> VECTOR&gt;
<a name="l00307"></a>00307 <span class="keyword">static</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> covariance(<span class="keyword">const</span> MATRIX &amp;<a class="code" href="classmatrix.html">matrix</a>, <span class="keyword">const</span> VECTOR &amp;means)
<a name="l00308"></a>00308 {
<a name="l00309"></a>00309     assert(means.size() == NUM_ALLELES);
<a name="l00310"></a>00310     assert(matrix.numCols() == NUM_ALLELES);
<a name="l00311"></a>00311     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> ret;
<a name="l00312"></a>00312     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; NUM_ALLELES; ++i) {
<a name="l00313"></a>00313         ret[i][i] = variance(matrix, means[i], i);
<a name="l00314"></a>00314     }
<a name="l00315"></a>00315     <span class="keywordtype">double</span> acc = 0.0;
<a name="l00316"></a>00316     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; matrix.numRows(); ++i) {
<a name="l00317"></a>00317         acc += (matrix[i][0] - means[0]) * (matrix[i][1] - means[1]);
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319     ret[0][1] = ret[1][0] = acc / (matrix.numRows() - 1);
<a name="l00320"></a>00320     <span class="keywordflow">return</span> ret;
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MATRIX&gt;
<a name="l00324"></a>00324 <span class="keyword">static</span> MATRIX pow(<span class="keyword">const</span> MATRIX &amp;matrix, <span class="keyword">typename</span> MATRIX::value_type exponent)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326     MATRIX ret;
<a name="l00327"></a>00327     <span class="keywordflow">if</span> (exponent == 2) {
<a name="l00328"></a>00328         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; matrix.numRows(); ++row) {
<a name="l00329"></a>00329             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; matrix.numCols(); ++col) {
<a name="l00330"></a>00330                 ret[row][col] = matrix[row][col] * matrix[row][col];
<a name="l00331"></a>00331             }
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333     }
<a name="l00334"></a>00334     <span class="keywordflow">else</span> {
<a name="l00335"></a>00335         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; matrix.numRows(); ++row) {
<a name="l00336"></a>00336             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; matrix.numCols(); ++col) {
<a name="l00337"></a>00337                 ret[row][col] = pow(matrix[row][col], exponent);
<a name="l00338"></a>00338             }
<a name="l00339"></a>00339         }
<a name="l00340"></a>00340     }
<a name="l00341"></a>00341     <span class="keywordflow">return</span> ret;
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="keyword">template</span>&lt;<span class="keyword">class</span> VECTOR&gt;
<a name="l00345"></a>00345 <span class="keyword">static</span> VECTOR powVector(<span class="keyword">const</span> VECTOR &amp;vec, <span class="keyword">typename</span> VECTOR::value_type exponent)
<a name="l00346"></a>00346 {
<a name="l00347"></a>00347     VECTOR ret(vec.size());
<a name="l00348"></a>00348     <span class="keywordflow">if</span> (exponent == 2) {
<a name="l00349"></a>00349         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec.size(); ++i) {
<a name="l00350"></a>00350             ret[i] = vec[i] * vec[i];
<a name="l00351"></a>00351         }
<a name="l00352"></a>00352     }
<a name="l00353"></a>00353     <span class="keywordflow">else</span> {
<a name="l00354"></a>00354         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec.size(); ++i) {
<a name="l00355"></a>00355             ret[i] = pow(vec[i], exponent);
<a name="l00356"></a>00356         }
<a name="l00357"></a>00357     }
<a name="l00358"></a>00358     <span class="keywordflow">return</span> ret;
<a name="l00359"></a>00359 }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MATRIX&gt;
<a name="l00363"></a>00363 <span class="keyword">static</span> MATRIX sqrt(<span class="keyword">const</span> MATRIX &amp;matrix)
<a name="l00364"></a>00364 {
<a name="l00365"></a>00365     MATRIX ret(matrix.numRows());
<a name="l00366"></a>00366     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; matrix.numRows(); ++row) {
<a name="l00367"></a>00367         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; matrix.numCols(); ++col) {
<a name="l00368"></a>00368             ret[row][col] = sqrt(matrix[row][col]);
<a name="l00369"></a>00369         }
<a name="l00370"></a>00370     }
<a name="l00371"></a>00371     <span class="keywordflow">return</span> ret;
<a name="l00372"></a>00372 }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="keyword">template</span> &lt;<span class="keyword">class</span> VECTOR&gt;
<a name="l00375"></a>00375 <span class="keyword">static</span> VECTOR sqrtVector(<span class="keyword">const</span> VECTOR &amp;vec)
<a name="l00376"></a>00376 {
<a name="l00377"></a>00377     VECTOR ret(vec.size());
<a name="l00378"></a>00378     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vec.size(); ++i) {
<a name="l00379"></a>00379         ret[i] = sqrt(vec[i]);
<a name="l00380"></a>00380     }
<a name="l00381"></a>00381     <span class="keywordflow">return</span> ret;
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">double</span> calculateBestPriorFit(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> &amp;B, <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors, <span class="keywordtype">size_t</span> otherprior, <span class="keywordtype">size_t</span> bestpriormatch)
<a name="l00385"></a>00385 {
<a name="l00386"></a>00386     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> priorMeanDelta = priors.getPrior(otherprior).m_mean - priors.getPrior(bestpriormatch).m_mean;
<a name="l00387"></a>00387     <span class="keywordflow">return</span> exp(-((priorMeanDelta * B * priorMeanDelta)/2.0));
<a name="l00388"></a>00388 }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 <span class="comment">// Returns the index of the prior that the cluster matched</span>
<a name="l00391"></a>00391 <span class="keyword">static</span> <span class="keywordtype">size_t</span> monomorphicCluster(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *ret,
<a name="l00392"></a>00392                                  <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities,
<a name="l00393"></a>00393                                  <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors,
<a name="l00394"></a>00394                                  <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> &amp;stdInterceptPrior)
<a name="l00395"></a>00395 {
<a name="l00396"></a>00396     <span class="keywordtype">int</span> numSamples = intensities.numRows();
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     <span class="comment">// number of gaussians</span>
<a name="l00399"></a>00399     <span class="keywordtype">size_t</span> k = 1;
<a name="l00400"></a>00400 
<a name="l00401"></a>00401     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> means;
<a name="l00402"></a>00402     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; NUM_ALLELES; ++i) {
<a name="l00403"></a>00403         means[i] = mean(intensities, i);
<a name="l00404"></a>00404     }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     <span class="comment">// check out concordance with the priors:</span>
<a name="l00407"></a>00407     <span class="keywordtype">size_t</span> priorIndexA = Priors::AA_INDEX;
<a name="l00408"></a>00408     <span class="keywordtype">size_t</span> priorIndexB = Priors::BB_INDEX;
<a name="l00409"></a>00409     <span class="keywordflow">if</span> (!priors.isDiploid()) {
<a name="l00410"></a>00410         priorIndexA = Priors::A_INDEX;
<a name="l00411"></a>00411         priorIndexB = Priors::B_INDEX;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413     }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415      <span class="keywordtype">double</span> delta_meanA = priors.getPrior(priorIndexA).m_mean[A_ALLELE_INDEX] - means[A_ALLELE_INDEX];
<a name="l00416"></a>00416      <span class="keywordtype">double</span> delta_meanB = priors.getPrior(priorIndexA).m_mean[B_ALLELE_INDEX] - means[B_ALLELE_INDEX];
<a name="l00417"></a>00417      <span class="keywordtype">double</span> aa_distance_sqrd = (delta_meanA * delta_meanA) + (delta_meanB * delta_meanB);
<a name="l00418"></a>00418      delta_meanA = priors.getPrior(priorIndexB).m_mean[A_ALLELE_INDEX] - means[A_ALLELE_INDEX];
<a name="l00419"></a>00419      delta_meanB = priors.getPrior(priorIndexB).m_mean[B_ALLELE_INDEX] - means[B_ALLELE_INDEX];
<a name="l00420"></a>00420      <span class="keywordtype">double</span> bb_distance_sqrd = (delta_meanA * delta_meanA) + (delta_meanB * delta_meanB);
<a name="l00421"></a>00421      delta_meanA = priors.getPrior(Priors::AB_INDEX).m_mean[A_ALLELE_INDEX] - means[A_ALLELE_INDEX];
<a name="l00422"></a>00422      delta_meanB = priors.getPrior(Priors::AB_INDEX).m_mean[B_ALLELE_INDEX] - means[B_ALLELE_INDEX];
<a name="l00423"></a>00423      <span class="keywordtype">double</span> ab_distance_sqrd = (delta_meanA * delta_meanA) + (delta_meanB * delta_meanB);
<a name="l00424"></a>00424     <span class="keywordtype">size_t</span> bestpriormatch;
<a name="l00425"></a>00425     <span class="keywordtype">size_t</span> otherprior;
<a name="l00426"></a>00426     <span class="keywordflow">if</span> (priors.isDiploid()) {
<a name="l00427"></a>00427         bestpriormatch = (aa_distance_sqrd &lt;= bb_distance_sqrd? Priors::AA_INDEX: Priors::BB_INDEX);
<a name="l00428"></a>00428         <span class="keywordtype">double</span> bestdistance_sqrd = (aa_distance_sqrd &lt;= bb_distance_sqrd? aa_distance_sqrd: bb_distance_sqrd);
<a name="l00429"></a>00429         otherprior = Priors::AB_INDEX;
<a name="l00430"></a>00430         <span class="keywordflow">if</span> (allow_unlikely_clusters) {
<a name="l00431"></a>00431             ab_distance_sqrd *= mono_het_penalty;
<a name="l00432"></a>00432             <span class="keywordflow">if</span> (ab_distance_sqrd &lt; bestdistance_sqrd) {
<a name="l00433"></a>00433                 bestpriormatch = Priors::AB_INDEX;
<a name="l00434"></a>00434             }
<a name="l00435"></a>00435         }
<a name="l00436"></a>00436     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (aa_distance_sqrd &lt;= bb_distance_sqrd) {
<a name="l00437"></a>00437         bestpriormatch = Priors::A_INDEX;
<a name="l00438"></a>00438         otherprior = Priors::B_INDEX;
<a name="l00439"></a>00439     } <span class="keywordflow">else</span> {
<a name="l00440"></a>00440         bestpriormatch = Priors::B_INDEX;
<a name="l00441"></a>00441         otherprior = Priors::A_INDEX;
<a name="l00442"></a>00442     }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444     <span class="comment">// Found best match</span>
<a name="l00445"></a>00445         <span class="keywordflow">if</span> (verbosity&gt;2)
<a name="l00446"></a>00446         {
<a name="l00447"></a>00447                 cout &lt;&lt; <span class="stringliteral">&quot;MonomorphicClusterDistances:\t&quot;</span>;
<a name="l00448"></a>00448                 cout &lt;&lt; aa_distance_sqrd &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00449"></a>00449                 cout &lt;&lt; ab_distance_sqrd &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00450"></a>00450                 cout &lt;&lt; bb_distance_sqrd &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00451"></a>00451                 cout &lt;&lt; endl;
<a name="l00452"></a>00452                 cout &lt;&lt; <span class="stringliteral">&quot;MonomorphicPriorMatch:\t&quot;</span>;
<a name="l00453"></a>00453                 cout &lt;&lt; bestpriormatch &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00454"></a>00454                 cout &lt;&lt; endl;
<a name="l00455"></a>00455         }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457     <span class="keywordtype">double</span> vars[NUM_ALLELES];
<a name="l00458"></a>00458     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; NUM_ALLELES; ++i) {
<a name="l00459"></a>00459         vars[i] = numSamples/(numSamples) * variance(intensities, means[i], i);
<a name="l00460"></a>00460     }
<a name="l00461"></a>00461     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> temp = covariance(intensities, means);
<a name="l00462"></a>00462     <span class="keywordtype">double</span> covar2 = temp[0][1]/sqrt(temp[0][0]*temp[1][1]);
<a name="l00463"></a>00463     <span class="keywordtype">double</span> covar = min(max_covar2, max(covar2, min_covar));
<a name="l00464"></a>00464     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> varmat;
<a name="l00465"></a>00465     varmat[0][0] = vars[0];
<a name="l00466"></a>00466     varmat[1][0] = varmat[0][1] = covar * sqrt(vars[0]*vars[1]);
<a name="l00467"></a>00467     varmat[1][1] = vars[1];
<a name="l00468"></a>00468     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> B = invert(varmat);
<a name="l00469"></a>00469     <span class="keywordtype">double</span> bestpriorfit;
<a name="l00470"></a>00470     <span class="keywordflow">if</span> (priors.isDiploid() &amp;&amp; bestpriormatch == Priors::AB_INDEX) {
<a name="l00471"></a>00471         bestpriorfit = max(calculateBestPriorFit(B, priors, Priors::AA_INDEX, Priors::AB_INDEX),
<a name="l00472"></a>00472                            calculateBestPriorFit(B, priors, Priors::BB_INDEX, Priors::AB_INDEX));
<a name="l00473"></a>00473     } <span class="keywordflow">else</span> {
<a name="l00474"></a>00474         bestpriorfit = calculateBestPriorFit(B, priors, otherprior, bestpriormatch);
<a name="l00475"></a>00475     }
<a name="l00476"></a>00476     <span class="keywordtype">double</span> bestscale1 = means[0]/priors.getPrior(bestpriormatch).m_mean[0];
<a name="l00477"></a>00477     <span class="keywordtype">double</span> bestscale2 = means[1]/priors.getPrior(bestpriormatch).m_mean[1];
<a name="l00478"></a>00478 
<a name="l00479"></a>00479     <span class="keywordtype">double</span> A = (1/sqrt(determinant(varmat)))/(2*pi);
<a name="l00480"></a>00480     <span class="keywordtype">double</span> sum_log_pxi_zj = 0.0;
<a name="l00481"></a>00481     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numSamples; ++i) {
<a name="l00482"></a>00482         sum_log_pxi_zj += log(A * exp(-((intensities[i] - means) * B * (intensities[i] - means))/2.0));
<a name="l00483"></a>00483     }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485     <span class="comment">// fill in the missing gaussians</span>
<a name="l00486"></a>00486     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> stdIntercept;
<a name="l00487"></a>00487     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; NUM_ALLELES; ++d) {
<a name="l00488"></a>00488         stdIntercept[d] = sqrt(vars[d]) - std_slope*means[d];
<a name="l00489"></a>00489     }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491     ret-&gt;means.resize(priors.getNumPriors());
<a name="l00492"></a>00492     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; priors.getNumPriors(); ++i) {
<a name="l00493"></a>00493         ret-&gt;means[i][0] = priors.getPrior(i).m_mean[0] * bestscale1;
<a name="l00494"></a>00494         ret-&gt;means[i][1] = priors.getPrior(i).m_mean[1] * bestscale2;
<a name="l00495"></a>00495     }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497     <span class="keywordtype">double</span> var_mult_sq = var_mult * var_mult;
<a name="l00498"></a>00498     ret-&gt;vars.resize(priors.getNumPriors());
<a name="l00499"></a>00499     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; priors.getNumPriors(); ++row) {
<a name="l00500"></a>00500         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; NUM_ALLELES; ++col) {
<a name="l00501"></a>00501           ret-&gt;vars[row][col] = 
<a name="l00502"></a>00502             (stdIntercept[col] + std_slope*ret-&gt;means[row][col]) * 
<a name="l00503"></a>00503             (stdIntercept[col] + std_slope*ret-&gt;means[row][col]);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505             <span class="keywordflow">if</span> (row != bestpriormatch) {
<a name="l00506"></a>00506                 ret-&gt;vars[row][col] *= var_mult_sq;
<a name="l00507"></a>00507             }
<a name="l00508"></a>00508         }
<a name="l00509"></a>00509     }
<a name="l00510"></a>00510     ret-&gt;weights.resize(priors.getNumPriors());
<a name="l00511"></a>00511     ret-&gt;weights.setAllElements(starting_cluster_weight);
<a name="l00512"></a>00512     <span class="keywordflow">if</span> (priors.getNumPriors() == MAX_NUM_CLUSTERS) {
<a name="l00513"></a>00513         ret-&gt;weights[bestpriormatch] = 1-2*starting_cluster_weight;
<a name="l00514"></a>00514     } <span class="keywordflow">else</span> {
<a name="l00515"></a>00515         ret-&gt;weights[bestpriormatch] = 1-starting_cluster_weight;
<a name="l00516"></a>00516     }
<a name="l00517"></a>00517 
<a name="l00518"></a>00518         <span class="keywordflow">if</span> (verbosity&gt;2)
<a name="l00519"></a>00519         {
<a name="l00520"></a>00520                 cout &lt;&lt; <span class="stringliteral">&quot;MonomorphicClusterLogL:\t&quot;</span>;
<a name="l00521"></a>00521                 cout &lt;&lt; sum_log_pxi_zj &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00522"></a>00522                 cout &lt;&lt; max(0.0,low_covar_threshold-covar2) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00523"></a>00523                 cout &lt;&lt; bestpriorfit &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00524"></a>00524                 cout &lt;&lt; 0.5*(2*k+2+k)*log(static_cast&lt;double&gt;(numSamples)) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00525"></a>00525                 cout &lt;&lt; endl;
<a name="l00526"></a>00526         }
<a name="l00527"></a>00527     ret-&gt;log_likelihood = sum_log_pxi_zj
<a name="l00528"></a>00528         - low_covar_penalty*log(static_cast&lt;double&gt;(numSamples))*max(0.0, low_covar_threshold-covar2)
<a name="l00529"></a>00529         - wing_length_delta_penalty*bestpriorfit
<a name="l00530"></a>00530         - bic_weight*0.5*(2*k+2+k)*log(static_cast&lt;double&gt;(numSamples));
<a name="l00531"></a>00531     ret-&gt;covar = covar;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533     <span class="keywordflow">return</span> bestpriormatch;
<a name="l00534"></a>00534 }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536 
<a name="l00537"></a>00537 <span class="keyword">static</span> <span class="keywordtype">void</span> initialize(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *ret,
<a name="l00538"></a>00538                        <span class="keywordtype">size_t</span> k,
<a name="l00539"></a>00539                        <span class="keywordtype">size_t</span> count,
<a name="l00540"></a>00540                        <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities,
<a name="l00541"></a>00541                        <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors,
<a name="l00542"></a>00542                        <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> &amp;stdInterceptPrior,
<a name="l00543"></a>00543                        <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> &amp;oldavgvars,
<a name="l00544"></a>00544                        <span class="keywordtype">size_t</span> bestpriormatch)
<a name="l00545"></a>00545 {
<a name="l00546"></a>00546     assert(k &gt; 1);
<a name="l00547"></a>00547     <span class="keywordflow">if</span> (k == 2) {
<a name="l00548"></a>00548         ret-&gt;covar = 0;
<a name="l00549"></a>00549         ret-&gt;weights.resize(k);
<a name="l00550"></a>00550         ret-&gt;weights.setAllElements(1.0/k);
<a name="l00551"></a>00551         ret-&gt;means.resize(2);
<a name="l00552"></a>00552         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; NUM_ALLELES; ++col) {
<a name="l00553"></a>00553             ret-&gt;means[0][col] = priors.getAPrior().m_mean[col];
<a name="l00554"></a>00554             ret-&gt;means[1][col] = priors.getBPrior().m_mean[col];
<a name="l00555"></a>00555         }
<a name="l00556"></a>00556         <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> temp;
<a name="l00557"></a>00557         temp[0][0] = temp[1][0] = stdInterceptPrior[0];
<a name="l00558"></a>00558         temp[0][1] = temp[1][1] = stdInterceptPrior[1];
<a name="l00559"></a>00559 
<a name="l00560"></a>00560         ret-&gt;vars.resize(2);
<a name="l00561"></a>00561         ret-&gt;vars = pow(temp + ret-&gt;means * std_slope, 2) * var_start;
<a name="l00562"></a>00562         <span class="keywordflow">if</span> (special &amp;&amp; count == 1) {
<a name="l00563"></a>00563             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; k; ++row) {
<a name="l00564"></a>00564                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; NUM_ALLELES; ++col) {
<a name="l00565"></a>00565                     ret-&gt;vars[row][col] =
<a name="l00566"></a>00566                         0.666 * oldavgvars[bestpriormatch][col];
<a name="l00567"></a>00567                 }
<a name="l00568"></a>00568             }
<a name="l00569"></a>00569         }
<a name="l00570"></a>00570     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k == 3) {
<a name="l00571"></a>00571         ret-&gt;weights.resize(k);
<a name="l00572"></a>00572         ret-&gt;weights.setAllElements(1.0/k);
<a name="l00573"></a>00573         <span class="keywordflow">if</span> (special &amp;&amp; count == 2) {
<a name="l00574"></a>00574             ret-&gt;means.resize(3);
<a name="l00575"></a>00575             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; MAX_NUM_CLUSTERS; ++row) {
<a name="l00576"></a>00576                 ret-&gt;means[row] = priors.getPrior(row).m_mean;
<a name="l00577"></a>00577             }
<a name="l00578"></a>00578             ret-&gt;vars.resize(3);
<a name="l00579"></a>00579             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; MAX_NUM_CLUSTERS; ++row) {
<a name="l00580"></a>00580                 ret-&gt;vars[row][0] = priors.getPrior(row).m_covarMatrix[0][0];
<a name="l00581"></a>00581                 ret-&gt;vars[row][1] = priors.getPrior(row).m_covarMatrix[1][1];
<a name="l00582"></a>00582             }
<a name="l00583"></a>00583             <span class="keywordtype">double</span> acc = 0;
<a name="l00584"></a>00584             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; MAX_NUM_CLUSTERS; ++i) {
<a name="l00585"></a>00585                 acc += priors.getPrior(i).m_numObservations * priors.getPrior(i).m_covarMatrix[1][0] /
<a name="l00586"></a>00586                     sqrt(priors.getPrior(i).m_covarMatrix[0][0] * priors.getPrior(i).m_covarMatrix[1][1]);
<a name="l00587"></a>00587             }
<a name="l00588"></a>00588             ret-&gt;covar = max(min_covar,min(max_covar1, acc/priors.numObservations()));
<a name="l00589"></a>00589         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (special) {
<a name="l00590"></a>00590             ret-&gt;means.resize(3);
<a name="l00591"></a>00591             ret-&gt;means[0][0] = minInColumn(intensities, 0);
<a name="l00592"></a>00592             ret-&gt;means[0][1] = maxInColumn(intensities, 1);
<a name="l00593"></a>00593             ret-&gt;means[2][0] = maxInColumn(intensities, 0);
<a name="l00594"></a>00594             ret-&gt;means[2][1] = minInColumn(intensities, 1);
<a name="l00595"></a>00595             ret-&gt;means[1] = (ret-&gt;means[0] + ret-&gt;means[2])/2;
<a name="l00596"></a>00596 
<a name="l00597"></a>00597             ret-&gt;vars.resize(3);
<a name="l00598"></a>00598             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; ret-&gt;means.numRows(); ++row) {
<a name="l00599"></a>00599                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; ret-&gt;means.numCols(); ++col) {
<a name="l00600"></a>00600                   ret-&gt;vars[row][col] = 
<a name="l00601"></a>00601                       ((ret-&gt;means[row][col] * std_slope + stdInterceptPrior[col]) * 
<a name="l00602"></a>00602                        (ret-&gt;means[row][col] * std_slope + stdInterceptPrior[col])) * 
<a name="l00603"></a>00603                     var_start;
<a name="l00604"></a>00604                 }
<a name="l00605"></a>00605             }
<a name="l00606"></a>00606             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; ret-&gt;vars.numCols(); ++col) {
<a name="l00607"></a>00607                 ret-&gt;vars[1][col] /= 20;
<a name="l00608"></a>00608             }
<a name="l00609"></a>00609             ret-&gt;covar = 0.0;
<a name="l00610"></a>00610         } <span class="keywordflow">else</span> {
<a name="l00611"></a>00611             ret-&gt;means.resize(3);
<a name="l00612"></a>00612             ret-&gt;vars.resize(3);
<a name="l00613"></a>00613             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; MAX_NUM_CLUSTERS; ++row) {
<a name="l00614"></a>00614                 ret-&gt;means[row] = priors.getPrior(row).m_mean;
<a name="l00615"></a>00615                 ret-&gt;vars[row][0] = priors.getPrior(row).m_covarMatrix[0][0];
<a name="l00616"></a>00616                 ret-&gt;vars[row][1] = priors.getPrior(row).m_covarMatrix[1][1];
<a name="l00617"></a>00617             }
<a name="l00618"></a>00618             ret-&gt;covar = 0.0;
<a name="l00619"></a>00619         }
<a name="l00620"></a>00620     } <span class="keywordflow">else</span> {
<a name="l00621"></a>00621         assert(<span class="keyword">false</span>);
<a name="l00622"></a>00622     }
<a name="l00623"></a>00623 }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 <span class="comment">// k=2 case</span>
<a name="l00626"></a>00626 <span class="comment">// Not called for male chrX</span>
<a name="l00627"></a>00627 <span class="keyword">static</span> <span class="keywordtype">void</span> fillInMissingGaussians(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *clusters, <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors, <span class="keywordtype">size_t</span> numSamples)
<a name="l00628"></a>00628 {
<a name="l00629"></a>00629     <span class="comment">// fill in missing Gaussians:</span>
<a name="l00630"></a>00630     <span class="comment">// check out concordance with the priors:</span>
<a name="l00631"></a>00631     <span class="comment">// If all else fails, consider clusters to be AA and AB</span>
<a name="l00632"></a>00632     <span class="keywordtype">size_t</span> bestpriormatch[2] = {0, 1};
<a name="l00633"></a>00633     <span class="keywordtype">double</span> bestdistance = INFINITY;
<a name="l00634"></a>00634     <span class="keywordtype">double</span> bestshift1 = 0;
<a name="l00635"></a>00635     <span class="keywordtype">double</span> bestshift2 = 0;
<a name="l00636"></a>00636     <span class="keywordtype">double</span> bestscale1 = 1;
<a name="l00637"></a>00637     <span class="keywordtype">double</span> bestscale2 = 1;
<a name="l00638"></a>00638 
<a name="l00639"></a>00639     <span class="comment">// Just syntactic sugar</span>
<a name="l00640"></a>00640     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> &amp;means = clusters-&gt;means;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> firstCluster = Priors::AA_INDEX; firstCluster &lt; Priors::BB_INDEX; ++firstCluster) {
<a name="l00643"></a>00643         <span class="keywordtype">size_t</span> maxSecondCluster;
<a name="l00644"></a>00644         maxSecondCluster = (allow_unlikely_clusters? Priors::BB_INDEX: firstCluster + 1);
<a name="l00645"></a>00645         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> secondCluster = firstCluster + 1; secondCluster &lt;= maxSecondCluster; ++secondCluster) {
<a name="l00646"></a>00646 
<a name="l00647"></a>00647             <span class="comment">// Hom cluster should not have low weight</span>
<a name="l00648"></a>00648                 <span class="keywordflow">if</span> (verbosity&gt;2)
<a name="l00649"></a>00649                 {
<a name="l00650"></a>00650                         cout &lt;&lt; <span class="stringliteral">&quot;2fillCluster:\t&quot;</span>;
<a name="l00651"></a>00651                         cout &lt;&lt; firstCluster &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00652"></a>00652                         cout &lt;&lt; clusters-&gt;weights[0] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00653"></a>00653                         cout &lt;&lt; low_hom_weight_fraction*(numSamples/(numSamples+low_hom_sample_inflation)) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00654"></a>00654                         cout &lt;&lt; secondCluster &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00655"></a>00655                         cout &lt;&lt; clusters-&gt;weights[1] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00656"></a>00656                         cout &lt;&lt; endl;
<a name="l00657"></a>00657                 }
<a name="l00658"></a>00658             <span class="keywordflow">if</span> (firstCluster == Priors::AA_INDEX &amp;&amp; clusters-&gt;weights[0] &lt; low_hom_weight_fraction*numSamples/(numSamples+low_hom_sample_inflation)) {
<a name="l00659"></a>00659                 <span class="keywordflow">continue</span>;
<a name="l00660"></a>00660             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (secondCluster == Priors::BB_INDEX &amp;&amp; clusters-&gt;weights[1] &lt; low_hom_weight_fraction*numSamples/(numSamples+low_hom_sample_inflation)) {
<a name="l00661"></a>00661                 <span class="keywordflow">continue</span>;
<a name="l00662"></a>00662             }
<a name="l00663"></a>00663 
<a name="l00664"></a>00664             <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> tempmat;
<a name="l00665"></a>00665             tempmat[0][1] = tempmat[1][1] = 1;
<a name="l00666"></a>00666             tempmat[0][0] = priors.getPrior(firstCluster).m_mean[0];
<a name="l00667"></a>00667             tempmat[1][0] = priors.getPrior(secondCluster).m_mean[0];
<a name="l00668"></a>00668 
<a name="l00669"></a>00669             <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, 2&gt;</a> temp1 = invert(tempmat) * means.columnSlice(0);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671             tempmat[0][1] = tempmat[1][1] = 1;
<a name="l00672"></a>00672             tempmat[0][0] = priors.getPrior(firstCluster).m_mean[1];
<a name="l00673"></a>00673             tempmat[1][0] = priors.getPrior(secondCluster).m_mean[1];
<a name="l00674"></a>00674 
<a name="l00675"></a>00675             <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, 2&gt;</a> temp2 = invert(tempmat) * means.columnSlice(1);
<a name="l00676"></a>00676 
<a name="l00677"></a>00677             <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, 2&gt;</a> priorMeanSlice0;
<a name="l00678"></a>00678             priorMeanSlice0[0] = priors.getPrior(firstCluster).m_mean[0];
<a name="l00679"></a>00679             priorMeanSlice0[1] = priors.getPrior(secondCluster).m_mean[0];
<a name="l00680"></a>00680 
<a name="l00681"></a>00681             <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, 2&gt;</a> priorMeanSlice1;
<a name="l00682"></a>00682             priorMeanSlice1[0] = priors.getPrior(firstCluster).m_mean[1];
<a name="l00683"></a>00683             priorMeanSlice1[1] = priors.getPrior(secondCluster).m_mean[1];
<a name="l00684"></a>00684 
<a name="l00685"></a>00685             <span class="keywordtype">double</span> distance = meanVector(sqrtVector(powVector(priorMeanSlice0 - means.columnSlice(0), 2) +
<a name="l00686"></a>00686                                                     powVector(priorMeanSlice1 - means.columnSlice(1), 2)));
<a name="l00687"></a>00687 
<a name="l00688"></a>00688             <span class="comment">// Penalize this alignment if the hom cluster has few observations</span>
<a name="l00689"></a>00689             <span class="keywordflow">if</span> (firstCluster == Priors::AA_INDEX &amp;&amp; priors.getPrior(Priors::AA_INDEX).m_numObservations &lt; priors.numObservations()) {
<a name="l00690"></a>00690                 distance *= sqrt((two_cluster_low_observation_penalty_factor + priors.numObservations())/(two_cluster_low_observation_penalty_factor + priors.getPrior(Priors::AA_INDEX).m_numObservations));
<a name="l00691"></a>00691             }
<a name="l00692"></a>00692             <span class="comment">// There is potentially a double penalty if for the AA-BB alignment, if both have few observations.</span>
<a name="l00693"></a>00693             <span class="keywordflow">if</span> (secondCluster == Priors::BB_INDEX &amp;&amp; priors.getPrior(Priors::BB_INDEX).m_numObservations &lt; priors.numObservations()) {
<a name="l00694"></a>00694                 distance *= sqrt((two_cluster_low_observation_penalty_factor + priors.numObservations())/(two_cluster_low_observation_penalty_factor + priors.getPrior(Priors::BB_INDEX).m_numObservations));
<a name="l00695"></a>00695             }
<a name="l00696"></a>00696             <span class="keywordflow">if</span> (firstCluster == Priors::AA_INDEX &amp;&amp; secondCluster == Priors::BB_INDEX) {
<a name="l00697"></a>00697                 distance *= hom_hom_penalty;
<a name="l00698"></a>00698             }
<a name="l00699"></a>00699                 <span class="keywordflow">if</span> (verbosity&gt;2)
<a name="l00700"></a>00700                 {
<a name="l00701"></a>00701                         <span class="comment">// decision made on distance</span>
<a name="l00702"></a>00702                         cout &lt;&lt; <span class="stringliteral">&quot;2fillClusterDistance:\t&quot;</span>;
<a name="l00703"></a>00703                         cout &lt;&lt; distance &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00704"></a>00704                         cout &lt;&lt; temp1[0] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; temp2[0] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00705"></a>00705                         cout &lt;&lt; temp1[1] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; temp2[1] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00706"></a>00706                         cout &lt;&lt; endl;
<a name="l00707"></a>00707                 }
<a name="l00708"></a>00708             <span class="keywordflow">if</span> (distance&lt;bestdistance) {
<a name="l00709"></a>00709                 bestdistance = distance;
<a name="l00710"></a>00710                 bestpriormatch[0] = firstCluster;
<a name="l00711"></a>00711                 bestpriormatch[1] = secondCluster;
<a name="l00712"></a>00712                 bestscale1 = temp1[0];
<a name="l00713"></a>00713                 bestscale2 = temp2[0];
<a name="l00714"></a>00714                 bestshift1 = temp1[1];
<a name="l00715"></a>00715                 bestshift2 = temp2[1];
<a name="l00716"></a>00716             }
<a name="l00717"></a>00717         }
<a name="l00718"></a>00718     }
<a name="l00719"></a>00719 
<a name="l00720"></a>00720     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> oldMeans(clusters-&gt;means);
<a name="l00721"></a>00721     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> oldVars(clusters-&gt;vars);
<a name="l00722"></a>00722     <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> oldWeights(clusters-&gt;weights);
<a name="l00723"></a>00723     <span class="comment">// fill in the missing gaussians:</span>
<a name="l00724"></a>00724     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> stdIntercept;
<a name="l00725"></a>00725     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; NUM_ALLELES; ++d) {
<a name="l00726"></a>00726         stdIntercept[d] = meanVector(sqrtVector(clusters-&gt;vars.columnSlice(d)) -
<a name="l00727"></a>00727                               clusters-&gt;means.columnSlice(d) * std_slope);
<a name="l00728"></a>00728     }
<a name="l00729"></a>00729     clusters-&gt;means.resize(MAX_NUM_CLUSTERS);
<a name="l00730"></a>00730     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; MAX_NUM_CLUSTERS; ++i) {
<a name="l00731"></a>00731         clusters-&gt;means[i][0] = bestshift1 + priors.getPrior(i).m_mean[0] * bestscale1;
<a name="l00732"></a>00732         clusters-&gt;means[i][1] = bestshift2 + priors.getPrior(i).m_mean[1] * bestscale2;
<a name="l00733"></a>00733     }
<a name="l00734"></a>00734     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 2; ++i) {
<a name="l00735"></a>00735         clusters-&gt;means[bestpriormatch[i]] = oldMeans[i];
<a name="l00736"></a>00736     }
<a name="l00737"></a>00737     clusters-&gt;means = maxMatrixElementwise(clusters-&gt;means, 50);
<a name="l00738"></a>00738     clusters-&gt;vars.resize(MAX_NUM_CLUSTERS);
<a name="l00739"></a>00739     <span class="keywordtype">double</span> var_mult_sq = var_mult * var_mult;
<a name="l00740"></a>00740     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; MAX_NUM_CLUSTERS; ++row) {
<a name="l00741"></a>00741         clusters-&gt;vars[row] = powVector(stdIntercept + clusters-&gt;means[row]*std_slope, 2) * var_mult_sq;
<a name="l00742"></a>00742     }
<a name="l00743"></a>00743     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 2; ++i) {
<a name="l00744"></a>00744         clusters-&gt;vars[bestpriormatch[i]] = oldVars[i];
<a name="l00745"></a>00745     }
<a name="l00746"></a>00746     clusters-&gt;weights.resize(MAX_NUM_CLUSTERS);
<a name="l00747"></a>00747     clusters-&gt;weights.setAllElements(starting_cluster_weight);
<a name="l00748"></a>00748     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 2; ++i) {
<a name="l00749"></a>00749         clusters-&gt;weights[bestpriormatch[i]] = min(1 - starting_cluster_weight * (MAX_NUM_CLUSTERS-1),
<a name="l00750"></a>00750                                                      max(starting_cluster_weight,
<a name="l00751"></a>00751                                                          oldWeights[i] *
<a name="l00752"></a>00752                                                          (1 - starting_cluster_weight * (MAX_NUM_CLUSTERS-2))));
<a name="l00753"></a>00753     }
<a name="l00754"></a>00754 }
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 <span class="keywordtype">void</span> birdseed::v1::calculatePXI_ZJ(<a class="code" href="classbirdseed_1_1dev_1_1VarVarMatrix.html">PXI_ZJMatrix</a> *pxi_zj,
<a name="l00757"></a>00757                                <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> &amp;clusters,
<a name="l00758"></a>00758                                <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities,
<a name="l00759"></a>00759                                <span class="keywordtype">size_t</span> k)
<a name="l00760"></a>00760 {
<a name="l00761"></a>00761     assert(pxi_zj-&gt;numRows() == intensities.numRows());
<a name="l00762"></a>00762     assert(pxi_zj-&gt;numCols() == k);
<a name="l00763"></a>00763     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; k; ++j) {
<a name="l00764"></a>00764         <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> varmat;
<a name="l00765"></a>00765         varmat[0][0] = clusters.vars[j][0];
<a name="l00766"></a>00766         varmat[0][1] = clusters.covar * sqrt(clusters.vars[j][0] * clusters.vars[j][1]);
<a name="l00767"></a>00767         varmat[1][0] = varmat[0][1];
<a name="l00768"></a>00768         varmat[1][1] = clusters.vars[j][1];
<a name="l00769"></a>00769         <span class="keywordtype">double</span> A = clusters.weights[j] * (1/pow(determinant(varmat), .5)) / (2*pi);
<a name="l00770"></a>00770         <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> B = invert(varmat);
<a name="l00771"></a>00771         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; intensities.numRows(); ++i) {
<a name="l00772"></a>00772             <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> meanDelta = intensities[i] - clusters.means[j];
<a name="l00773"></a>00773             (*pxi_zj)[i][j] = A * exp(-((meanDelta * B * meanDelta)/2));
<a name="l00774"></a>00774         }
<a name="l00775"></a>00775     }
<a name="l00776"></a>00776 }
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 <span class="keyword">static</span> <span class="keywordtype">void</span> estimation(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *clusters, <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities, <span class="keywordtype">size_t</span> k)
<a name="l00779"></a>00779 {
<a name="l00780"></a>00780     calculatePXI_ZJ(&amp;clusters-&gt;pxi_zj, *clusters, intensities, k);
<a name="l00781"></a>00781     <span class="keywordtype">double</span> theSum = 0.0;
<a name="l00782"></a>00782     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; clusters-&gt;pxi_zj.numRows(); ++row) {
<a name="l00783"></a>00783         theSum += log(sumRow(clusters-&gt;pxi_zj, row));
<a name="l00784"></a>00784 
<a name="l00785"></a>00785     }
<a name="l00786"></a>00786     clusters-&gt;log_likelihood = theSum;
<a name="l00787"></a>00787 }
<a name="l00788"></a>00788 
<a name="l00789"></a>00789 <span class="keyword">static</span> <span class="keywordtype">void</span> finishEMLoop(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *clusters, <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors, <span class="keywordtype">size_t</span> k, <span class="keywordtype">size_t</span> numSamples)
<a name="l00790"></a>00790 {
<a name="l00791"></a>00791     <span class="comment">// Just syntactic sugar</span>
<a name="l00792"></a>00792     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> &amp;means = clusters-&gt;means;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794     vector&lt;double&gt; meandists(k-1);
<a name="l00795"></a>00795     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; k-1; ++i) {
<a name="l00796"></a>00796         meandists[i] = sqrt(sumVector(powVector(means[i+1] - means[i], 2)));
<a name="l00797"></a>00797     }
<a name="l00798"></a>00798     <span class="keywordtype">double</span> avgmeandist = sumVector(meandists)/meandists.size();
<a name="l00799"></a>00799     <span class="keywordtype">double</span> worstmeandist = maxInVector(meandists)/avgmeandist;
<a name="l00800"></a>00800     <span class="keywordtype">double</span> tempmeandist = INFINITY;
<a name="l00801"></a>00801     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; k-1; ++i) {
<a name="l00802"></a>00802         <span class="keywordtype">double</span> temp = (means[i+1][0]/means[i][0] + means[i][1]/means[i+1][1])/2;
<a name="l00803"></a>00803         tempmeandist = min(temp, tempmeandist);
<a name="l00804"></a>00804     }
<a name="l00805"></a>00805 
<a name="l00806"></a>00806         <span class="comment">// simplified version of the logic for testing the second cluster</span>
<a name="l00807"></a>00807         tempmeandist = (10.0/3) * (tempmeandist -
<a name="l00808"></a>00808                                    (priors.isDiploid()?
<a name="l00809"></a>00809                                     mean_dist2:
<a name="l00810"></a>00810                                     1.0));
<a name="l00811"></a>00811 
<a name="l00812"></a>00812     <span class="keywordtype">double</span> tempmeandist2 = INFINITY;
<a name="l00813"></a>00813     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; k-1; ++i) {
<a name="l00814"></a>00814         tempmeandist2 = min(tempmeandist2, means[i+1][0]/means[i][0]);
<a name="l00815"></a>00815         tempmeandist2 = min(tempmeandist2, means[i][1]/means[i+1][1]);
<a name="l00816"></a>00816     }
<a name="l00817"></a>00817 
<a name="l00818"></a>00818     <span class="keywordflow">if</span> ((k == 2) &amp;&amp; priors.isDiploid()) {
<a name="l00819"></a>00819         fillInMissingGaussians(clusters, priors, numSamples);
<a name="l00820"></a>00820     }
<a name="l00821"></a>00821 
<a name="l00822"></a>00822     <span class="keywordtype">double</span> bestpriorfit = 0.0;
<a name="l00823"></a>00823     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; priors.getNumPriors() - 1; ++i) {
<a name="l00824"></a>00824         <span class="keywordtype">double</span> delta_means0 = clusters-&gt;means[i][0]-clusters-&gt;means[i+1][0];
<a name="l00825"></a>00825         <span class="keywordtype">double</span> delta_means1 = clusters-&gt;means[i][1]-clusters-&gt;means[i+1][1];
<a name="l00826"></a>00826         <span class="keywordtype">double</span> mymeandist = sqrt((delta_means0 * delta_means0) + (delta_means1 * delta_means1));
<a name="l00827"></a>00827         delta_means0 = priors.getPrior(i).m_mean[0] - priors.getPrior(i+1).m_mean[0];
<a name="l00828"></a>00828         delta_means1 = priors.getPrior(i).m_mean[1] - priors.getPrior(i+1).m_mean[1];
<a name="l00829"></a>00829         <span class="keywordtype">double</span> priormeandist = sqrt((delta_means0 * delta_means0) + (delta_means1 * delta_means1));
<a name="l00830"></a>00830         bestpriorfit += abs(mymeandist-priormeandist)/(mymeandist+priormeandist);
<a name="l00831"></a>00831     }
<a name="l00832"></a>00832 
<a name="l00833"></a>00833         <span class="keywordflow">if</span> (verbosity&gt;2)
<a name="l00834"></a>00834         {
<a name="l00835"></a>00835                 cout &lt;&lt; <span class="stringliteral">&quot;finishEMlogL:\t&quot;</span>;
<a name="l00836"></a>00836                 cout &lt;&lt; clusters-&gt;log_likelihood &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00837"></a>00837                 cout &lt;&lt; log(static_cast&lt;double&gt;(numSamples))*max(0.0,low_covar_threshold-clusters-&gt;covar) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00838"></a>00838                 cout &lt;&lt; log(static_cast&lt;double&gt;(numSamples))*max(0.0,worstmeandist-expected_wingspan_ratio) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00839"></a>00839                 cout &lt;&lt; min(1.0,bestpriorfit) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00840"></a>00840                 cout &lt;&lt; 0.5*(2*k+2+k)*log(static_cast&lt;double&gt;(numSamples)) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00841"></a>00841                 cout &lt;&lt; endl;
<a name="l00842"></a>00842         }
<a name="l00843"></a>00843     <span class="comment">// log_likelihood is already sum(log(sum(pxi_zj,2))) ... %ll of data | gaussians</span>
<a name="l00844"></a>00844     clusters-&gt;log_likelihood = clusters-&gt;log_likelihood
<a name="l00845"></a>00845         - low_covar_penalty*log(static_cast&lt;double&gt;(numSamples))*(max(0.0,low_covar_threshold-clusters-&gt;covar))  <span class="comment">// ll of covariance</span>
<a name="l00846"></a>00846         - unbalanced_wingspan_penalty*k*log(static_cast&lt;double&gt;(numSamples))*(max(0.0,worstmeandist-expected_wingspan_ratio))  <span class="comment">//ll of mean distribution</span>
<a name="l00847"></a>00847         - wing_length_delta_penalty*min(1.0, bestpriorfit)  <span class="comment">// ll of prior</span>
<a name="l00848"></a>00848         - bic_weight*0.5*(2*k+2+k)*log(static_cast&lt;double&gt;(numSamples)); <span class="comment">// ll of model (BIC criterion)</span>
<a name="l00849"></a>00849     <span class="keywordflow">if</span> (tempmeandist &lt; 0) { <span class="comment">//make sure the distance between means is enough</span>
<a name="l00850"></a>00850         clusters-&gt;log_likelihood = clusters-&gt;log_likelihood+k*tempmeandist*lambda3*k*log(static_cast&lt;double&gt;(numSamples));
<a name="l00851"></a>00851         <span class="keywordflow">if</span> (verbosity&gt;3)
<a name="l00852"></a>00852         {
<a name="l00853"></a>00853                 cout &lt;&lt; <span class="stringliteral">&quot;tempmeandist&lt;0:\t&quot;</span>;
<a name="l00854"></a>00854                 cout &lt;&lt; k*tempmeandist*k*log(static_cast&lt;double&gt;(numSamples)) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00855"></a>00855                 cout &lt;&lt; endl;
<a name="l00856"></a>00856         }
<a name="l00857"></a>00857     }
<a name="l00858"></a>00858     <span class="keywordflow">if</span> (tempmeandist2&lt;cluster_distance_ratio_cutoff) { <span class="comment">// Make sure the order is correct (by a margin), or throw away:</span>
<a name="l00859"></a>00859         clusters-&gt;log_likelihood = -INFINITY;
<a name="l00860"></a>00860         <span class="keywordflow">if</span> (verbosity&gt;3)
<a name="l00861"></a>00861         {
<a name="l00862"></a>00862                 cout &lt;&lt; <span class="stringliteral">&quot;tempmeandist2&lt;cluster_distance_ratio_cutoff:\t-INFINITY&quot;</span> &lt;&lt; endl;
<a name="l00863"></a>00863         }
<a name="l00864"></a>00864     }
<a name="l00865"></a>00865     <span class="keywordflow">if</span> ((k==3) &amp;&amp; (minInVector(clusters-&gt;weights)&lt;small_cluster_weight_threshold)) {
<a name="l00866"></a>00866         clusters-&gt;log_likelihood = clusters-&gt;log_likelihood
<a name="l00867"></a>00867             - small_cluster_penalty*k*sqrt((small_cluster_weight_threshold-minInVector(clusters-&gt;weights)))*log(static_cast&lt;double&gt;(numSamples));
<a name="l00868"></a>00868         <span class="keywordflow">if</span> (verbosity&gt;3)
<a name="l00869"></a>00869         {
<a name="l00870"></a>00870                 cout &lt;&lt; <span class="stringliteral">&quot;Small_cluster_weight_threshold\t&quot;</span>;
<a name="l00871"></a>00871                 cout &lt;&lt; k*sqrt((small_cluster_weight_threshold-minInVector(clusters-&gt;weights)))*log(static_cast&lt;double&gt;(numSamples)) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
<a name="l00872"></a>00872                 cout &lt;&lt; endl;
<a name="l00873"></a>00873         }
<a name="l00874"></a>00874     }
<a name="l00875"></a>00875 }
<a name="l00876"></a>00876 
<a name="l00877"></a>00877 <span class="comment">// false return means stop E-M loop.</span>
<a name="l00878"></a>00878 <span class="keyword">static</span> <span class="keywordtype">bool</span> maximization(<a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> *clusters,
<a name="l00879"></a>00879                          <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities,
<a name="l00880"></a>00880                          <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors,
<a name="l00881"></a>00881                          <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> &amp;stdInterceptPrior,
<a name="l00882"></a>00882                          <span class="keywordtype">size_t</span> numSamples,
<a name="l00883"></a>00883                          <span class="keywordtype">size_t</span> k,
<a name="l00884"></a>00884                          <span class="keywordtype">size_t</span> iter)
<a name="l00885"></a>00885 {
<a name="l00886"></a>00886     <span class="comment">// Syntactic sugar</span>
<a name="l00887"></a>00887     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> &amp;means = clusters-&gt;means;
<a name="l00888"></a>00888 
<a name="l00889"></a>00889     <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> nj(clusters-&gt;pxi_zj.numCols());
<a name="l00890"></a>00890     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; clusters-&gt;pxi_zj.numCols(); ++col) {
<a name="l00891"></a>00891         nj[col] = sumColumn(clusters-&gt;pxi_zj, col);
<a name="l00892"></a>00892         clusters-&gt;weights[col] = nj[col] / numSamples;
<a name="l00893"></a>00893     }
<a name="l00894"></a>00894     <span class="keywordtype">double</span> minNJ = minInVector(nj);
<a name="l00895"></a>00895     <span class="keywordflow">if</span> ((minNJ &lt; epsilon &amp;&amp; iter &gt; 10) || (minNJ &lt; eps &amp;&amp; iter &gt; 1)) {
<a name="l00896"></a>00896         clusters-&gt;log_likelihood = -INFINITY;
<a name="l00897"></a>00897         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00898"></a>00898     }
<a name="l00899"></a>00899     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nj.size(); ++i) {
<a name="l00900"></a>00900         <span class="comment">// Floor to be at least smallest non-zero double.</span>
<a name="l00901"></a>00901         nj[i] = max(nj[i], numeric_limits&lt;double&gt;::epsilon());
<a name="l00902"></a>00902     }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904     <a class="code" href="classbirdseed_1_1dev_1_1VarVector.html">VarVector&lt;double&gt;</a> covs(k);
<a name="l00905"></a>00905 
<a name="l00906"></a>00906     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; k; ++j) {
<a name="l00907"></a>00907         <span class="comment">// means(j,:) = sum(repmat(pxi_zj(:,j),1,2).*dataVector) / nj(j);</span>
<a name="l00908"></a>00908         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; NUM_ALLELES; ++col) {
<a name="l00909"></a>00909             <span class="keywordtype">double</span> meanSum = 0;
<a name="l00910"></a>00910             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; intensities.numRows(); ++row) {
<a name="l00911"></a>00911                 meanSum += clusters-&gt;pxi_zj[row][j] * intensities[row][col];
<a name="l00912"></a>00912             }
<a name="l00913"></a>00913             means[j][col] = meanSum / nj[j];
<a name="l00914"></a>00914         }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916         <span class="comment">// vars(j,:) = 1/nj(j).*sum(repmat(pxi_zj(:,j),1,2) .* ((dataVector-repmat(means(j,:),n,1)).^2));</span>
<a name="l00917"></a>00917         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; NUM_ALLELES; ++col) {
<a name="l00918"></a>00918             <span class="keywordtype">double</span> varSum = 0;
<a name="l00919"></a>00919             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; intensities.numRows(); ++row) {
<a name="l00920"></a>00920                 varSum += clusters-&gt;pxi_zj[row][j] * ((intensities[row][col] - means[j][col]) * (intensities[row][col] - means[j][col]));
<a name="l00921"></a>00921             }
<a name="l00922"></a>00922             clusters-&gt;vars[j][col] = varSum/nj[j];
<a name="l00923"></a>00923         }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925         <span class="comment">// covs(j) = 1/nj(j).* (pxi_zj(:,j) .* (dataVector(:,1)-repmat(means(j,1),n,1)))&#39;*(dataVector(:,2)-repmat(means(j,2),n,1));</span>
<a name="l00926"></a>00926         <span class="keywordtype">double</span> covSum = 0;
<a name="l00927"></a>00927         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; intensities.numRows(); ++row) {
<a name="l00928"></a>00928             covSum += clusters-&gt;pxi_zj[row][j] *
<a name="l00929"></a>00929                 (intensities[row][0] - means[j][0]) *
<a name="l00930"></a>00930                 (intensities[row][1] - means[j][1]);
<a name="l00931"></a>00931         }
<a name="l00932"></a>00932         covs[j] = covSum / nj[j];
<a name="l00933"></a>00933     }
<a name="l00934"></a>00934     <span class="comment">// covar = min(0.95,max(min_covar,sum(nj&#39;.*covs&#39;./(eps+sqrt(vars(:,1).*vars(:,2))))/sum(nj)));</span>
<a name="l00935"></a>00935     clusters-&gt;covar = min(max_covar2,max(min_covar,
<a name="l00936"></a>00936                                        sumVector(nj.multiplyElementwise(covs).divideElementwise
<a name="l00937"></a>00937                                                  (sqrtVector(clusters-&gt;vars.columnSlice(0).multiplyElementwise(clusters-&gt;vars.columnSlice(1))) + eps))/
<a name="l00938"></a>00938                                        sumVector(nj)));
<a name="l00939"></a>00939 
<a name="l00940"></a>00940     <span class="keywordflow">if</span> ((iter&lt;=covar_floor_decay) &amp;&amp; (k==2 || k==3)) {
<a name="l00941"></a>00941         clusters-&gt;covar = max(max_covar1-(iter-1.0)/covar_floor_decay, clusters-&gt;covar);
<a name="l00942"></a>00942         clusters-&gt;log_likelihood = -INFINITY;
<a name="l00943"></a>00943     }
<a name="l00944"></a>00944 
<a name="l00945"></a>00945     <span class="comment">// make sure the means aren&#39;t too close</span>
<a name="l00946"></a>00946     <span class="comment">// if(max((sqrt(sum((means(2:k,:)-means(1:k-1,:)).^2,2))&#39;./sqrt(sum(means(2:k,:).^2))))&lt;merged_cluster_threshold)</span>
<a name="l00947"></a>00947     <span class="keywordtype">double</span> maxDistance = -INFINITY;
<a name="l00948"></a>00948     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; k; ++i) {
<a name="l00949"></a>00949         <span class="keywordtype">double</span> distance = sqrt(((means[i][0] - means[i-1][0]) * (means[i][0] - means[i-1][0])) + ((means[i][1] - means[i-1][1]) * (means[i][1] - means[i-1][1]))) /
<a name="l00950"></a>00950             sqrt((means[i][0] * means[i][0]) + (means[i][1] * means[i][1]));
<a name="l00951"></a>00951         maxDistance = max(maxDistance, distance);
<a name="l00952"></a>00952     }
<a name="l00953"></a>00953     <span class="keywordflow">if</span> (maxDistance &lt; merged_cluster_threshold) {
<a name="l00954"></a>00954         clusters-&gt;log_likelihood = -INFINITY;
<a name="l00955"></a>00955         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00956"></a>00956     }
<a name="l00957"></a>00957 
<a name="l00958"></a>00958     <span class="comment">// regularize the variances</span>
<a name="l00959"></a>00959     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; 2; ++d) {
<a name="l00960"></a>00960         <span class="comment">// vars(:,d) = nj&#39;./(nj&#39;+np).*vars(:,d) + ...</span>
<a name="l00961"></a>00961         <span class="comment">//        np./(nj&#39;+np).*((repmat(stdInterceptPrior(d),k,1)+std_slope*means(:,d)).^2); %regularization term 1</span>
<a name="l00962"></a>00962         <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> temp(nj.size());
<a name="l00963"></a>00963         temp = nj.divideElementwise(nj).multiplyElementwise(clusters-&gt;vars.columnSlice(d)); <span class="comment">// regularization term 1</span>
<a name="l00964"></a>00964         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; temp.size(); ++i) {
<a name="l00965"></a>00965             clusters-&gt;vars[i][d] = temp[i];
<a name="l00966"></a>00966         }
<a name="l00967"></a>00967     }
<a name="l00968"></a>00968 
<a name="l00969"></a>00969     <span class="comment">// how much variances are regularized to look like each other</span>
<a name="l00970"></a>00970     <span class="keywordtype">double</span> cluster_variance_regularization = cluster_variance_regularization_factor * intensities.numRows() * ((double(k-1)/k) * (<span class="keywordtype">double</span>(k-1)/k));
<a name="l00971"></a>00971 
<a name="l00972"></a>00972     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; 2; ++d) {
<a name="l00973"></a>00973         <span class="comment">// expectedvars = (mean(sqrt(vars(:,d))-std_slope*means(:,d)) +std_slope*means(:,d)).^2;</span>
<a name="l00974"></a>00974         <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> expectedvars(clusters-&gt;vars.numRows());
<a name="l00975"></a>00975 
<a name="l00976"></a>00976         expectedvars = powVector(clusters-&gt;means.columnSlice(d)*std_slope +
<a name="l00977"></a>00977                                  meanVector(sqrtVector(clusters-&gt;vars.columnSlice(d)) - clusters-&gt;means.columnSlice(d)*std_slope), 2);
<a name="l00978"></a>00978 
<a name="l00979"></a>00979         <span class="comment">// vars(:,d) = nj&#39;./(nj&#39;+np+cluster_variance_regularization).*vars(:,d) + ...</span>
<a name="l00980"></a>00980         <span class="comment">//    cluster_variance_regularization./(nj&#39;+np+cluster_variance_regularization).*expectedvars; %regularization term 2</span>
<a name="l00981"></a>00981         <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> temp(clusters-&gt;vars.numRows());
<a name="l00982"></a>00982         <a class="code" href="classbirdseed_1_1dev_1_1VarVectorWithReservedLength.html">VarVectorWithReservedLength&lt;double, MAX_NUM_CLUSTERS&gt;</a> temp2(nj.size());
<a name="l00983"></a>00983         temp2 = nj + cluster_variance_regularization;
<a name="l00984"></a>00984         temp = nj.divideElementwise(temp2).multiplyElementwise(clusters-&gt;vars.columnSlice(d)) +
<a name="l00985"></a>00985             temp2.divisor(cluster_variance_regularization).multiplyElementwise(expectedvars);
<a name="l00986"></a>00986         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; temp.size(); ++i) {
<a name="l00987"></a>00987             clusters-&gt;vars[i][d] = temp[i];
<a name="l00988"></a>00988         }
<a name="l00989"></a>00989     }
<a name="l00990"></a>00990     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00991"></a>00991 }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993 
<a name="l00994"></a>00994 <a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> birdseed::v1::FitSNPGaussianPriors3(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities, <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors)
<a name="l00995"></a>00995 {
<a name="l00996"></a>00996     <span class="keywordtype">size_t</span> numSamples = intensities.numRows();
<a name="l00997"></a>00997 
<a name="l00998"></a>00998     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">FixedVector&lt;double, NUM_ALLELES&gt;</a> stdInterceptPrior;
<a name="l00999"></a>00999     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; NUM_ALLELES; ++i) {
<a name="l01000"></a>01000         stdInterceptPrior[i] = computeStdInterceptPrior(priors, i);
<a name="l01001"></a>01001     }
<a name="l01002"></a>01002 
<a name="l01003"></a>01003     <span class="keyword">const</span> <span class="keywordtype">size_t</span> *numGaussians = (priors.isDiploid()? diploidNumGaussians: haploidNumGaussians);
<a name="l01004"></a>01004     <span class="keyword">const</span> <span class="keywordtype">size_t</span> lenNumGaussians = (priors.isDiploid()? lenDiploidNumGaussians: lenHaploidNumGaussians);
<a name="l01005"></a>01005 
<a name="l01006"></a>01006     <span class="comment">// It is required that we start with the 1 gaussian case</span>
<a name="l01007"></a>01007     assert(lenNumGaussians &gt; 0);
<a name="l01008"></a>01008     assert(numGaussians[0] == 1);
<a name="l01009"></a>01009     <a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> bestResult(1,1, 0);
<a name="l01010"></a>01010     <span class="keywordtype">size_t</span> bestpriormatch = monomorphicCluster(&amp;bestResult, intensities, priors, stdInterceptPrior);
<a name="l01011"></a>01011 
<a name="l01012"></a>01012     <span class="keywordflow">if</span> (verbosity &gt;= 2) {
<a name="l01013"></a>01013         cout &lt;&lt; <span class="stringliteral">&quot;oneGaussian result: &quot;</span> &lt;&lt; bestResult.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01014"></a>01014     }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016     <span class="comment">// Use k=1 case to estimate the variances for k=2 case</span>
<a name="l01017"></a>01017     <a class="code" href="classbirdseed_1_1dev_1_1VarMatrixWithReservedRows.html">VarMatrixWithReservedRows&lt;double, MAX_NUM_CLUSTERS, NUM_ALLELES&gt;</a> oldavgvars(bestResult.vars);
<a name="l01018"></a>01018 
<a name="l01019"></a>01019 
<a name="l01020"></a>01020     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> count = 1; count &lt; lenNumGaussians; ++count) {
<a name="l01021"></a>01021         <span class="keywordtype">size_t</span> k = numGaussians[count];
<a name="l01022"></a>01022         assert(k &gt; 1);
<a name="l01023"></a>01023 
<a name="l01024"></a>01024         <a class="code" href="classbirdseed_1_1dev_1_1Clusters.html">Clusters</a> clusters(intensities.numRows(), k, count);
<a name="l01025"></a>01025         initialize(&amp;clusters, k, count, intensities, priors, stdInterceptPrior, oldavgvars, bestpriormatch);
<a name="l01026"></a>01026 
<a name="l01027"></a>01027         <span class="comment">// EM loop:</span>
<a name="l01028"></a>01028         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> iter = 1; ; ++iter) {
<a name="l01029"></a>01029             <span class="keywordtype">double</span> old_log_likelihood = clusters.log_likelihood;
<a name="l01030"></a>01030             estimation(&amp;clusters, intensities, k);
<a name="l01031"></a>01031 
<a name="l01032"></a>01032             <span class="keywordflow">if</span> ((clusters.log_likelihood - old_log_likelihood &lt; epsilon) || (iter&gt;max_iter)) {
<a name="l01033"></a>01033                 <span class="keywordflow">if</span> (verbosity &gt;= 3) {
<a name="l01034"></a>01034                     cout &lt;&lt; <span class="stringliteral">&quot;Before finishEMLoop &quot;</span> &lt;&lt; <span class="stringliteral">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;; iter: &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; clusters.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01035"></a>01035                 }
<a name="l01036"></a>01036                 finishEMLoop(&amp;clusters, priors, k, numSamples);
<a name="l01037"></a>01037                 <span class="keywordflow">if</span> (verbosity &gt;= 3) {
<a name="l01038"></a>01038                     cout &lt;&lt; <span class="stringliteral">&quot;After finishEMLoop &quot;</span> &lt;&lt; <span class="stringliteral">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;; iter: &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; clusters.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01039"></a>01039                 }
<a name="l01040"></a>01040                 <span class="keywordflow">break</span>;
<a name="l01041"></a>01041             }
<a name="l01042"></a>01042             <span class="comment">// Normalize each row of pxi_zj so that each value is divided by the sum of values in that row</span>
<a name="l01043"></a>01043             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row = 0; row &lt; clusters.pxi_zj.numRows(); ++row) {
<a name="l01044"></a>01044                 <span class="keywordtype">double</span> rowSum = sumRow(clusters.pxi_zj, row);
<a name="l01045"></a>01045                 <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> col = 0; col &lt; clusters.pxi_zj.numCols(); ++col) {
<a name="l01046"></a>01046                     <span class="keywordflow">if</span> (rowSum &gt; 0) {
<a name="l01047"></a>01047                         clusters.pxi_zj[row][col] /= rowSum;
<a name="l01048"></a>01048                     } <span class="keywordflow">else</span> {
<a name="l01049"></a>01049                         clusters.pxi_zj[row][col] = 1.0 / k;
<a name="l01050"></a>01050                     }
<a name="l01051"></a>01051                 }
<a name="l01052"></a>01052             }
<a name="l01053"></a>01053             <span class="keywordflow">if</span> (verbosity &gt;= 3) {
<a name="l01054"></a>01054                 cout &lt;&lt; <span class="stringliteral">&quot;Before maximization &quot;</span> &lt;&lt; <span class="stringliteral">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;; iter: &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; clusters.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01055"></a>01055             }
<a name="l01056"></a>01056 
<a name="l01057"></a>01057             <span class="keywordflow">if</span> (!maximization(&amp;clusters, intensities, priors, stdInterceptPrior, numSamples, k, iter)) {
<a name="l01058"></a>01058                 <span class="keywordflow">break</span>;
<a name="l01059"></a>01059             }
<a name="l01060"></a>01060             <span class="keywordflow">if</span> (verbosity &gt;= 3) {
<a name="l01061"></a>01061                 cout &lt;&lt; <span class="stringliteral">&quot;After maximization &quot;</span> &lt;&lt; <span class="stringliteral">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;; iter: &quot;</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; clusters.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01062"></a>01062             }
<a name="l01063"></a>01063         }
<a name="l01064"></a>01064         <span class="keywordflow">if</span> (verbosity &gt;= 2) {
<a name="l01065"></a>01065             cout &lt;&lt; <span class="stringliteral">&quot;After iter loop count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; clusters.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01066"></a>01066         }
<a name="l01067"></a>01067         <span class="keywordflow">if</span> (clusters.log_likelihood &gt; bestResult.log_likelihood) {
<a name="l01068"></a>01068             bestResult = clusters;
<a name="l01069"></a>01069         }
<a name="l01070"></a>01070     }
<a name="l01071"></a>01071     <span class="keywordflow">if</span> (verbosity &gt;= 2) {
<a name="l01072"></a>01072         cout &lt;&lt; <span class="stringliteral">&quot;final result: &quot;</span> &lt;&lt; bestResult.tostring() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01073"></a>01073     }
<a name="l01074"></a>01074 
<a name="l01075"></a>01075     <span class="comment">// This is no longer necessary so delete it.</span>
<a name="l01076"></a>01076     bestResult.pxi_zj.resizeRows(0);
<a name="l01077"></a>01077 
<a name="l01078"></a>01078     <span class="keywordflow">return</span> bestResult;
<a name="l01079"></a>01079 }
<a name="l01080"></a>01080 
<a name="l01081"></a>01081 <span class="keywordtype">double</span> birdseed::v1::calculateSNPSpecificCorrectionFactor(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1VarMatrix.html">IntensityMatrix</a> &amp;intensities,
<a name="l01082"></a>01082                                                       <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1Priors.html">Priors</a> &amp;priors)
<a name="l01083"></a>01083 {
<a name="l01084"></a>01084     <span class="comment">// This could be done in a for loop to avoid memory allocation</span>
<a name="l01085"></a>01085     <span class="keywordtype">double</span> numerator = meanVector(sqrtVector(powVector(intensities.columnSlice(0), 2) + powVector(intensities.columnSlice(1), 2)));
<a name="l01086"></a>01086     <span class="keywordtype">double</span> denominator = 0.0;
<a name="l01087"></a>01087     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; priors.getNumPriors(); ++i) {
<a name="l01088"></a>01088         <span class="keywordtype">double</span> mean0 = priors.getPrior(i).m_mean[0];
<a name="l01089"></a>01089         <span class="keywordtype">double</span> mean1 = priors.getPrior(i).m_mean[1];
<a name="l01090"></a>01090         denominator += sqrt((mean0 * mean0) + (mean1 * mean1));
<a name="l01091"></a>01091     }
<a name="l01092"></a>01092     denominator /= priors.getNumPriors();
<a name="l01093"></a>01093     <span class="keywordflow">return</span> numerator / denominator;
<a name="l01094"></a>01094 }
<a name="l01095"></a>01095 
<a name="l01096"></a>01096 <span class="keywordtype">double</span> birdseed::v1::calculateConfidenceRelativeToCluster(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> &amp;B,
<a name="l01097"></a>01097                                                       <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">IntensityMatrix::ROW</a> &amp;intensities,
<a name="l01098"></a>01098                                                       <span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">IntensityMatrix::ROW</a> &amp;clusterMean)
<a name="l01099"></a>01099 {
<a name="l01100"></a>01100     <span class="keyword">static</span> <span class="keywordtype">double</span> exp_stdInflectionPoint = -1.0;
<a name="l01101"></a>01101     <span class="keywordflow">if</span> (exp_stdInflectionPoint &lt; 0) {
<a name="l01102"></a>01102         exp_stdInflectionPoint = exp(std_inflection_point);
<a name="l01103"></a>01103     }
<a name="l01104"></a>01104     <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">IntensityMatrix::ROW</a> <a class="code" href="snp_8label_8cpp.html#ad748ef26c031cf6086e3a490afd3a47f" title="difference in cumulative sums: i.e.">delta</a> = intensities - clusterMean;
<a name="l01105"></a>01105     <span class="keywordtype">double</span> stdDist = sqrt((delta * B * delta)/2);
<a name="l01106"></a>01106     <span class="keywordtype">double</span> confidenceRelativeToCluster = 1/(1+exp(std_inflection_point-stdDist)) -
<a name="l01107"></a>01107         1/(1+exp_stdInflectionPoint);
<a name="l01108"></a>01108     <span class="keywordflow">return</span> confidenceRelativeToCluster;
<a name="l01109"></a>01109 }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111 <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> birdseed::v1::makeBMatrix(<span class="keyword">const</span> <a class="code" href="classbirdseed_1_1dev_1_1FixedVector.html">Matrix2x2::ROW</a> &amp;clusterVars, <span class="keywordtype">double</span> covar)
<a name="l01112"></a>01112 {
<a name="l01113"></a>01113     <a class="code" href="classbirdseed_1_1dev_1_1FixedMatrix.html">Matrix2x2</a> varmat;
<a name="l01114"></a>01114     varmat[0][0] = clusterVars[0];
<a name="l01115"></a>01115     varmat[1][0] = varmat[0][1] = covar * sqrt(clusterVars[0]*clusterVars[1]);
<a name="l01116"></a>01116     varmat[1][1] = clusterVars[1];
<a name="l01117"></a>01117     <span class="keywordflow">return</span> invert(varmat);
<a name="l01118"></a>01118 }
<a name="l01119"></a>01119 
<a name="l01120"></a>01120 <span class="comment">/******************************************************************/</span>
<a name="l01121"></a>01121 <span class="comment">/**************************[END OF FitSNPGaussiansPriors3.cpp]*************************/</span>
<a name="l01122"></a>01122 <span class="comment">/******************************************************************/</span>
<a name="l01123"></a>01123 
<a name="l01124"></a>01124 <span class="comment">/* Emacs configuration</span>
<a name="l01125"></a>01125 <span class="comment"> * Local Variables:</span>
<a name="l01126"></a>01126 <span class="comment"> * mode: C++</span>
<a name="l01127"></a>01127 <span class="comment"> * tab-width:4</span>
<a name="l01128"></a>01128 <span class="comment"> * End:</span>
<a name="l01129"></a>01129 <span class="comment"> */</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2016 12:58:38 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
