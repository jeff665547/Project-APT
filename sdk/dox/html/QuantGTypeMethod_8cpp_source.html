<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: chipstream/QuantGTypeMethod.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_fa2ccd765111060c049013d9614ef4eb.html">chipstream</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>QuantGTypeMethod.cpp</h1>  </div>
</div>
<div class="contents">
<a href="QuantGTypeMethod_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00002"></a>00002 <span class="comment"></span><span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// Copyright (C) 2005 Affymetrix, Inc.</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// This program is free software; you can redistribute it and/or modify </span>
<a name="l00006"></a>00006 <span class="comment">// it under the terms of the GNU General Public License (version 2) as </span>
<a name="l00007"></a>00007 <span class="comment">// published by the Free Software Foundation.</span>
<a name="l00008"></a>00008 <span class="comment">// </span>
<a name="l00009"></a>00009 <span class="comment">// This program is distributed in the hope that it will be useful, </span>
<a name="l00010"></a>00010 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<a name="l00011"></a>00011 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU </span>
<a name="l00012"></a>00012 <span class="comment">// General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment">// </span>
<a name="l00014"></a>00014 <span class="comment">// You should have received a copy of the GNU General Public License </span>
<a name="l00015"></a>00015 <span class="comment">// along with this program;if not, write to the </span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// Free Software Foundation, Inc., </span>
<a name="l00018"></a>00018 <span class="comment">// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00019"></a>00019 <span class="comment">//</span><span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00021"></a>00021 <span class="comment"></span><span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">/**</span>
<a name="l00023"></a>00023 <span class="comment"> * @file   QuantGTypeMethod.cpp</span>
<a name="l00024"></a>00024 <span class="comment"> * @author Earl Hubbell</span>
<a name="l00025"></a>00025 <span class="comment"> * @date   Fri Feb 24 11:02:09 2006</span>
<a name="l00026"></a>00026 <span class="comment"> *</span>
<a name="l00027"></a>00027 <span class="comment"> *  Placeholder: should isolate genotyping probe set summary functions</span>
<a name="l00028"></a>00028 <span class="comment"> *</span>
<a name="l00029"></a>00029 <span class="comment"> */</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="comment">//</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="QuantMethodFactory_8h.html" title="Factory class for making chip streams based on a string representation.">chipstream/QuantMethodFactory.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="comment">//</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="TsvFile_8h.html" title="Headers for the TsvFile classes.">file/TsvFile/TsvFile.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="Convert_8h.html" title="Utility functions for converting between types.">util/Convert.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;<a class="code" href="Util_8h.html" title="General Utilities.">util/Util.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;<a class="code" href="Verbose_8h.html" title="Class for doing logging and some command line ui.">util/Verbose.h</a>&quot;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="keyword">using namespace </span>affx;
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 QuantGTypeMethod::~QuantGTypeMethod() {}
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">/** </span>
<a name="l00044"></a>00044 <span class="comment"> * Get the genotype call at specified index (sample).</span>
<a name="l00045"></a>00045 <span class="comment"> * @param index - sample of interest.</span>
<a name="l00046"></a>00046 <span class="comment"> * @return - Genotyping call made.</span>
<a name="l00047"></a>00047 <span class="comment"> */</span>
<a name="l00048"></a>00048 
<a name="l00049"></a><a class="code" href="classQuantGTypeMethod.html#a4ef68832da9ea1ac365a098d2e47bf3d">00049</a> affx::GType <a class="code" href="classQuantGTypeMethod.html#a4ef68832da9ea1ac365a098d2e47bf3d" title="Get the genotype call at specified index (sample).">QuantGTypeMethod::getGTypeCall</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index) {
<a name="l00050"></a>00050   affx::GType call = getGTypeForcedCall(index);
<a name="l00051"></a>00051   <span class="keywordtype">double</span> conf = <a class="code" href="classQuantGTypeMethod.html#a0d242123ad6e0bfd6934d0ef0c0073cc" title="Get our confidence value for a particular call in a particular sample.">getConfidence</a>(index);
<a name="l00052"></a>00052   <span class="keywordflow">if</span>((conf &gt;= <a class="code" href="classQuantGTypeMethod.html#af73b280fce51d3e4e324993356ceb543" title="Get the min value for a call.">getMinThresh</a>()) &amp;&amp; (conf &lt;= <a class="code" href="classQuantGTypeMethod.html#abe1ebe82ba24b2a97130c0d8d7d9e4ce" title="Get the max value for a call.">getMaxThresh</a>()))
<a name="l00053"></a>00053     <span class="keywordflow">return</span> call;
<a name="l00054"></a>00054   <span class="keywordflow">else</span>
<a name="l00055"></a>00055     <span class="keywordflow">return</span> affx::NN;
<a name="l00056"></a>00056 }
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 affx::GType QuantGTypeMethod::getGTypeForcedCall(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index) {
<a name="l00059"></a>00059   <span class="keywordflow">if</span>(index &gt;= m_Calls.size()) {
<a name="l00060"></a>00060     <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;Asking for call at index &quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(index) + <span class="stringliteral">&quot; when Probeset &quot;</span> + 
<a name="l00061"></a>00061                   <a class="code" href="classQuantGTypeMethod.html#ab4ce64f2ef8bc3ec6d554fa0c1f13212" title="Name of current probeset.">m_ProbesetName</a> + <span class="stringliteral">&quot; has only &quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(m_Calls.size()) + <span class="stringliteral">&quot; calls.&quot;</span>);
<a name="l00062"></a>00062   }
<a name="l00063"></a>00063   <span class="keywordflow">return</span> m_Calls[index];
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 <span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">/** </span>
<a name="l00067"></a>00067 <span class="comment"> * Get the genotype call at specified index (sample).</span>
<a name="l00068"></a>00068 <span class="comment"> * @param index - sample of interest.</span>
<a name="l00069"></a>00069 <span class="comment"> * @return - Genotyping call made.</span>
<a name="l00070"></a>00070 <span class="comment"> */</span>
<a name="l00071"></a>00071 
<a name="l00072"></a><a class="code" href="classQuantGTypeMethod.html#a5b5d32b6fe0f304307834f9d633391c5">00072</a> <span class="keywordtype">int</span> <a class="code" href="classQuantGTypeMethod.html#a5b5d32b6fe0f304307834f9d633391c5" title="Get the genotype call at specified index (sample).">QuantGTypeMethod::getForcedCall</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index) {
<a name="l00073"></a>00073   <span class="keywordflow">return</span> <a class="code" href="namespaceaffx.html#ac9e9039b462ebd2bec646ed4c5ff1122" title="Convert a GType enum to an external integer value ///.">affx::GType_to_int</a>(getGTypeForcedCall(index));
<a name="l00074"></a>00074 }
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">/** </span>
<a name="l00077"></a>00077 <span class="comment"> * Get the genotype call at specified index (sample).</span>
<a name="l00078"></a>00078 <span class="comment"> * @param index - sample of interest.</span>
<a name="l00079"></a>00079 <span class="comment"> * @return - Genotyping call made.</span>
<a name="l00080"></a>00080 <span class="comment"> */</span>
<a name="l00081"></a>00081 
<a name="l00082"></a><a class="code" href="classQuantGTypeMethod.html#a927281a63e8b749027c68a261604cdb8">00082</a> <span class="keywordtype">int</span> <a class="code" href="classQuantGTypeMethod.html#a927281a63e8b749027c68a261604cdb8" title="Get the genotype call at specified index (sample).">QuantGTypeMethod::getCall</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index) {
<a name="l00083"></a>00083   <span class="keywordflow">return</span> <a class="code" href="namespaceaffx.html#ac9e9039b462ebd2bec646ed4c5ff1122" title="Convert a GType enum to an external integer value ///.">affx::GType_to_int</a>(<a class="code" href="classQuantGTypeMethod.html#a4ef68832da9ea1ac365a098d2e47bf3d" title="Get the genotype call at specified index (sample).">getGTypeCall</a>(index));
<a name="l00084"></a>00084 }
<a name="l00085"></a>00085 <span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">/** </span>
<a name="l00087"></a>00087 <span class="comment"> * Get a string representation for a particular SNP.</span>
<a name="l00088"></a>00088 <span class="comment"> * @return - a string version of a SNP</span>
<a name="l00089"></a>00089 <span class="comment"> */</span>
<a name="l00090"></a><a class="code" href="classQuantGTypeMethod.html#ae425c2a925d20d056242d74e10a2e282">00090</a> std::string <a class="code" href="classQuantGTypeMethod.html#ae425c2a925d20d056242d74e10a2e282" title="Get a string representation for a particular SNP.">QuantGTypeMethod::getModelString</a>() {
<a name="l00091"></a>00091   <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 <span class="comment"></span>
<a name="l00094"></a>00094 <span class="comment">/** summarize this allele - no reports */</span>
<a name="l00095"></a><a class="code" href="classQuantGTypeMethod.html#a85f2f697bc57efc1385c4c00b8cee5bf">00095</a> <span class="keywordtype">bool</span> <a class="code" href="classQuantGTypeMethod.html#a6561033a69acb59e1b6ac76976f80561" title="summarize this allele">QuantGTypeMethod::summarizeAllele</a>(<a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> *pSet,
<a name="l00096"></a>00096                                        std::vector&lt;double&gt; &amp;summaryValues,
<a name="l00097"></a>00097                                        <span class="keyword">const</span> <a class="code" href="classIntensityMart.html" title="IntensityMart.">IntensityMart</a> &amp;iMart,
<a name="l00098"></a>00098                                        std::vector&lt;ChipStream *&gt; &amp;iTrans, 
<a name="l00099"></a>00099                                        <a class="code" href="classPmAdjuster.html" title="Interface for determining a change based on intensity of perfect match.">PmAdjuster</a> &amp;pmAdjust, 
<a name="l00100"></a>00100                                        <a class="code" href="classQuantExprMethod.html" title="QuantExprMethod - Interface for computing quantification summaries from PM intensities grouped into p...">QuantExprMethod</a> *quantMethod,
<a name="l00101"></a>00101                                        <span class="keywordtype">bool</span> lowPrecision) {
<a name="l00102"></a>00102   std::vector&lt;QuantMethodReport *&gt; nullReporters;
<a name="l00103"></a>00103   <span class="keywordflow">return</span> <a class="code" href="classQuantGTypeMethod.html#a6561033a69acb59e1b6ac76976f80561" title="summarize this allele">summarizeAllele</a>(pSet, summaryValues, iMart, iTrans, 
<a name="l00104"></a>00104                          pmAdjust, quantMethod, lowPrecision, 
<a name="l00105"></a>00105                          <span class="keyword">false</span>, nullReporters);
<a name="l00106"></a>00106 }
<a name="l00107"></a>00107 <span class="comment"></span>
<a name="l00108"></a>00108 <span class="comment">/** clear a probeset structure */</span>
<a name="l00109"></a><a class="code" href="classQuantGTypeMethod.html#aff29fdf8763f00f5e1eb451162cb38c2">00109</a> <span class="keywordtype">void</span> <a class="code" href="classQuantGTypeMethod.html#aff29fdf8763f00f5e1eb451162cb38c2" title="clear a probe set">QuantGTypeMethod::clearProbeSet</a>(<a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> &amp;ps) {
<a name="l00110"></a>00110     <span class="keyword">delete</span> [] ps.<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a>;
<a name="l00111"></a>00111     ps.<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a> = NULL;
<a name="l00112"></a>00112     ps.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.clear();
<a name="l00113"></a>00113 };
<a name="l00114"></a>00114 <span class="comment"></span>
<a name="l00115"></a>00115 <span class="comment">/** summarize an allele using expression summary methods specified*/</span>
<a name="l00116"></a><a class="code" href="classQuantGTypeMethod.html#a6561033a69acb59e1b6ac76976f80561">00116</a> <span class="keywordtype">bool</span> <a class="code" href="classQuantGTypeMethod.html#a6561033a69acb59e1b6ac76976f80561" title="summarize this allele">QuantGTypeMethod::summarizeAllele</a>(<a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> *pSet,
<a name="l00117"></a>00117                      vector&lt;double&gt; &amp;summaryValues,
<a name="l00118"></a>00118                      <span class="keyword">const</span> <a class="code" href="classIntensityMart.html" title="IntensityMart.">IntensityMart</a> &amp;iMart,
<a name="l00119"></a>00119                      std::vector&lt;ChipStream *&gt; &amp;iTrans,
<a name="l00120"></a>00120                      <a class="code" href="classPmAdjuster.html" title="Interface for determining a change based on intensity of perfect match.">PmAdjuster</a> &amp;pmAdjust,
<a name="l00121"></a>00121                      <a class="code" href="classQuantExprMethod.html" title="QuantExprMethod - Interface for computing quantification summaries from PM intensities grouped into p...">QuantExprMethod</a> *quantMethod,
<a name="l00122"></a>00122                      <span class="keywordtype">bool</span> lowPrecision,
<a name="l00123"></a>00123                      <span class="keywordtype">bool</span> doReport,
<a name="l00124"></a>00124                      std::vector&lt;QuantMethodReport *&gt; reporters) {
<a name="l00125"></a>00125   <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;
<a name="l00126"></a>00126   summaryValues.clear();
<a name="l00127"></a>00127   <span class="comment">/* This is a little interesting as we are spoofing a probeSetGroup for calling</span>
<a name="l00128"></a>00128 <span class="comment">     functions but don&#39;t want the destructor called while that group thinks it</span>
<a name="l00129"></a>00129 <span class="comment">     owns those probesets. */</span>
<a name="l00130"></a>00130   <a class="code" href="classProbeSetGroup.html" title="Group of probe sets that should be processed as a single large probe set.">ProbeSetGroup</a> group(pSet);
<a name="l00131"></a>00131   <span class="keywordflow">if</span>(!quantMethod-&gt;<a class="code" href="classQuantMethod.html#ab238f90e423b5ac3026d088b9964d83f" title="Set up the quantification method given all the data about the probe set, chip layout and data...">setUp</a>(group, iMart, iTrans, pmAdjust))
<a name="l00132"></a>00132     success = <span class="keyword">false</span>;
<a name="l00133"></a>00133   <span class="keywordflow">else</span> {
<a name="l00134"></a>00134     quantMethod-&gt;<a class="code" href="classQuantMethod.html#ad395fca27a92995b08ecefd71cf87b38" title="Do the heavy lifting of estimation.">computeEstimate</a>();
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; quantMethod-&gt;<a class="code" href="classQuantExprMethod.html#ac2900783138ce00c4712bd634c72fbd2" title="Return number of targets (experiments or chips).">getNumTargets</a>(); i++) {
<a name="l00137"></a>00137       <span class="keywordtype">double</span> val = quantMethod-&gt;<a class="code" href="classQuantExprMethod.html#a52010be442a430f736cba07f21c52462" title="Get the estimated intensity for a chip.">getTargetEffect</a>(i);
<a name="l00138"></a>00138       <span class="keywordflow">if</span>(lowPrecision) {
<a name="l00139"></a>00139         val = <a class="code" href="DM_8cpp.html#a88ba7496aba146eabdf9e03f74ab23aa" title="Round the double and return it.">Util::round</a>(val);
<a name="l00140"></a>00140       }
<a name="l00141"></a>00141       summaryValues.push_back(val);
<a name="l00142"></a>00142     }
<a name="l00143"></a>00143     success = <span class="keyword">true</span>;
<a name="l00144"></a>00144   }
<a name="l00145"></a>00145   <span class="comment">/* print out a report if necessary. */</span>
<a name="l00146"></a>00146   <span class="keywordflow">if</span>(success &amp;&amp; doReport) {
<a name="l00147"></a>00147     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; reporters.size(); i++) {
<a name="l00148"></a>00148       reporters[i]-&gt;report(group, *quantMethod, iMart, iTrans, pmAdjust);
<a name="l00149"></a>00149     }
<a name="l00150"></a>00150   }
<a name="l00151"></a>00151   <span class="comment">/* clear out probesets to prevent deleting them. */</span>
<a name="l00152"></a>00152   group.<a class="code" href="classProbeSetGroup.html#aa197d2e48f3c2e8ae67cc8f5d54735ac" title="Vector of probe set pointers.">probeSets</a>.clear();
<a name="l00153"></a>00153   <a class="code" href="classQuantGTypeMethod.html#aff29fdf8763f00f5e1eb451162cb38c2" title="clear a probe set">clearProbeSet</a>(*pSet);
<a name="l00154"></a>00154   <span class="keywordflow">return</span> success;
<a name="l00155"></a>00155 }
<a name="l00156"></a>00156 <span class="comment"></span>
<a name="l00157"></a>00157 <span class="comment">/** fill in both probe sets with intensities for both alleles */</span>
<a name="l00158"></a><a class="code" href="classQuantGTypeMethod.html#a1a853c2d2821e9c4930fb5c3807f36f9">00158</a> <span class="keywordtype">bool</span> <a class="code" href="classQuantGTypeMethod.html#a1a853c2d2821e9c4930fb5c3807f36f9" title="fill in the probe set with the allele values">QuantGTypeMethod::fillInAlleleProbeSets</a>(<span class="keyword">const</span> <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> &amp;gtPs, <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> &amp;aAllele, <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> &amp;bAllele) {
<a name="l00159"></a>00159   <span class="comment">/* First set up the probe sets to do the summarization of a and b alleles. */</span>
<a name="l00160"></a>00160   aAllele.<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> = ProbeSet::Expression;
<a name="l00161"></a>00161   bAllele.<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> = ProbeSet::Expression;
<a name="l00162"></a>00162   <span class="comment">// Set the names for our spoofed probesets with suffix A and B</span>
<a name="l00163"></a>00163   <span class="keywordtype">string</span> name = gtPs.<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a>;
<a name="l00164"></a>00164   <span class="keywordflow">if</span> (gtPs.<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> == ProbeSet::Copynumber)
<a name="l00165"></a>00165   {
<a name="l00166"></a>00166                 aAllele.<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a> = <a class="code" href="classUtil.html#a508b7aff9569ed929945d0d37eca384e" title="Create a copy of a string.">Util::cloneString</a>(name.c_str());
<a name="l00167"></a>00167                 <span class="keywordtype">int</span> groupOffset = 0; <span class="comment">// atoms are stored in blocks for each allele, keep track of which block we&#39;re in.</span>
<a name="l00168"></a>00168                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> groupIx = 0; groupIx &lt; gtPs.<a class="code" href="classProbeSet.html#a6d8ed948634c42033bd0c35d2640b274" title="How many groups (or blocks) are there? Used extensively in genotyping chips.">numGroups</a>; groupIx++) 
<a name="l00169"></a>00169                 {
<a name="l00170"></a>00170                         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> atomIx = groupOffset; atomIx &lt; gtPs.<a class="code" href="classProbeSet.html#a23b9df97be8aacc01ad21642b8c966b9" title="Number of atoms in each group, used to get the offsets into the atoms vector.">atomsPerGroup</a>[groupIx] + groupOffset; atomIx++) 
<a name="l00171"></a>00171                         {
<a name="l00172"></a>00172                                 aAllele.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.push_back(gtPs.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[atomIx]);
<a name="l00173"></a>00173                         }
<a name="l00174"></a>00174                         groupOffset += gtPs.<a class="code" href="classProbeSet.html#a23b9df97be8aacc01ad21642b8c966b9" title="Number of atoms in each group, used to get the offsets into the atoms vector.">atomsPerGroup</a>[groupIx];
<a name="l00175"></a>00175                 }
<a name="l00176"></a>00176   }
<a name="l00177"></a>00177   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gtPs.<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> == ProbeSet::GenoType || gtPs.<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> == ProbeSet::Marker || gtPs.<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> == ProbeSet::MultichannelMarker)
<a name="l00178"></a>00178   {
<a name="l00179"></a>00179           name += <span class="stringliteral">&quot;-A&quot;</span>;
<a name="l00180"></a>00180           aAllele.<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a> = <a class="code" href="classUtil.html#a508b7aff9569ed929945d0d37eca384e" title="Create a copy of a string.">Util::cloneString</a>(name.c_str());
<a name="l00181"></a>00181           name = gtPs.<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a>;
<a name="l00182"></a>00182           name += <span class="stringliteral">&quot;-B&quot;</span>;
<a name="l00183"></a>00183           bAllele.<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a> = <a class="code" href="classUtil.html#a508b7aff9569ed929945d0d37eca384e" title="Create a copy of a string.">Util::cloneString</a>(name.c_str());
<a name="l00184"></a>00184           <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a>* alleleToGetAtom = NULL;
<a name="l00185"></a>00185           <span class="keywordtype">int</span> groupOffset = 0; <span class="comment">// atoms are stored in blocks for each allele, keep track of which block we&#39;re in.</span>
<a name="l00186"></a>00186           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> groupIx = 0; groupIx &lt; gtPs.<a class="code" href="classProbeSet.html#a6d8ed948634c42033bd0c35d2640b274" title="How many groups (or blocks) are there? Used extensively in genotyping chips.">numGroups</a>; groupIx++) {
<a name="l00187"></a>00187             <span class="comment">/* Probe belongs to the A allele, put atoms in that probeset. */</span>
<a name="l00188"></a>00188             <span class="keywordflow">if</span> (gtPs.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[groupIx]-&gt;getAlleleCode() == 0) {
<a name="l00189"></a>00189               alleleToGetAtom = &amp;aAllele;
<a name="l00190"></a>00190             }
<a name="l00191"></a>00191             <span class="comment">/* Probe belongs to the B allele, put atoms in that probeset. */</span>
<a name="l00192"></a>00192             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gtPs.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[groupIx]-&gt;getAlleleCode() == 1) {
<a name="l00193"></a>00193               alleleToGetAtom = &amp;bAllele;
<a name="l00194"></a>00194             }
<a name="l00195"></a>00195             <span class="comment">/* Uh-oh, if it doesn&#39;t belong to A and it doesn&#39;t belong to B we&#39;re going to complain. */</span>
<a name="l00196"></a>00196             <span class="keywordflow">else</span> {
<a name="l00197"></a>00197               <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00198"></a>00198             }
<a name="l00199"></a>00199 
<a name="l00200"></a>00200             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> atomIx = groupOffset; atomIx &lt; gtPs.<a class="code" href="classProbeSet.html#a23b9df97be8aacc01ad21642b8c966b9" title="Number of atoms in each group, used to get the offsets into the atoms vector.">atomsPerGroup</a>[groupIx] + groupOffset; atomIx++) {
<a name="l00201"></a>00201               alleleToGetAtom-&gt;<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.push_back(gtPs.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[atomIx]);
<a name="l00202"></a>00202             }
<a name="l00203"></a>00203             groupOffset += gtPs.<a class="code" href="classProbeSet.html#a23b9df97be8aacc01ad21642b8c966b9" title="Number of atoms in each group, used to get the offsets into the atoms vector.">atomsPerGroup</a>[groupIx];
<a name="l00204"></a>00204           }
<a name="l00205"></a>00205   }
<a name="l00206"></a>00206   <span class="keywordflow">else</span> {
<a name="l00207"></a>00207       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00208"></a>00208   }
<a name="l00209"></a>00209   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00210"></a>00210 }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="comment"></span>
<a name="l00213"></a>00213 <span class="comment">/** extract the probes for an allele specified*/</span>
<a name="l00214"></a><a class="code" href="classQuantGTypeMethod.html#ab62a74a7fc8feaaff51d96496b041be9">00214</a> <span class="keywordtype">bool</span> <a class="code" href="classQuantGTypeMethod.html#ab62a74a7fc8feaaff51d96496b041be9" title="extract the probes for an allele specified">QuantGTypeMethod::extractProbes</a>(vector &lt;vector &lt;double&gt; &gt; &amp;probeIntensity,
<a name="l00215"></a>00215                    <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> *pSet,
<a name="l00216"></a>00216                    vector&lt; unsigned int &gt; &amp;probeIds,
<a name="l00217"></a>00217                    <span class="keyword">const</span> <a class="code" href="classIntensityMart.html" title="IntensityMart.">IntensityMart</a> &amp;iMart, std::vector&lt;ChipStream *&gt; &amp;iTrans,
<a name="l00218"></a>00218                    <a class="code" href="classPmAdjuster.html" title="Interface for determining a change based on intensity of perfect match.">PmAdjuster</a> &amp;pmAdjust, <span class="keywordtype">bool</span> lowPrecision,
<a name="l00219"></a>00219                    <a class="code" href="classQuantExprMethod.html" title="QuantExprMethod - Interface for computing quantification summaries from PM intensities grouped into p...">QuantExprMethod</a> *quantMethod) {
<a name="l00220"></a>00220   <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;
<a name="l00221"></a>00221   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i,j,NTarg,NFeat;
<a name="l00222"></a>00222   <span class="keywordtype">double</span> val;
<a name="l00223"></a>00223   <span class="comment">/* This is a little interesting as we are spoofing a probeSetGroup for calling</span>
<a name="l00224"></a>00224 <span class="comment">     functions but don&#39;t want the destructor called while that group thinks it</span>
<a name="l00225"></a>00225 <span class="comment">     owns those probesets. */</span>
<a name="l00226"></a>00226   <a class="code" href="classProbeSetGroup.html" title="Group of probe sets that should be processed as a single large probe set.">ProbeSetGroup</a> group(pSet);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228   <span class="keywordflow">if</span>(!quantMethod-&gt;<a class="code" href="classQuantMethod.html#ab238f90e423b5ac3026d088b9964d83f" title="Set up the quantification method given all the data about the probe set, chip layout and data...">setUp</a>(group, iMart, iTrans, pmAdjust))
<a name="l00229"></a>00229     success = <span class="keyword">false</span>;
<a name="l00230"></a>00230   <span class="keywordflow">else</span> {
<a name="l00231"></a>00231     NTarg = quantMethod-&gt;<a class="code" href="classQuantExprMethod.html#ac2900783138ce00c4712bd634c72fbd2" title="Return number of targets (experiments or chips).">getNumTargets</a>();
<a name="l00232"></a>00232     NFeat = quantMethod-&gt;<a class="code" href="classQuantExprMethod.html#a55ebf5772f4ecb39139ae92657e41437" title="Return number of features (probes).">getNumFeatures</a>();
<a name="l00233"></a>00233 <span class="comment"></span>
<a name="l00234"></a>00234 <span class="comment">    ///@todo need to populate probe IDs</span>
<a name="l00235"></a>00235 <span class="comment"></span>    probeIds.assign(NFeat,0);
<a name="l00236"></a>00236 
<a name="l00237"></a>00237     probeIntensity.clear(); <span class="comment">// empty the register</span>
<a name="l00238"></a>00238     <span class="comment">// organize this by probe across experiments</span>
<a name="l00239"></a>00239     <span class="comment">// because that&#39;s how we&#39;ll use this.</span>
<a name="l00240"></a>00240     <span class="keywordflow">if</span>(probeIntensity.empty()) {
<a name="l00241"></a>00241       <span class="keywordflow">while</span>(probeIntensity.size() &lt; NFeat) {
<a name="l00242"></a>00242         probeIntensity.push_back(vector&lt;double&gt;(NTarg));
<a name="l00243"></a>00243       }
<a name="l00244"></a>00244     }
<a name="l00245"></a>00245     <span class="keywordflow">for</span>(i = 0; i &lt; NTarg; i++) {
<a name="l00246"></a>00246       <span class="keywordflow">for</span> (j=0; j&lt;NFeat; j++) {
<a name="l00247"></a>00247         val = quantMethod-&gt;<a class="code" href="classQuantExprMethod.html#a1c2bb03874f5a507f5fc4ab15f9cc47a" title="Get the PM data at probe set probe index and chip index.">getPMDataAt</a>(j,i);
<a name="l00248"></a>00248         <span class="keywordflow">if</span>(lowPrecision)
<a name="l00249"></a>00249           val = <a class="code" href="DM_8cpp.html#a88ba7496aba146eabdf9e03f74ab23aa" title="Round the double and return it.">Util::round</a>(val);
<a name="l00250"></a>00250         probeIntensity[j][i] = val;
<a name="l00251"></a>00251         <span class="keyword">const</span> <a class="code" href="classProbe.html" title="Represents an individual feature on a chip.">Probe</a> *p = quantMethod-&gt;<a class="code" href="classQuantExprMethod.html#aa93c8bf54a865ffd158c5b67fde7b375" title="Get the Probe for a particular index in the probe set.">getFeature</a>(j);
<a name="l00252"></a>00252         probeIds[j] = p-&gt;<a class="code" href="classProbe.html#a839c453922e807335dc6f4b385ed456c" title="Id of probe, in practice usually realated to position on array.">id</a>;
<a name="l00253"></a>00253       }
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255     success = <span class="keyword">true</span>;
<a name="l00256"></a>00256   }
<a name="l00257"></a>00257   <span class="comment">/* clear out probesets to prevent deleting them. */</span>
<a name="l00258"></a>00258   group.<a class="code" href="classProbeSetGroup.html#aa197d2e48f3c2e8ae67cc8f5d54735ac" title="Vector of probe set pointers.">probeSets</a>.clear();
<a name="l00259"></a>00259   <a class="code" href="classQuantGTypeMethod.html#aff29fdf8763f00f5e1eb451162cb38c2" title="clear a probe set">clearProbeSet</a>(*pSet);
<a name="l00260"></a>00260   <span class="keywordflow">return</span> success;
<a name="l00261"></a>00261 }
<a name="l00262"></a>00262 <span class="comment"></span>
<a name="l00263"></a>00263 <span class="comment">/**</span>
<a name="l00264"></a>00264 <span class="comment"> * Can the ProbeSet set up the intensities and summaries</span>
<a name="l00265"></a>00265 <span class="comment"> * @param const ProbeSet* - The probe set to be checked.</span>
<a name="l00266"></a>00266 <span class="comment"> * @return bool - true if can be setup else false. </span>
<a name="l00267"></a>00267 <span class="comment"> */</span>
<a name="l00268"></a><a class="code" href="classQuantGTypeMethod.html#a71d6dfe5d15e5d77354f770913c23824">00268</a> <span class="keywordtype">bool</span> <a class="code" href="classQuantGTypeMethod.html#a71d6dfe5d15e5d77354f770913c23824" title="Can the ProbeSet set up the intensities and summaries.">QuantGTypeMethod::canSetUpProbeSet</a>(<span class="keyword">const</span> <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a>* gtPs)
<a name="l00269"></a>00269 {
<a name="l00270"></a>00270         <span class="keywordflow">if</span> (gtPs-&gt;<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> != ProbeSet::Copynumber)
<a name="l00271"></a>00271         {
<a name="l00272"></a>00272                 <span class="keywordflow">if</span> (gtPs-&gt;<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> != ProbeSet::GenoType &amp;&amp; gtPs-&gt;<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> != ProbeSet::Marker &amp;&amp; gtPs-&gt;<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> != ProbeSet::MultichannelMarker) 
<a name="l00273"></a>00273                 {
<a name="l00274"></a>00274                         <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(4, <span class="stringliteral">&quot;Expecting to get genotyping probesets only. (probeset: name=&quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(gtPs-&gt;<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a>) + <span class="stringliteral">&quot;, type=&quot;</span> + <a class="code" href="classProbeSet.html#a24255185fa5ead036e3791ad41298b55" title="Generate probeset_type string from enum Type.">ProbeSet::typeEnumToString</a>(gtPs-&gt;<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a>) + <span class="stringliteral">&quot;)&quot;</span>);
<a name="l00275"></a>00275                         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// We only process genotyping probesets.</span>
<a name="l00276"></a>00276                 }
<a name="l00277"></a>00277                 <span class="keywordflow">if</span> (gtPs-&gt;<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> == ProbeSet::GenoType &amp;&amp; gtPs-&gt;<a class="code" href="classProbeSet.html#a6d8ed948634c42033bd0c35d2640b274" title="How many groups (or blocks) are there? Used extensively in genotyping chips.">numGroups</a> != 4 &amp;&amp; gtPs-&gt;<a class="code" href="classProbeSet.html#a6d8ed948634c42033bd0c35d2640b274" title="How many groups (or blocks) are there? Used extensively in genotyping chips.">numGroups</a> != 2) 
<a name="l00278"></a>00278                 {
<a name="l00279"></a>00279                         <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(4, <span class="stringliteral">&quot;Expecting to get two or four groups in genotyping probeset. (probeset: name=&quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(gtPs-&gt;<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a>) + <span class="stringliteral">&quot;, numgroups=&quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>((<span class="keywordtype">int</span>)gtPs-&gt;<a class="code" href="classProbeSet.html#a6d8ed948634c42033bd0c35d2640b274" title="How many groups (or blocks) are there? Used extensively in genotyping chips.">numGroups</a>) + <span class="stringliteral">&quot;)&quot;</span>);
<a name="l00280"></a>00280                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00281"></a>00281                 }
<a name="l00282"></a>00282         }
<a name="l00283"></a>00283         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00284"></a>00284 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2016 12:58:52 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
