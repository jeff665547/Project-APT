<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: APT Libraries</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>APT Libraries </h1>  </div>
</div>
<div class="contents">
<p>There are numerous libraries in use at Affymetrix to help write maintainable and reusable code.</p>
<p>It is critical to use these existing libraries whenever possible rather than reinventing the wheel at every opportunity. Below is a brief description of some of the key libraries. Please refer to the libraries themselves for further documentation.</p>
<h2><a class="anchor" id="LibraryErrAbort"></a>
Err::errAbort()</h2>
<p><code><a class="el" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort()</a></code> is a centralized place to handle all fatal errors. What happens when a fatal error is encountered can be customized by using the <code><a class="el" href="classErr.html#a7cd8651ed7e53ac86b43dad235d1cb91" title="Pop off the current handler and return it for cleanup, etc.">Err::popHandler()</a></code> and <code><a class="el" href="classErr.html#ae57b8788e17115012f6b42e9f8d5aed9" title="Add a new handler for errors.">Err::pushHandler(ErrHandler *)</a></code> functions. This allows the command line programs to do simple things like call <code>exit(1)</code> and the GUI programs to enable other behaviors like throwing exceptions or setting global flags and clean up. It is extremely bad when the APT libraries bring down a GUI program that is using them use <code><a class="el" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort()</a></code> rather than <code>exit(1)</code> or some other mechanism of stopping the entire program. Use <code><a class="el" href="Err_8h.html#ad024208f4ba6a4e75df4499ea1639a05" title="Calls Err::apt_err_assert with the filename and linenumber set. /// We want to avoid evaluating the m...">APT_ERR_ASSERT()</a></code> rather than <code>assert</code> which will stop execution immediately.</p>
<h2><a class="anchor" id="LibraryVerbose"></a>
Verbose::out()</h2>
<p><code>Verbose::out(int level, const string &amp;s)</code> is a centralized place for communication from the APT libraries and engines to the users and logs. Think of <code><a class="el" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out()</a></code> as printing to the usual stdout for programs, but with the added structure of specifying a level of detail. The level parameter specifies the detail level of the message and thus when the message should be output. Different message handlers can be registered with the <code><a class="el" href="classVerbose.html" title="Verbose.">Verbose</a></code> class and they can each choose to ignore messages above a certain level. By convention the levels correspond to the following levels of detail.</p>
<ul>
<li>1 = Messages for the end user, should be pretty sparse. (Console, GUI, log file)</li>
<li>2 = More detailed information for the Console and log file.</li>
<li>3 = Very detailed level of information, usually just displayed in log file.</li>
<li>4 = sparse debug messages,</li>
<li>5 = probeset level debug messages,</li>
<li>6 = probe level debug messages</li>
</ul>
<p><code><a class="el" href="classVerbose.html#a34e1d936178741eeb78de93c5497e1b8" title="Print a warning message.">Verbose::warn()</a></code> is a similar but should be thought of as the stderr equivalent of <code><a class="el" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out()</a></code>. And should be used for errors rather than informative messages.</p>
<p><code>progressBegin(),progressStep()</code> and <code>progressEnd()</code> in the <code><a class="el" href="classVerbose.html" title="Verbose.">Verbose</a></code> class allow communication of the progress of a longer job to the user. For the command line programs this often means simply printing a dot to let the user know the program is progressing. GUI programs can register a <code><a class="el" href="classProgressHandler.html" title="An abstract class for handling Progress updates.">ProgressHandler</a></code> drives the use of a dialog progress meter to let the user know how the computation is progressing.</p>
<h2><a class="anchor" id="LibraryPgOptions"></a>
PgOptions</h2>
<p><code><a class="el" href="classPgOptions.html">PgOptions</a></code> is the APT library for working with command line options. With this library, a program can declare the list of options it supports along with their kind and defaults. <code><a class="el" href="classPgOptions.html">PgOptions</a></code> will process the command line and then the program can query what was set.</p>
<p>Like standard unix programs, an option of <code>"--"</code> ends option parsing. All the remaining arguments are args to the program.</p>
<p>There are three kinds of options: <code>BOOL</code>, <code>DOUBLE</code> and <code>STRING</code>. All three kinds may have a value appended to the option name with "=". (Like: <code>"--double-example=10.5"</code>, <code>"--output-dir=foo"</code>.)</p>
<p>BOOL values may have a prefix of "-no-" or "--no-" to set the value to "false". If the arg after a bool option is "true/1" or "false/0" it is used as the value. Otherwise the option is set to true. (Note that this might make working with a file called "true" ambiguous. In that case use "--" to separate the args from the option.) Non-option args to the program are put into the "args" list which the program can retrieve with <code>"getArg(idx)"</code>.</p>
<p>Normal usage looks like:</p>
<div class="fragment"><pre class="fragment">
int main (int argc,char* argv[]) {
  PgOptions opts;
  opts-&gt;setUsage("A nice paragraph about what this program does.");
  opts-&gt;defineOption("p","print",PgOpt::BOOL_OPT,
                     "Do you want to print the output?",
                     "true");

  opts-&gt;parseArgv(argv);
  if (opts-&gt;getBool("print")) {
    doPrint();
  }
}
</pre></div><p>Please try and write the options in the "positive sense". If the default is to print, then define the option "print" to be true. The user can use <code>"--no-print"</code> when they don't want to. (Don't define <code>"--no-print"</code>.)</p>
<h2><a class="anchor" id="LibraryTsvFile"></a>
TsvFile</h2>
<p><code>TsvFile</code> is a library to read tab separated files, or any other delimited file. The caller defines the columns in the file and then functions to get and or set the values at a particular row. The <code>TsvFile</code> library allows for:</p>
<ul>
<li>Reading headers</li>
<li>Reading data by lines or levels</li>
<li>Writing headers and data</li>
<li>Indexing the contents of the file by a column and searching the index</li>
</ul>
<p>Whenever possible input and output files should use the <code>TsvFile</code> libraries. See the <a class="el" href="file-format-tsv.html">documentation </a> and <a class="el" href="tsv-example_8cpp_source.html">tsv-example.cpp </a> for some example usages.</p>
<h2><a class="anchor" id="LibraryFile5"></a>
File5</h2>
<p><code>File5</code> is a library which provides a simplified C++ interface to the HDF5 library. It is similar in spirit to a binary form of the <code>TsvFile</code> library. It allows the user to focus on the specification of "what" is stored while HDF5 takes care of the "how" it is represented on disk. Note that as every <code>File5</code> file is an HDF5 file the normal <code>h5dump</code> and other utilities like HDF5 viewer will work with them.</p>
<p>HDF5 (Hierarchical Data Format 5) is a data model, file format and library for file IO. It is mature and permits the storage of multiple named binary data sets in one file along with user transparent byte-ordering, resizing, compression, and checksuming of the stored data. With HDF5, we can concentrate on what is to be stored rather than the how. By using this library we hope to have a richer data format than the file formats which are currently in use at Affymetrix. (It does not have a 2 or 4 GB limit.)</p>
<p>With all of the features HDF5 offers, the interface is rather large. Additionally, there is a bit of book-keeping of the objects which HDF5 uses. (data-types, data-sets, data-files, etc.) The aim of File5 is to offer a set of C++ objects which simplify working with the datasets by taking care of the resource tracking.</p>
<p>See the <a class="el" href="file-format-file5.html"><code>File5</code> documentation </a> for further details and usage.</p>
<h2><a class="anchor" id="LibraryRegression"></a>
Regression Testing</h2>
<p>When writing regression or integration tests use the <code><a class="el" href="classRegressionTest.html" title="Utility class for helping to do regression testing.">RegressionTest</a></code> framework. <code><a class="el" href="classRegressionTest.html" title="Utility class for helping to do regression testing.">RegressionTest</a></code> takes a command to run and a series of checks that implement <code><a class="el" href="classRegressionCheck.html" title="Abstract base class (i.e.">RegressionCheck</a></code> interface to be run after the command.</p>
<h2><a class="anchor" id="LibraryCPPUnit"></a>
CPPUnit</h2>
<p>Use <code>CPPUnit</code> for unit testing. There is a lot of documentation at the Sourceforge page for <code>CPPUnit</code> <a href="http://sourceforge.net/apps/mediawiki/cppunit/">http://sourceforge.net/apps/mediawiki/cppunit/</a> . By convention the <code>CPPUnit</code> tests reside in a <code>CPPTest</code> subdirectory of the location of the classes to be tested. Unit tests should run very quickly and only reference data either in the file itself or checked into cvs. If your unit tests runtime is measured in minutes or you data in megabytes then please use the regression framework instead. An example of <code>CPPUnit</code> usage for testing is in the <a class="el" href="classRMA.html" title="Holds methods for computing the popular Robust Muliarray Average of Microarrays (RMA).">RMA</a> framework under <code>affy/sdk/rma/CPPTest</code></p>
<h2><a class="anchor" id="LibraryUtil"></a>
Util</h2>
<p>In <code><a class="el" href="Util_8h.html" title="General Utilities.">util/Util.h</a></code> there are a number of useful functions that developers are encouraged to use. Examples include:</p>
<ul>
<li>String utilities for pattern matching, comparing, case changing etc.</li>
<li>File opening, closing, removing, renaming, etc. on different platforms.</li>
<li><code>convertPathName()</code> is particularly important as it allows longer paths on Windows platform. </li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2016 12:59:11 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
