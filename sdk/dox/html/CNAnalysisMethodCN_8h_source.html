<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: copynumber/CNAnalysisMethodCN.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_41dda80f44caddc01a4a55d902223772.html">copynumber</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>CNAnalysisMethodCN.h</h1>  </div>
</div>
<div class="contents">
<a href="CNAnalysisMethodCN_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00002"></a>00002 <span class="comment"></span><span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// Copyright (C) 2005 Affymetrix, Inc.</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// This program is free software; you can redistribute it and/or modify</span>
<a name="l00006"></a>00006 <span class="comment">// it under the terms of the GNU General Public License (version 2) as</span>
<a name="l00007"></a>00007 <span class="comment">// published by the Free Software Foundation.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l00010"></a>00010 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00011"></a>00011 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<a name="l00012"></a>00012 <span class="comment">// General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">// You should have received a copy of the GNU General Public License</span>
<a name="l00015"></a>00015 <span class="comment">// along with this program;if not, write to the</span>
<a name="l00016"></a>00016 <span class="comment">//</span>
<a name="l00017"></a>00017 <span class="comment">// Free Software Foundation, Inc.,</span>
<a name="l00018"></a>00018 <span class="comment">// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00019"></a>00019 <span class="comment">//</span><span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="preprocessor">#ifndef _CNAnalysisMethodCN_H_</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#define _CNAnalysisMethodCN_H_</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l00025"></a>00025 <span class="comment"> * @file CNAnalysisMethodCN.h</span>
<a name="l00026"></a>00026 <span class="comment"> *</span>
<a name="l00027"></a>00027 <span class="comment"> * @brief This header contains the CNAnalysisMethodCN class definition.</span>
<a name="l00028"></a>00028 <span class="comment"> */</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="CNAnalysisMethod_8h.html" title="This header contains the CNAnalysisMethod class definition.">copynumber/CNAnalysisMethod.h</a>&quot;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#define CNAnalysisMethodCN_Version &quot;1.0&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>
<a name="l00034"></a>00034 <span class="preprocessor">#define CNERR_CHECK(x, y) if ( !(x) ) throw(Except(y))</span>
<a name="l00035"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a57fda809e6c500c94faba7eda6a9d716">00035</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> U_INT; <span class="comment">///&lt; Unsigned int.</span>
<a name="l00036"></a>00036 <span class="comment"></span><span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">///////////////////////////////////////////////////////////////////////////</span>
<a name="l00038"></a>00038 <span class="comment"></span><span class="comment">// Basic types.</span>
<a name="l00039"></a>00039 <span class="comment">// NOTE: CNLRT should be used since CNLR is deprecated.</span><span class="comment"></span>
<a name="l00040"></a>00040 <span class="comment">///////////////////////////////////////////////////////////////////////////</span>
<a name="l00041"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a28e35ed58b924c363a5e444e9813ee73">00041</a> <span class="comment"></span><span class="keyword">typedef</span> <span class="keywordtype">float</span>                               CNLRT;    <span class="comment">///&lt; CN log2 ratio.</span>
<a name="l00042"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a98738d22d312192c7840893ab7b6eba9">00042</a> <span class="comment"></span><span class="keyword">typedef</span> <a class="code" href="CNAnalysisMethodCN_8h.html#a28e35ed58b924c363a5e444e9813ee73" title="CN log2 ratio.">CNLRT</a>                               CNLR;     <span class="comment">///&lt; CN log2 ratio.</span>
<a name="l00043"></a><a class="code" href="CNAnalysisMethodCN_8h.html#aa9d3b4e9bb848cacde2b47a0f389f9de">00043</a> <span class="comment"></span><span class="keyword">typedef</span> <span class="keywordtype">long</span>                                FragLenT; <span class="comment">///&lt; Fragment length.</span>
<a name="l00044"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a78cf7c898073ab03510343b0c493f3f2">00044</a> <span class="comment"></span><span class="keyword">typedef</span> <span class="keywordtype">int</span>                                    PosT;     <span class="comment">///&lt; Position.</span>
<a name="l00045"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a45c667bab41bfe32d98dc0822543668e">00045</a> <span class="comment"></span><span class="keyword">typedef</span> <span class="keywordtype">double</span>                              GCCT;     <span class="comment">///&lt; GC content.</span>
<a name="l00046"></a><a class="code" href="CNAnalysisMethodCN_8h.html#ae85319efa2b80dfdcce2904d2ab18264">00046</a> <span class="comment"></span><span class="keyword">typedef</span> <span class="keywordtype">int</span>                                 HmmStateT;<span class="comment">///&lt; State.</span>
<a name="l00047"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a29b78c4b78c7900183a160087fbb8fbe">00047</a> <span class="comment"></span><span class="keyword">typedef</span> <span class="keywordtype">double</span>                              PValT;    <span class="comment">///&lt; P-Value.</span>
<a name="l00048"></a>00048 <span class="comment"></span><span class="comment"></span>
<a name="l00049"></a>00049 <span class="comment">/// Genotype Type</span>
<a name="l00050"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a519839d379593c0242d6f77936c46ecf">00050</a> <span class="comment"></span><span class="keyword">enum</span> <a class="code" href="CNAnalysisMethodCN_8h.html#a519839d379593c0242d6f77936c46ecf" title="Genotype Type.">geno_type_t</a> { AA, AB, BB, N};
<a name="l00051"></a>00051 <span class="comment"></span>
<a name="l00052"></a>00052 <span class="comment">///////////////////////////////////////////////////////////////////////////</span>
<a name="l00053"></a>00053 <span class="comment"></span><span class="comment">// Collections: this is for convenience so one does not have to write</span>
<a name="l00054"></a>00054 <span class="comment">// out something like &quot;std::map&lt;std::string,std::string&gt;&quot;</span><span class="comment"></span>
<a name="l00055"></a>00055 <span class="comment">///////////////////////////////////////////////////////////////////////////</span>
<a name="l00056"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a831c522ec6d6a9a23be30bdc6adf2270">00056</a> <span class="comment"></span><span class="keyword">typedef</span> std::map&lt;std::string,std::string&gt;   StrStrMap; <span class="comment">///&lt; Map of string to string.</span>
<a name="l00057"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a665edd0c3bb3353d8549e492d1da42fa">00057</a> <span class="comment"></span><span class="keyword">typedef</span> std::map&lt;std::string,int&gt;           StrIntMap; <span class="comment">///&lt; Map of String to int.</span>
<a name="l00058"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a477a7deba3ec6c6f9cf0b3e7e11ec2bf">00058</a> <span class="comment"></span><span class="keyword">typedef</span> std::map&lt;int,std::string&gt;           IntStrMap; <span class="comment">///&lt; Map of int to string.</span>
<a name="l00059"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a1972afbb2da11833cc5c4e7dda7936cf">00059</a> <span class="comment"></span><span class="keyword">typedef</span> std::map&lt;int,int&gt;                   IntIntMap; <span class="comment">///&lt; Map of int to int.</span>
<a name="l00060"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a073e9926e51139db1741b866f0bcdd48">00060</a> <span class="comment"></span><span class="keyword">typedef</span> std::set&lt;int&gt;                       IntSet;    <span class="comment">///&lt; Set of ints.</span>
<a name="l00061"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a146b3b56e358a0e30ee6e00227e85767">00061</a> <span class="comment"></span><span class="keyword">typedef</span> std::set&lt;std::string&gt;               StrSet;    <span class="comment">///&lt; Set of Strings.</span>
<a name="l00062"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a95bfcd43ba8dc9b4dbace1e6a9419966">00062</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt;int&gt;                    VecInt;    <span class="comment">///&lt; Vector of ints.</span>
<a name="l00063"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a5b339eb8e48c17012665ffef38980a7c">00063</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt;double&gt;                 VecD;      <span class="comment">///&lt; Vector of doubles.</span>
<a name="l00064"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a70cd37b9b469dfb416a06c90bbbc5a99">00064</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt;float&gt;                  VecF;      <span class="comment">///&lt; Vector of floats.</span>
<a name="l00065"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a3a68664df2c4fdca940eb9e2a14a7fb8">00065</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt; std::vector&lt;int&gt; &gt;     VecVecInt; <span class="comment">///&lt; Vector of vector of ints.</span>
<a name="l00066"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a72af6c9b3aafe4334422a023617705af">00066</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt; std::vector&lt;int&gt; &gt;     VecVecI;   <span class="comment">///&lt; Vector of vector of ints.</span>
<a name="l00067"></a><a class="code" href="CNAnalysisMethodCN_8h.html#ae2d4e25d9fe7fa0882906870128f48ab">00067</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt; VecD &gt;                 VecVecD;   <span class="comment">///&lt; Vector of vector of doubles.</span>
<a name="l00068"></a><a class="code" href="CNAnalysisMethodCN_8h.html#ab8c0ec3eb2b8143b3b76b5205c52f3db">00068</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt; VecF &gt;                 VecVecF;   <span class="comment">///&lt; Vector of vector of floats.</span>
<a name="l00069"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a5bc1569759d3334e9126cdbb413fefaa">00069</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt;std::string&gt;            VecStr;    <span class="comment">///&lt; Vector of strings.</span>
<a name="l00070"></a><a class="code" href="CNAnalysisMethodCN_8h.html#ace1e911a3c168ee28e1d9dd43c3b0041">00070</a> <span class="comment"></span><span class="keyword">typedef</span> <a class="code" href="CNAnalysisMethodCN_8h.html#a5bc1569759d3334e9126cdbb413fefaa" title="Vector of strings.">VecStr</a>                              StrVec;    <span class="comment">///&lt; Vector of strings.</span>
<a name="l00071"></a><a class="code" href="CNAnalysisMethodCN_8h.html#ad3fb64d22d2a807df07be24cb2d1dc8d">00071</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt;VecStr&gt;                 VecVecStr; <span class="comment">///&lt; Vector of vector of strings.</span>
<a name="l00072"></a>00072 <span class="comment"></span>
<a name="l00073"></a><a class="code" href="CNAnalysisMethodCN_8h.html#abc9347d58c28bfc04f32dc829c0df81a">00073</a> <span class="keyword">typedef</span> std::vector&lt;CNLRT&gt;                  VecCNLR;     <span class="comment">///&lt; Vector of CNLRT.</span>
<a name="l00074"></a><a class="code" href="CNAnalysisMethodCN_8h.html#aaea9eecd55e8f15e8a7522ba097faf2c">00074</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt;HmmStateT&gt;              VecHmmState; <span class="comment">///&lt; Vector of HmmStateT.</span>
<a name="l00075"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a0d65355d9e9b406484419676339c89d6">00075</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt;PValT&gt;                  VecProb;     <span class="comment">///&lt; Vector of PValT.</span>
<a name="l00076"></a><a class="code" href="CNAnalysisMethodCN_8h.html#ae113ca9c3b110bd3fbefd884fe7f6b85">00076</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt;PosT&gt;                   VecPosition; <span class="comment">///&lt; Vector of PosT.</span>
<a name="l00077"></a><a class="code" href="CNAnalysisMethodCN_8h.html#ad0784aa86615a508908c55eecaa0ff1f">00077</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt;FragLenT&gt;               VecFraglen;  <span class="comment">///&lt; Vector of FragLenT.</span>
<a name="l00078"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a9db6b59cb1c3fba2d72994865f1a1048">00078</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt;GCCT&gt;                   VecGCC;      <span class="comment">///&lt; Vector of GCCT.</span>
<a name="l00079"></a>00079 <span class="comment"></span>
<a name="l00080"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a00035786e0aa142ac24221a7be9158fb">00080</a> <span class="keyword">typedef</span> std::vector&lt; VecCNLR &gt;              VecVecCNLR;     <span class="comment">///&lt; Vector of vector of CNLR.</span>
<a name="l00081"></a><a class="code" href="CNAnalysisMethodCN_8h.html#af72b7a9199ddd6bbbad707cb1479b190">00081</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt; VecHmmState &gt;          VecVecHmmState; <span class="comment">///&lt; Vector of vector of HMMStateT.</span>
<a name="l00082"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a82f20e466afe5bc55554d2b40a02cec8">00082</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt; VecProb &gt;              VecVecProb;     <span class="comment">///&lt; Vector of vector of PValT.</span>
<a name="l00083"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a515b6ef1777884c51dd354285a9d5a21">00083</a> <span class="comment"></span><span class="keyword">typedef</span> std::vector&lt; VecPosition &gt;          VecVecPosition; <span class="comment">///&lt; Vector of vector of PosT.</span>
<a name="l00084"></a>00084 <span class="comment"></span>
<a name="l00085"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a8f86e94f5b84c854fe5e76b18175c3df">00085</a> <span class="keyword">typedef</span> std::map&lt;std::string,CNLRT&gt;         MapStrCNLR;     <span class="comment">///&lt; Map of string to CNLRT.</span>
<a name="l00086"></a>00086 <span class="comment"></span>
<a name="l00087"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a20134d0b9d75e8d1942ed9ebadd78316">00087</a> <span class="preprocessor">#define MIN_PVALUE 1e-16                    ///&lt; The smallest p-value that we can report (since we&#39;ll be taking logs of p-values)</span>
<a name="l00088"></a><a class="code" href="CNAnalysisMethodCN_8h.html#af5245ff4d1a87f5644e4bb6667af9138">00088</a> <span class="preprocessor"></span><span class="preprocessor">#define N_NORMAL_SEGMENTS 1000              ///&lt; The initial buffer for storing normal state segment statistics</span>
<a name="l00089"></a><a class="code" href="CNAnalysisMethodCN_8h.html#aa931c86225bbf158de3459f40909cf61">00089</a> <span class="preprocessor"></span><span class="preprocessor">#define N_NORMAL_SEGMENTS_GROWTH_FACTOR 1.1 ///&lt; Factor by which the normal state segment vectors will be grown when they overflow</span>
<a name="l00090"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a91e3c5c4d8590d328e56efe79d8bfeb9">00090</a> <span class="preprocessor"></span><span class="preprocessor">#define MIN_SIGMA 1e-8                      ///&lt; The smallest sigma that we allow for HMM state emissions</span>
<a name="l00091"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a461204bbb320043239195ee590befba7">00091</a> <span class="preprocessor"></span><span class="preprocessor">#define MAX_SIGMA_RATIO 3                   ///&lt; The biggest allowable ratio between max &amp; min sigma for HMM state emissions</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00093"></a>00093 <span class="comment">/**</span>
<a name="l00094"></a>00094 <span class="comment"> * @brief Macro to return log(exp(x)+exp(y)) in a manner that avoids</span>
<a name="l00095"></a>00095 <span class="comment"> * underflow. Useful for HMM operations where we need to compute the log</span>
<a name="l00096"></a>00096 <span class="comment"> * of the sum of two probabilities which are stored in log scale and which</span>
<a name="l00097"></a>00097 <span class="comment"> * might be very small.</span>
<a name="l00098"></a>00098 <span class="comment"> */</span>
<a name="l00099"></a><a class="code" href="CNAnalysisMethodCN_8h.html#a3590d11d082221ffd42bd1e9e013d720">00099</a> <span class="preprocessor">#define ADD_LOG_PROB(X,Y) ( (Y) &gt; (X) ) ? ((Y) + log(1 + exp((X)-(Y)))) : ((X) + log(1 + exp((Y)-(X))))</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l00101"></a>00101 <span class="comment"> * @brief Macro to return log(exp(x)-exp(y)) in a manner that avoids</span>
<a name="l00102"></a>00102 <span class="comment"> * underflow. Useful for HMM operations where we need to compute the log</span>
<a name="l00103"></a>00103 <span class="comment"> * of the difference of two probabilities which are stored in log scale</span>
<a name="l00104"></a>00104 <span class="comment"> * and which might be very small.</span>
<a name="l00105"></a>00105 <span class="comment"> */</span>
<a name="l00106"></a><a class="code" href="CNAnalysisMethodCN_8h.html#afefa8dfe81ad8a63c9e0270879b947d7">00106</a> <span class="preprocessor">#define SUBTRACT_LOG_PROB(X,Y) ( (Y) &gt; (X) ) ? ((Y) + log(exp((X)-(Y)) - 1)) : ((X) + log(1 - exp((Y)-(X))))</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00108"></a>00108 <span class="comment">/**</span>
<a name="l00109"></a>00109 <span class="comment"> * @brief  The CN analysis method.</span>
<a name="l00110"></a>00110 <span class="comment"> *</span>
<a name="l00111"></a>00111 <span class="comment"> */</span>
<a name="l00112"></a><a class="code" href="classCNAnalysisMethodCN.html">00112</a> <span class="keyword">class </span><a class="code" href="classCNAnalysisMethodCN.html" title="The CN analysis method.">CNAnalysisMethodCN</a> : <span class="keyword">public</span> <a class="code" href="classCNAnalysisMethod.html" title="A base class for copy number analysis methods.">CNAnalysisMethod</a>
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114 <span class="keyword">private</span>:
<a name="l00115"></a>00115     <span class="comment">// Copy Number State Parameters</span>
<a name="l00116"></a>00116     std::vector&lt;int&gt; m_vCNState;
<a name="l00117"></a>00117     std::vector&lt;double&gt; m_vPriorProb;
<a name="l00118"></a>00118     std::vector&lt;double&gt; m_vMu;
<a name="l00119"></a>00119     std::vector&lt;double&gt; m_vSigma;
<a name="l00120"></a>00120     <span class="keywordtype">double</span> m_dTransMatDecay;
<a name="l00121"></a>00121     <a class="code" href="classAffxString.html" title="A class derived from std::string.">AffxString</a> m_strStateEstMethod;
<a name="l00122"></a>00122     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m_uiEMIterations;
<a name="l00123"></a>00123     <span class="keywordtype">double</span> m_dEMConvergentThreshold;
<a name="l00124"></a>00124     <span class="keywordtype">int</span> m_iNormalState;
<a name="l00125"></a>00125     <span class="keywordtype">int</span> m_iPostCNFitMaxOutlierRemoveRunSize;
<a name="l00126"></a>00126     <span class="comment">// Unused parameters.</span>
<a name="l00127"></a>00127   <span class="keywordtype">int</span>   m_fwdOnly;
<a name="l00128"></a>00128   <span class="keywordtype">int</span> m_inormalStateMinObservations;
<a name="l00129"></a>00129   <span class="keywordtype">int</span> m_iSmoothOutliers;
<a name="l00130"></a>00130   <span class="keywordtype">int</span>   m_transTypeStat;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="keyword">private</span>:
<a name="l00134"></a>00134   <span class="keywordtype">bool</span>   m_updatePrior;
<a name="l00135"></a>00135   <span class="keywordtype">bool</span>   m_updateMu;
<a name="l00136"></a>00136   <span class="keywordtype">bool</span>   m_updateSigma;
<a name="l00137"></a>00137   <span class="keywordtype">bool</span>   m_updateTransMat;
<a name="l00138"></a>00138   <span class="keywordtype">bool</span>   m_scaled;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140   std::vector&lt;double&gt; m_diagProb;
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="keyword">public</span>:
<a name="l00143"></a>00143     <a class="code" href="classCNAnalysisMethodCN.html#a4c552edf808e8138a187373ca9c68b9e" title="Constructor.">CNAnalysisMethodCN</a>();
<a name="l00144"></a>00144     <span class="keyword">virtual</span> ~<a class="code" href="classCNAnalysisMethodCN.html" title="The CN analysis method.">CNAnalysisMethodCN</a>();
<a name="l00145"></a>00145 
<a name="l00146"></a>00146     <span class="keyword">static</span> std::string getType();
<a name="l00147"></a>00147     <span class="keyword">static</span> std::string getDescription();
<a name="l00148"></a>00148     <span class="keyword">static</span> std::string getVersion();
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     <span class="keyword">static</span> <a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a> <a class="code" href="classCNAnalysisMethodCN.html#afc5ff8fe50e9f7efd388ac08a00be190" title="Supply a little how/what/why about the algorithms this class performs and what parameters it takes...">explainSelf</a>();
<a name="l00151"></a>00151     <span class="keyword">static</span> std::vector&lt;SelfDoc::Opt&gt; <a class="code" href="classCNAnalysisMethodCN.html#a83cf269296a3723e15fc5778de36f88e" title="Default Getter method for parameters and their documentation.">getDefaultDocOptions</a>();
<a name="l00152"></a>00152     <span class="keyword">static</span> <a class="code" href="classSelfCreate.html" title="Small interface for functions that know how to make an instance of themselves given a map of key...">SelfCreate</a>* <a class="code" href="classCNAnalysisMethodCN.html#a1d93b29e711d63bee87a20085f981a26" title="This static function should be overridden by child classes to return an object of the correct type in...">newObject</a>(std::map&lt;std::string, std::string&gt;&amp; param);
<a name="l00153"></a>00153 
<a name="l00154"></a>00154     <span class="keyword">virtual</span> <a class="code" href="classAffxString.html" title="A class derived from std::string.">AffxString</a> getName();
<a name="l00155"></a>00155 
<a name="l00156"></a>00156     <span class="keyword">virtual</span> <span class="keywordtype">void</span> setEngine(<a class="code" href="classBaseEngine.html" title="Base class for analysis engines.">BaseEngine</a>* p);
<a name="l00157"></a>00157 
<a name="l00158"></a>00158     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethodCN.html#a6688a839a4e6aa143103a086afa4fbb8" title="Run the analysis.">run</a>();
<a name="l00159"></a>00159     <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isSegmentTypeAnalysis();
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="keyword">protected</span>:
<a name="l00162"></a>00162     <span class="keywordtype">int</span> <a class="code" href="classCNAnalysisMethodCN.html#a2964bec0802cb25f3a2d7833a7e572c0" title="Get the last autosome chromosome.">getLastAutosomeChromosome</a>();
<a name="l00163"></a>00163     <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethodCN.html#ab39d1f2f7ee29ae1a6e09c7fd130476d" title="Anneal the CN calls and load them into the CNProbeSet vector.">copyNumberStatePostProcessing</a>(<span class="keywordtype">int</span> iChromosome, std::vector&lt;float&gt;&amp; vLog2Ratios, std::vector&lt;int&gt;&amp; vCNStates);
<a name="l00164"></a>00164 <span class="comment"></span>
<a name="l00165"></a>00165 <span class="comment">  /// @brief Compute the observed log-likelihoods &#39;aka&#39; the emission probabilities.</span>
<a name="l00166"></a>00166 <span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethodCN.html#afa0aa6561c3034cf6b266bd2d1834c46" title="Compute the observed log-likelihoods &amp;#39;aka&amp;#39; the emission probabilities.">obsloglik</a>(
<a name="l00167"></a>00167       <span class="keyword">const</span> <a class="code" href="CNAnalysisMethodCN_8h.html#abc9347d58c28bfc04f32dc829c0df81a" title="Vector of CNLRT.">VecCNLR</a>&amp;                       samplr,
<a name="l00168"></a>00168       <span class="keyword">const</span> <span class="keywordtype">int</span>                            numState,
<a name="l00169"></a>00169       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;           updated_mu,
<a name="l00170"></a>00170       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;           updated_sigma,
<a name="l00171"></a>00171       std::vector&lt; std::vector&lt;double&gt; &gt;&amp;  log_lik_obs
<a name="l00172"></a>00172   );<span class="comment"></span>
<a name="l00173"></a>00173 <span class="comment">  ///</span>
<a name="l00174"></a>00174 <span class="comment"></span>  <span class="keywordtype">double</span> <a class="code" href="classCNAnalysisMethodCN.html#ad0b401b0f159531fe0eea66a5c97f7cf" title="Compute the forward log likelihood.">fwdback</a>(
<a name="l00175"></a>00175       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;            dist_covariate,
<a name="l00176"></a>00176       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;            log_priorProb,
<a name="l00177"></a>00177       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;            updated_log_priorProb,
<a name="l00178"></a>00178       <span class="keyword">const</span> std::vector&lt; std::vector&lt;double&gt; &gt;&amp;   log_lik_obs,
<a name="l00179"></a>00179       <span class="keyword">const</span> <span class="keywordtype">double</span>                          transMatDecay,
<a name="l00180"></a>00180       <span class="keyword">const</span> <span class="keywordtype">bool</span>                            trans_type_stat,
<a name="l00181"></a>00181       <span class="keyword">const</span> std::vector&lt; std::vector&lt;double&gt; &gt;&amp;  log_transmat_stat,
<a name="l00182"></a>00182       std::vector&lt; std::vector&lt;double&gt; &gt;&amp;   alpha,
<a name="l00183"></a>00183       std::vector&lt; std::vector&lt;double&gt; &gt;&amp;   beta,
<a name="l00184"></a>00184       std::vector&lt; std::vector&lt;double&gt; &gt;&amp;   gamma,
<a name="l00185"></a>00185       std::vector&lt;double&gt;&amp;                  gamma_state_sum,
<a name="l00186"></a>00186       std::vector&lt; std::vector&lt;double&gt; &gt;&amp;   xi_sum,
<a name="l00187"></a>00187       <span class="keyword">const</span> <span class="keywordtype">double</span>   previous_loglik
<a name="l00188"></a>00188   );<span class="comment"></span>
<a name="l00189"></a>00189 <span class="comment">  ///</span>
<a name="l00190"></a>00190 <span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="classCNAnalysisMethodCN.html#a9e0e6bdb2c2072a3739012d3a06ec171">EMconverge</a>(
<a name="l00191"></a>00191       <span class="keyword">const</span> <span class="keywordtype">double</span>   previous_loglik,
<a name="l00192"></a>00192       <span class="keyword">const</span> <span class="keywordtype">double</span>   loglik,
<a name="l00193"></a>00193       <span class="keyword">const</span> <span class="keywordtype">double</span>   emConvergenceThresh,
<a name="l00194"></a>00194       <span class="keywordtype">bool</span>           bEMconverged
<a name="l00195"></a>00195   );<span class="comment"></span>
<a name="l00196"></a>00196 <span class="comment">  ///</span>
<a name="l00197"></a>00197 <span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethodCN.html#aec270080a25bc5edf538116bf256267e">reEstimate</a> (
<a name="l00198"></a>00198       <span class="keyword">const</span> <a class="code" href="CNAnalysisMethodCN_8h.html#abc9347d58c28bfc04f32dc829c0df81a" title="Vector of CNLRT.">VecCNLR</a>&amp;                                  samplr, <span class="comment">// Sample log2 ratios</span>
<a name="l00199"></a>00199       <span class="keyword">const</span> std::vector&lt; std::vector&lt;double&gt; &gt;&amp;       gamma,
<a name="l00200"></a>00200       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;                      gamma_state_sum,
<a name="l00201"></a>00201       <span class="keyword">const</span> std::vector&lt; std::vector&lt;double&gt; &gt;&amp;       xi_sum,
<a name="l00202"></a>00202       std::vector&lt; std::vector&lt;double&gt; &gt;&amp;             log_transmat_stat,
<a name="l00203"></a>00203       std::vector&lt;double&gt;&amp;                            updated_log_priorProb,
<a name="l00204"></a>00204       std::vector&lt;double&gt;&amp;                            updated_mu,
<a name="l00205"></a>00205       std::vector&lt;double&gt;&amp;                            updated_sigma,
<a name="l00206"></a>00206       <span class="keywordtype">bool</span>&amp;                                           compute_obsloglik,
<a name="l00207"></a>00207       <span class="keywordtype">bool</span>&amp;                                           bEMconverged,
<a name="l00208"></a>00208       <span class="keywordtype">int</span>                                             normalState
<a name="l00209"></a>00209   );<span class="comment"></span>
<a name="l00210"></a>00210 <span class="comment">  ///</span>
<a name="l00211"></a>00211 <span class="comment"></span>  <span class="keywordtype">double</span> <a class="code" href="classCNAnalysisMethodCN.html#a698fb6cb624939e1095693d4a00e00ad">viterbi</a> (
<a name="l00212"></a>00212       <span class="keyword">const</span> std::vector&lt; std::vector&lt;double&gt; &gt;&amp;       log_lik_obs,
<a name="l00213"></a>00213       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;                      dist_covariate,
<a name="l00214"></a>00214       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;                      log_priorProb,
<a name="l00215"></a>00215       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;                      updated_log_priorProb,
<a name="l00216"></a>00216       <span class="keyword">const</span> <span class="keywordtype">double</span>                                    transMatDecay,
<a name="l00217"></a>00217       <span class="keyword">const</span> <span class="keywordtype">bool</span>                                      trans_type_stat,
<a name="l00218"></a>00218       <span class="keyword">const</span> std::vector&lt; std::vector&lt;double&gt; &gt;&amp;            log_transmat_stat,
<a name="l00219"></a>00219       std::vector&lt;int&gt;&amp;                               state
<a name="l00220"></a>00220   );<span class="comment"></span>
<a name="l00221"></a>00221 <span class="comment">  ///</span>
<a name="l00222"></a>00222 <span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethodCN.html#a770c468c345f171f6c66b0e582222953" title="Collects segment stats.">collect_segment_stats</a>(
<a name="l00223"></a>00223       <span class="comment">// Inputs</span>
<a name="l00224"></a>00224       <span class="keyword">const</span> std::vector&lt;int&gt;&amp;     state,                      <span class="comment">// estimated HMM state sequence</span>
<a name="l00225"></a>00225       <span class="keyword">const</span> <a class="code" href="CNAnalysisMethodCN_8h.html#abc9347d58c28bfc04f32dc829c0df81a" title="Vector of CNLRT.">VecCNLR</a>&amp;         <a class="code" href="GenoUtility_8cpp.html#a631afdfd53685cf4cc3f0cf46b448c5c" title="Calculate the natural log ratio for two probeset signal.">logRatio</a>,                          <span class="comment">// observed log ratios</span>
<a name="l00226"></a>00226       <span class="keywordtype">int</span>                    normalState,                <span class="comment">// definition of which state corresponds to normal copy number</span>
<a name="l00227"></a>00227       <span class="keywordtype">int</span>                    normalStateMinObservations, <span class="comment">// min #observations in normal copy number segment to include in baseline for significance testing</span>
<a name="l00228"></a>00228       <span class="comment">// Segment outputs - these vectors will be resized according to # segments found</span>
<a name="l00229"></a>00229       std::vector&lt;int&gt;&amp;           segment_state,              <span class="comment">// state for each segment</span>
<a name="l00230"></a>00230       std::vector&lt;int&gt;&amp;           segment_end_index,          <span class="comment">// index of state just after segment ends</span>
<a name="l00231"></a>00231       <a class="code" href="CNAnalysisMethodCN_8h.html#abc9347d58c28bfc04f32dc829c0df81a" title="Vector of CNLRT.">VecCNLR</a>&amp;               segment_average_x,          <span class="comment">// average log ratio within each segment</span>
<a name="l00232"></a>00232       <a class="code" href="CNAnalysisMethodCN_8h.html#abc9347d58c28bfc04f32dc829c0df81a" title="Vector of CNLRT.">VecCNLR</a>&amp;               segment_average_xsquared,   <span class="comment">// average squared log ratio within each segment</span>
<a name="l00233"></a>00233       <a class="code" href="CNAnalysisMethodCN_8h.html#abc9347d58c28bfc04f32dc829c0df81a" title="Vector of CNLRT.">VecCNLR</a>&amp;               segment_median,             <span class="comment">// median log ratio within each segment</span>
<a name="l00234"></a>00234       <span class="comment">// Normal segment outputs - these vectors will be written to starting at index normal_state_n and will be expanded in chunks as necessary</span>
<a name="l00235"></a>00235       <a class="code" href="CNAnalysisMethodCN_8h.html#abc9347d58c28bfc04f32dc829c0df81a" title="Vector of CNLRT.">VecCNLR</a>&amp;               normal_state_average,       <span class="comment">// average log ratio per normal state segment</span>
<a name="l00236"></a>00236       <a class="code" href="CNAnalysisMethodCN_8h.html#abc9347d58c28bfc04f32dc829c0df81a" title="Vector of CNLRT.">VecCNLR</a>&amp;               normal_state_sd,            <span class="comment">// sample sd of log ratio per normal state segment</span>
<a name="l00237"></a>00237       std::vector&lt;U_INT&gt;&amp;         normal_state_nObs,          <span class="comment">// number of observations of normal state per normal state segment</span>
<a name="l00238"></a>00238       <a class="code" href="CNAnalysisMethodCN_8h.html#a57fda809e6c500c94faba7eda6a9d716" title="Unsigned int.">U_INT</a>&amp;                 normal_state_n              <span class="comment">// number of normal state segments</span>
<a name="l00239"></a>00239   );
<a name="l00240"></a>00240 
<a name="l00241"></a>00241   <span class="keywordtype">void</span> setup(
<a name="l00242"></a>00242       <span class="keywordtype">bool</span> updatePrior,
<a name="l00243"></a>00243       <span class="keywordtype">bool</span> updateMu,
<a name="l00244"></a>00244       <span class="keywordtype">bool</span> updateSigma,
<a name="l00245"></a>00245       <span class="keywordtype">bool</span> updateTransMat,
<a name="l00246"></a>00246       <span class="keywordtype">bool</span> fwdOnly,
<a name="l00247"></a>00247       <span class="keywordtype">bool</span> scaled,
<a name="l00248"></a>00248       <span class="keywordtype">bool</span> transTypeStat
<a name="l00249"></a>00249       );
<a name="l00250"></a>00250 <span class="comment"></span>
<a name="l00251"></a>00251 <span class="comment">  /**</span>
<a name="l00252"></a>00252 <span class="comment">   * @brief Gives the CopyNumberHMM object the diagonal probabilities</span>
<a name="l00253"></a>00253 <span class="comment">   * it should use.</span>
<a name="l00254"></a>00254 <span class="comment">   */</span>
<a name="l00255"></a>00255   <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethodCN.html#a0744a82f7e92cb4d0ce08ea06a8314d8" title="Gives the CopyNumberHMM object the diagonal probabilities it should use.">diagProb</a>(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; dpvec);<span class="comment"></span>
<a name="l00256"></a>00256 <span class="comment">  /**</span>
<a name="l00257"></a>00257 <span class="comment">   * @brief Runs HMM algorithm on a set of log2 ratios for a given sample</span>
<a name="l00258"></a>00258 <span class="comment">   * on a given chromosome.</span>
<a name="l00259"></a>00259 <span class="comment">   * Note: currently, only &quot;state&quot; will be used outside this method.</span>
<a name="l00260"></a>00260 <span class="comment">   */</span>
<a name="l00261"></a>00261   <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethodCN.html#a00d94045f6d5b1b50f6c45dc29538168" title="Runs HMM algorithm on a set of log2 ratios for a given sample on a given chromosome.">hmm</a>(
<a name="l00262"></a>00262       <span class="keyword">const</span> std::vector&lt;int&gt;&amp;      position,   <span class="comment">// SNP positions</span>
<a name="l00263"></a>00263       <span class="keyword">const</span> <a class="code" href="CNAnalysisMethodCN_8h.html#abc9347d58c28bfc04f32dc829c0df81a" title="Vector of CNLRT.">VecCNLR</a>&amp;              samplr,     <span class="comment">// Sample log2 ratios</span>
<a name="l00264"></a>00264       std::vector&lt;int&gt;&amp;           state,
<a name="l00265"></a>00265       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;  priorProb,
<a name="l00266"></a>00266       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;  mu,
<a name="l00267"></a>00267       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;  sigma,
<a name="l00268"></a>00268       <span class="keywordtype">double</span>                      transMatDecay,
<a name="l00269"></a>00269       <span class="keyword">const</span> std::string&amp;          stateEstMethod,
<a name="l00270"></a>00270       std::vector&lt;double&gt;&amp;        stateMargProb,
<a name="l00271"></a>00271       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          emIterations,
<a name="l00272"></a>00272       <span class="keyword">const</span> <span class="keywordtype">double</span>                emConvergenceThresh,
<a name="l00273"></a>00273       <span class="keywordtype">bool</span>                        b_allelespecific,
<a name="l00274"></a>00274       <span class="keywordtype">int</span>                         normalState
<a name="l00275"></a>00275   );<span class="comment"></span>
<a name="l00276"></a>00276 <span class="comment">  /**</span>
<a name="l00277"></a>00277 <span class="comment">   * @brief This is done on a per chromosome basis for a given sample.</span>
<a name="l00278"></a>00278 <span class="comment">   */</span>
<a name="l00279"></a>00279   <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethodCN.html#ad3109d038ff6963f9aadb7cc6a261558" title="This is done on a per chromosome basis for a given sample.">smoothOutliers</a>(
<a name="l00280"></a>00280                       std::vector&lt;int&gt;&amp;           state,
<a name="l00281"></a>00281                       <span class="keyword">const</span> std::vector&lt;double&gt;&amp;  pos,
<a name="l00282"></a>00282                       <span class="keywordtype">double</span>                      distThresh
<a name="l00283"></a>00283   );<span class="comment"></span>
<a name="l00284"></a>00284 <span class="comment">  /**</span>
<a name="l00285"></a>00285 <span class="comment">   * @brief This is done across all chromosomes for a given sample.</span>
<a name="l00286"></a>00286 <span class="comment">   * The indexes for the &quot;vector&lt; vector&lt;TYPE&gt; &gt;&quot; items are</span>
<a name="l00287"></a>00287 <span class="comment">   * [chromosome][state/log2ratio/medianCN/pValue]</span>
<a name="l00288"></a>00288 <span class="comment">   * Example:  For chromosome index 2 the 5th log2 ratio values would</span>
<a name="l00289"></a>00289 <span class="comment">   * be &quot;samplr[2][4]&quot;</span>
<a name="l00290"></a>00290 <span class="comment">   */</span>
<a name="l00291"></a>00291   <span class="keywordtype">void</span> <a class="code" href="classCNAnalysisMethodCN.html#a8391ceb19c550f48efde9862b7ee045a" title="This is done across all chromosomes for a given sample.">postProcessHMM</a>(
<a name="l00292"></a>00292                       <span class="keyword">const</span> std::vector&lt; std::vector&lt;int&gt; &gt;&amp;   state,
<a name="l00293"></a>00293                       <span class="keyword">const</span> <a class="code" href="CNAnalysisMethodCN_8h.html#a00035786e0aa142ac24221a7be9158fb" title="Vector of vector of CNLR.">VecVecCNLR</a>&amp;                        logRatio,
<a name="l00294"></a>00294                       <span class="keywordtype">int</span>                                      normalState,
<a name="l00295"></a>00295                       <span class="keywordtype">int</span>                                      normalStateMinObservations,
<a name="l00296"></a>00296                       <span class="keywordtype">bool</span>                                     estCorrectionFactor,
<a name="l00297"></a>00297                       <span class="keywordtype">double</span>&amp;                                  correctionFactor,
<a name="l00298"></a>00298                       <a class="code" href="CNAnalysisMethodCN_8h.html#a00035786e0aa142ac24221a7be9158fb" title="Vector of vector of CNLR.">VecVecCNLR</a>&amp;                              medianCN
<a name="l00299"></a>00299   );
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 };
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="preprocessor">#endif</span>
<a name="l00305"></a>00305 <span class="preprocessor"></span>
<a name="l00306"></a>00306 
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2016 12:58:55 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
