<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: Architecture: Normalize Template Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Architecture: Normalize Template Code </h1>  </div>
</div>
<div class="contents">
<p>In general microarray data must be normalized before comparisons and other summaries can be made.</p>
<p>The normalization module consists of a number of template that implement a variety of normalization algorithms including median normalization (<a class="el" href="classMedianNormalization.html">MedianNormalization</a>) which scales the data linearly to have the same median and quantile normalization (<a class="el" href="classQuantileNormalization.html" title="first parameter is a nested pointer **p is a number *p is a sample; the second parameter should be a ...">QuantileNormalization</a>) which modifies the data non-linearly to ensure that each microarray has the same distribution. There are also methods to do an approximate (sketch) quantile normalization using just a subset of the data which can greatly reduce the memory impact usually associated with a full quantile normalization.</p>
<h2><a class="anchor" id="quantileNorm"></a>
Quantile Normalization</h2>
<p>Classes for quantile normalizing the data that a set of iterators point to. Basic algorithm is that data is sorted and the average value across all iterators is used as the normalized data value for all of the original data. This ensures that the distribution is identical for the data pointed to by each iterator. Ties can occur when a particular iterator points to data where there are multiple values that are identical. In these cases the ranking of a particular data value in the sort can be variable. These ties are resolved by taking the average value of the normalized distribution for all of the ties. These packages also support another popular way of resolving ties as implemented by the bioconductor (<a href="http://www.bioconductor.org/">http://www.bioconductor.org/</a>) "affy" package where the value of the middle position of the ties is used for all the ties.</p>
<p><b>Warning:</b> To resolve the ties efficiently with the average value a vector of partial sums is used. Be sure the LargeNumber type has sufficient range (i.e. doesn't overflow) and has sufficient precision (i.e. enough bits to represent mantissa). Doubles seem to do well.</p>
<p>A sample usage would be: </p>
<div class="fragment"><pre class="fragment">vector&lt;vector&lt;float&gt; &gt; data;
vector&lt;vector &lt;float&gt;::iterator&gt; dataIterVec;
<span class="comment">// Note that the second type is double to ensure that no overflow and no loss of </span>
<span class="comment">// precision in partial sums averaging.</span>
<a class="code" href="classQuantileNormalization.html" title="first parameter is a nested pointer **p is a number *p is a sample; the second parameter should be a ...">QuantileNormalization&lt;vector&lt;vector&lt;float&gt;::iterator</a> &gt;::iterator, <span class="keywordtype">double</span>&gt; qn(<span class="keyword">false</span>);  
<span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; data.size(); i++) {
  dataIterVec.push_back(data[i].begin());
}
qn(dataIterVec.begin(), dataIterVec.end(), *(dataIterVec.begin()) + data[0].size());
</pre></div><p>This would modify the matrix data consisting of (chips are rows, probes are columns): </p>
<div class="fragment"><pre class="fragment">
1 2 3  3  3  4  5  6  7
2 4 6  8  8  8  8 12 14
3 6 9 12 12 12 15 18 21
</pre></div><p> to a normalized data matrix with the following values: </p>
<div class="fragment"><pre class="fragment">
2 4 7.1 7.1 7.1 8   9.3 12 14
2 4 6   8.2 8.2 8.2 8.2 12 14
2 4 6   7.8 7.8 7.8 9.3 12 14
</pre></div><p> note that using the bioconductor manner of resolving ties would result in slightly different values: </p>
<div class="fragment"><pre class="fragment">
2 4 7.7 7.7 7.7 8   9.3 12 14
2 4 6   7.7 7.7 7.7 7.7 12 14
2 4 6   7.7 7.7 7.7 9.3 12 14
</pre></div><p> As seen using the following commands: </p>
<div class="fragment"><pre class="fragment">library(affy);
dat &lt;- read.table(<span class="stringliteral">&#39;CPPTest/input/doc-example.txt&#39;</span>)
<span class="preprocessor"># Note that normalize.quantiles expects chips to be columns </span>
<span class="preprocessor"></span><span class="preprocessor"># and probes to be rows so transpose with t().</span>
<span class="preprocessor"></span>ndat &lt;- normalize.quantiles(t(dat))
t(<a class="code" href="DM_8cpp.html#a88ba7496aba146eabdf9e03f74ab23aa" title="Round the double and return it.">round</a>(ndat, digits=1))
</pre></div><h2><a class="anchor" id="sketchNorm"></a>
Sketch Quantile Normalization</h2>
<p>It is possible to achieve a very good approximation to the quantile normalization using much less memory by using a sketch, or subset, of the data and extrapolating the normalization of all data values from the normalization of the sketch. As memory can be a limiting factor for many analysis with the higher density Affymetrix arrays and the difference between full quantile normalization and a sketch quantile normalization (or just "sketch" for short) is very small the sketch normalization has become the preferred manner for normalizing microarray data.</p>
<p>There are three phases to a sketch normalization:</p>
<ol type="1">
<li>Extract the sketch (or subsample) of the data using the <a class="el" href="classExtractSketch.html" title="Functor class for extracting a subset of data from a larger set.">ExtractSketch</a> class.</li>
<li>Find the average distribution of all the sketches using <a class="el" href="classAverageSketch.html" title="Combine all the sketches into a summary by averaging them. /// See also: Sketch Quantile Normalizatio...">AverageSketch</a>.</li>
<li>Create an interpolator (<a class="el" href="classInterpolateSketch.html" title="Functor class to determine normalized value given raw data point and the vector of sketch values for ...">InterpolateSketch</a> object) per microarray that will use linear interpolation to determine the normalized value of any intensity for that microarray.</li>
</ol>
<p>A sample usage is: </p>
<div class="fragment"><pre class="fragment"><span class="comment">// Declarations</span>
vector&lt;vector&lt;float&gt; &gt; data;
<span class="comment">// Load data...</span>
<span class="keywordtype">int</span> sketchSize = data[0].size()/10;
<span class="comment">// Note again that LargeNumber type is double</span>
vector&lt; InterpolateSketch&lt; vector&lt;float&gt;::iterator, <span class="keywordtype">double</span>&gt; &gt; m_Interpolators;
vector&lt; float &gt; m_AverageSketch;
vector&lt; vector&lt;float&gt;::iterator &gt; m_Sketches;
<a class="code" href="classExtractSketch.html" title="Functor class for extracting a subset of data from a larger set.">ExtractSketch&lt;vector&lt;float&gt;::iterator</a> &gt; extractor(sketchSize);
<span class="keywordtype">bool</span> doBioC = <span class="keyword">false</span>; <span class="comment">// Not being compatible with bioconductor.</span>
<span class="comment">// For each microarrays worth of data;</span>
<span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; data.size(); i++) {
  <span class="comment">// Allocate sketch. Don&#39;t forget to delete this later.</span>
  std::vector&lt;float&gt; *pVec = <span class="keyword">new</span> vector&lt;float&gt;(sketchSize);
  <span class="comment">// Extract sketch.</span>
  extractor(data[i].begin(), data[i].end(), pVec-&gt;begin());
  <span class="comment">// Save sketch for later.</span>
  m_Sketches.push_back(pVec-&gt;begin());
}
<span class="comment">// Average sketches together.</span>
<a class="code" href="classAverageSketch.html" title="Combine all the sketches into a summary by averaging them. /// See also: Sketch Quantile Normalizatio...">AverageSketch&lt; vector&lt; vector&lt;float&gt;::iterator</a> &gt;::iterator, vector&lt;float&gt;::iterator, <span class="keywordtype">float</span>&gt; as;
m_AverageSketch.resize(sketchSize);
as(m_Sketches.begin(), m_Sketches.end(), (*m_Sketches.begin()) + sketchSize, m_AverageSketch.begin());
<span class="comment">// Make interpolator for each chip.</span>
<span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; m_Sketches.size(); i++) {
 m_Interpolators.push_back(<a class="code" href="classInterpolateSketch.html" title="Functor class to determine normalized value given raw data point and the vector of sketch values for ...">InterpolateSketch</a>&lt;vector&lt;float&gt;::iterator, <span class="keywordtype">double</span>&gt;(m_Sketches[i], m_Sketches[i] + sketchSize,
                                                                              m_AverageSketch.begin(), 
                                                                              m_AverageSketch.end(), 
                                                                              doBioc));
  }

<span class="comment">// Use interpolators to get normalized values.</span>
<span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; data.size(); i++) {
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; data[i].size(); j++) {
     <span class="keywordtype">float</span> normValue = m_Interpolators[i](data[i][j]);
     <span class="comment">// Do something with our normalized value.</span>
  }
}
</pre></div> </div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2016 12:59:14 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
