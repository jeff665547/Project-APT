<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: translation/TranslationTableModel.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_b6d6d4a2e58a0f89851f849ab50b1d34.html">translation</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>TranslationTableModel.cpp</h1>  </div>
</div>
<div class="contents">
<a href="TranslationTableModel_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00002"></a>00002 <span class="comment"></span><span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// Copyright (C) 2008 Affymetrix, Inc.</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// This program is free software; you can redistribute it and/or modify </span>
<a name="l00006"></a>00006 <span class="comment">// it under the terms of the GNU General Public License (version 2) as </span>
<a name="l00007"></a>00007 <span class="comment">// published by the Free Software Foundation.</span>
<a name="l00008"></a>00008 <span class="comment">// </span>
<a name="l00009"></a>00009 <span class="comment">// This program is distributed in the hope that it will be useful, </span>
<a name="l00010"></a>00010 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<a name="l00011"></a>00011 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU </span>
<a name="l00012"></a>00012 <span class="comment">// General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment">// </span>
<a name="l00014"></a>00014 <span class="comment">// You should have received a copy of the GNU General Public License </span>
<a name="l00015"></a>00015 <span class="comment">// along with this program;if not, write to the </span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// Free Software Foundation, Inc., </span>
<a name="l00018"></a>00018 <span class="comment">// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00019"></a>00019 <span class="comment">//</span><span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00021"></a>00021 <span class="comment"></span><span class="comment">/**</span>
<a name="l00022"></a>00022 <span class="comment"> * @file   TranslationTableModel.cpp</span>
<a name="l00023"></a>00023 <span class="comment"> * @author Mybrid Spalding</span>
<a name="l00024"></a>00024 <span class="comment"> * @date   Tue Mar 18 09:02:01 PDT 2008</span>
<a name="l00025"></a>00025 <span class="comment"> * @brief  Single instance data model class that wraps the translation file in the TranslationInputTsvModel.</span>
<a name="l00026"></a>00026 <span class="comment"> */</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="TranslationTableModel_8h.html" title="Single instance data model class that wraps the translation file in the TranslationInputTsvModel.">translation/TranslationTableModel.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="comment">//</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="CallSet_8h.html" title="A little more functionaliy than using the STL &amp;#39;set&amp;#39; container for CallElement objects...">translation/CallSet.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="comment">//</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="GenoCallCoder_8h.html" title="Genotype call en/decoder.">calvin_files/utils/src/GenoCallCoder.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="comment">//</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00039"></a>00039 <span class="comment">//</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="keyword">using namespace </span>std;
<a name="l00042"></a>00042 <span class="keyword">using namespace </span>affx;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="comment">//Gene Reference Link ProbeSet Switch Design Strand dbSNP Defining cDNA Genomic Change External ID Validated Haplotype Reference Variant A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28 A29</span>
<a name="l00046"></a>00046 <span class="comment">//ABCB1 Reference Link ProbeSet refSNP ID Defining cDNA Nucleotide Position Genomic Nucleotide Position Change External ID Validated Haplotype Reference Variant WT *14 A893S A893T  N44S I829V S400N A599T V801M</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 pcrecpp::RE RE_IGNORE_ROW(<span class="stringliteral">&quot;^\\s*[#]&quot;</span>);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="keyword">const</span> <a class="code" href="classTittmColumnDefinition.html">TittmColumnDefinition</a> TTM_DMET2_COLUMN_DEFINTIONS[] = { <span class="comment">// m_columnName,        m_emptyOk, m_index, m_validRE</span>
<a name="l00051"></a>00051   { std::string(<span class="stringliteral">&quot;Gene&quot;</span>),           0,  0, std::string(<span class="stringliteral">&quot;^[A-Z\\d]+$&quot;</span>), NULL },
<a name="l00052"></a>00052   { std::string(<span class="stringliteral">&quot;Reference Link&quot;</span>), 1,  1, std::string(<span class="stringliteral">&quot;.*&quot;</span>), NULL },
<a name="l00053"></a>00053   { std::string(<span class="stringliteral">&quot;AssayID&quot;</span>),        0,  2,
<a name="l00054"></a>00054     std::string(<span class="stringliteral">&quot;^(?:AssayID)|(?:[\\w\\d]+)|(?:\\#.*)$&quot;</span>), NULL },
<a name="l00055"></a>00055   { std::string(<span class="stringliteral">&quot;dbSNP&quot;</span>),          1,  3,
<a name="l00056"></a>00056     std::string(<span class="stringliteral">&quot;^(?:(?:rs\\d+[|;\\s]*)+|(?:N/?A)|(?:refSNP\\sID)|(?:dbSNP))$&quot;</span>),
<a name="l00057"></a>00057     NULL },
<a name="l00058"></a>00058   { std::string(<span class="stringliteral">&quot;Defining&quot;</span>),       1,  4,
<a name="l00059"></a>00059     std::string(<span class="stringliteral">&quot;^(?:(?:N)|(?:Defining)|(?:\\*?[&gt;A-Za-z\\d\\-\\s\\+]+))$&quot;</span>), NULL },
<a name="l00060"></a>00060   { std::string(<span class="stringliteral">&quot;cDNA&quot;</span>),           1,  5, std::string(<span class="stringliteral">&quot;.*&quot;</span>), NULL },
<a name="l00061"></a>00061   { std::string(<span class="stringliteral">&quot;Genomic&quot;</span>),        1,  6, std::string(<span class="stringliteral">&quot;.*&quot;</span>), NULL },
<a name="l00062"></a>00062   { std::string(<span class="stringliteral">&quot;Change&quot;</span>),         1,  7, std::string(<span class="stringliteral">&quot;.*&quot;</span>), NULL },
<a name="l00063"></a>00063   { std::string(<span class="stringliteral">&quot;External ID&quot;</span>),    1,  8, std::string(<span class="stringliteral">&quot;.*&quot;</span>), NULL },
<a name="l00064"></a>00064   { std::string(<span class="stringliteral">&quot;Validated&quot;</span>),      1,  9,
<a name="l00065"></a>00065     std::string(<span class="stringliteral">&quot;^(?:Validated)|(?:[YN])$&quot;</span>), NULL },
<a name="l00066"></a>00066   { std::string(<span class="stringliteral">&quot;Haplotype&quot;</span>),      1, 10,  std::string(<span class="stringliteral">&quot;(?:Haplotype)|(?:[YN])&quot;</span>), NULL },
<a name="l00067"></a>00067   { std::string(<span class="stringliteral">&quot;Reference&quot;</span>),      1, 11,
<a name="l00068"></a>00068     std::string(<span class="stringliteral">&quot;^(?:Reference)|(?:Minor Allele)|(?:Major Allele)|(?:[ACGT0]+)|(?:INS)|(?:DEL)|(?:-)$&quot;</span>), NULL },
<a name="l00069"></a>00069   { std::string(<span class="stringliteral">&quot;Variant&quot;</span>),        1, 12,
<a name="l00070"></a>00070     std::string(<span class="stringliteral">&quot;^(?:Variant)|(?:Minor Allele)|(?:Major Allele)|(?:[ACGT0]+)|(?:INS)|(?:DEL)|(?:-)$&quot;</span>), NULL },
<a name="l00071"></a>00071 };
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="keyword">const</span> <a class="code" href="classTittmColumnDefinition.html">TittmColumnDefinition</a> TTM_DMET3_COLUMN_DEFINTIONS[] = { <span class="comment">// m_columnName,        m_emptyOk, m_index, m_validRE</span>
<a name="l00074"></a>00074   { std::string(<span class="stringliteral">&quot;Gene&quot;</span>),           0,  0, std::string(<span class="stringliteral">&quot;^[A-Z\\d]+$&quot;</span>), NULL },
<a name="l00075"></a>00075   { std::string(<span class="stringliteral">&quot;Reference Link&quot;</span>), 1,  1, std::string(<span class="stringliteral">&quot;.*&quot;</span>), NULL },
<a name="l00076"></a>00076   { std::string(<span class="stringliteral">&quot;Probe Set ID&quot;</span>),        1,  2,
<a name="l00077"></a>00077     std::string(<span class="stringliteral">&quot;^(?:Probe\\sSet\\sID)|(?:[_\\-\\w\\d]*\\d+)|(?:\\#.*)$&quot;</span>), NULL },
<a name="l00078"></a>00078   { std::string(<span class="stringliteral">&quot;Switch Design Strand to Report&quot;</span>), 1,  3, std::string(<span class="stringliteral">&quot;(?:Switch.Design.Strand.to.Report)|(?:[YN])|(?:\\#.*)$&quot;</span>), NULL },
<a name="l00079"></a>00079   { std::string(<span class="stringliteral">&quot;dbSNP RS ID&quot;</span>),          1,  4,
<a name="l00080"></a>00080     std::string(<span class="stringliteral">&quot;^(?:(?:rs\\d+[|;\\s]*)+|(?:N/?A)|(?:refSNP\\sID)|(?:dbSNP.RS.ID))$&quot;</span>),
<a name="l00081"></a>00081     NULL },
<a name="l00082"></a>00082   { std::string(<span class="stringliteral">&quot;Defining&quot;</span>),       1,  5,
<a name="l00083"></a>00083     std::string(<span class="stringliteral">&quot;^(?:(?:N)|(?:Defining)|(?:\\*?[&gt;A-Za-z\\d\\-\\s\\+]+))$&quot;</span>), NULL },
<a name="l00084"></a>00084   { std::string(<span class="stringliteral">&quot;cDNA Nucleotide Position&quot;</span>), 1,  6, std::string(<span class="stringliteral">&quot;.*&quot;</span>), NULL },
<a name="l00085"></a>00085   { std::string(<span class="stringliteral">&quot;Genome Position&quot;</span>),        1,  7, std::string(<span class="stringliteral">&quot;.*&quot;</span>), NULL },
<a name="l00086"></a>00086   { std::string(<span class="stringliteral">&quot;Change&quot;</span>),         1,  8, std::string(<span class="stringliteral">&quot;.*&quot;</span>), NULL },
<a name="l00087"></a>00087   { std::string(<span class="stringliteral">&quot;Common Name&quot;</span>),    1,  9, std::string(<span class="stringliteral">&quot;.*&quot;</span>), NULL },
<a name="l00088"></a>00088   { std::string(<span class="stringliteral">&quot;Haplotype&quot;</span>),      1, 10,  std::string(<span class="stringliteral">&quot;(?:Haplotype)|(?:[YN])&quot;</span>), NULL },
<a name="l00089"></a>00089   { std::string(<span class="stringliteral">&quot;Reference&quot;</span>),      1, 11,
<a name="l00090"></a>00090     std::string(<span class="stringliteral">&quot;^(?:Reference)|(?:Minor Allele)|(?:Major Allele)|(?:[ACGT0]+)|(?:INS)|(?:DEL)|(?:-)$&quot;</span>), NULL },
<a name="l00091"></a>00091   { std::string(<span class="stringliteral">&quot;Variant&quot;</span>),        1, 12,
<a name="l00092"></a>00092     std::string(<span class="stringliteral">&quot;^(?:Variant)|(?:Minor Allele)|(?:Major Allele)|(?:[ACGT0]+)|(?:INS)|(?:DEL)|(?:-)$&quot;</span>), NULL },
<a name="l00093"></a>00093 };
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="keyword">const</span> <a class="code" href="classTittmColumnDefinition.html">TittmColumnDefinition</a> ALLELE_COLUMN_TEMPLATE = { std::string(<span class="stringliteral">&quot;ANULL&quot;</span>), 1, 0, std::string(<span class="stringliteral">&quot;.*&quot;</span>), NULL };
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 
<a name="l00099"></a><a class="code" href="classDmet3ToDmet2ColumnMap.html">00099</a> <span class="keyword">class </span><a class="code" href="classDmet3ToDmet2ColumnMap.html">Dmet3ToDmet2ColumnMap</a>
<a name="l00100"></a>00100 {
<a name="l00101"></a>00101 <span class="keyword">public</span>:
<a name="l00102"></a>00102   ADT_DMET3_TT_COLUMNS_ENUM m_dmet3Index;
<a name="l00103"></a>00103   ADT_DMET2_TT_COLUMNS_ENUM m_dmet2Index;
<a name="l00104"></a>00104 };
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="keyword">const</span> <a class="code" href="classDmet3ToDmet2ColumnMap.html">Dmet3ToDmet2ColumnMap</a> DMET3_TO_DMET2_COLUMN_MAP[] = {
<a name="l00107"></a>00107   { ADT_DMET3_TT_GENE,  ADT_DMET2_TT_GENE },
<a name="l00108"></a>00108   { ADT_DMET3_TT_REFERENCE_LINK,  ADT_DMET2_TT_REFERENCE_LINK },
<a name="l00109"></a>00109   { ADT_DMET3_TT_PROBE_SET_ID,  ADT_DMET2_TT_ASSAYID },
<a name="l00110"></a>00110   { ADT_DMET3_TT_DBSNP,  ADT_DMET2_TT_DBSNP },
<a name="l00111"></a>00111   { ADT_DMET3_TT_DEFINING,  ADT_DMET2_TT_DEFINING },
<a name="l00112"></a>00112   { ADT_DMET3_TT_CDNA, ADT_DMET2_TT_CDNA },
<a name="l00113"></a>00113   { ADT_DMET3_TT_GENOME_POSITION,  ADT_DMET2_TT_GENOMIC },
<a name="l00114"></a>00114   { ADT_DMET3_TT_CHANGE,  ADT_DMET2_TT_CHANGE },
<a name="l00115"></a>00115   { ADT_DMET3_TT_COMMON_NAME,  ADT_DMET2_TT_EXTERNAL_ID },
<a name="l00116"></a>00116   { ADT_DMET3_TT_HAPLOTYPE, ADT_DMET2_TT_HAPLOTYPE },
<a name="l00117"></a>00117   { ADT_DMET3_TT_REFERENCE, ADT_DMET2_TT_REFERENCE },
<a name="l00118"></a>00118   { ADT_DMET3_TT_VARIANT, ADT_DMET2_TT_VARIANT },
<a name="l00119"></a>00119   { ADT_DMET3_TT_ALLELE_START, ADT_DMET2_TT_ALLELE_START },
<a name="l00120"></a>00120 };
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00123"></a>00123 <span class="comment">/**</span>
<a name="l00124"></a>00124 <span class="comment"> * convertTCDArrayToVector</span>
<a name="l00125"></a>00125 <span class="comment"> * Synopsis:</span>
<a name="l00126"></a>00126 <span class="comment"> </span>
<a name="l00127"></a>00127 <span class="comment"> * Callback function for TranslationInputTsvFile constructor</span>
<a name="l00128"></a>00128 <span class="comment"> * to generate the dynamic allele column definitions for TTM_COLUMN_DEFINTIONS.</span>
<a name="l00129"></a>00129 <span class="comment"> * The reason being is that the</span>
<a name="l00130"></a>00130 <span class="comment"> * number of Allele columns is dynamic and determined by the input file</span>
<a name="l00131"></a>00131 <span class="comment"> * at run time and not before.</span>
<a name="l00132"></a>00132 <span class="comment"> * </span>
<a name="l00133"></a>00133 <span class="comment"> * @param rte - the single instance run time environment</span>
<a name="l00134"></a>00134 <span class="comment"> * @param ttmTCD - the already filled in std::vector to build on the static plus dynamic stuff.</span>
<a name="l00135"></a>00135 <span class="comment"> * @param ttableFileName - the TsvFile for the Translation Table</span>
<a name="l00136"></a>00136 <span class="comment"> *</span>
<a name="l00137"></a>00137 <span class="comment"> * @return true - if ok, parent should throw an exception on false.</span>
<a name="l00138"></a>00138 <span class="comment"> *</span>
<a name="l00139"></a>00139 <span class="comment"> */</span>
<a name="l00140"></a>00140 <span class="comment">/*****************************************************************************/</span>
<a name="l00141"></a>00141 <span class="keyword">static</span> <span class="keywordtype">bool</span> convertTCDArrayToVector(<span class="keyword">const</span> <a class="code" href="classRunTimeEnvironment.html">RunTimeEnvironment</a> &amp; rte, std::vector&lt; TittmColumnDefinition &gt; &amp; ttmTCD, <span class="keyword">const</span> std::string &amp; ttableFileName)
<a name="l00142"></a>00142 {
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <a class="code" href="Err_8h.html#ad024208f4ba6a4e75df4499ea1639a05" title="Calls Err::apt_err_assert with the filename and linenumber set. /// We want to avoid evaluating the m...">APT_ERR_ASSERT</a>(rte.m_adtOpts.m_inputTTableType != ADT_TRANSLATION_TABLE_TYPE_INVALID, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00146"></a>00146 
<a name="l00147"></a>00147   <span class="keywordtype">bool</span> isDmet2 = (rte.m_adtOpts.m_inputTTableType == ADT_TRANSLATION_TABLE_TYPE_DMET2);
<a name="l00148"></a>00148 
<a name="l00149"></a>00149   ttmTCD.clear();
<a name="l00150"></a>00150 
<a name="l00151"></a>00151   std::stringstream msgSStr;
<a name="l00152"></a>00152   <span class="keywordtype">size_t</span>       numStaticDefinitions
<a name="l00153"></a>00153   = isDmet2 ? (size_t) <span class="keyword">sizeof</span>(TTM_DMET2_COLUMN_DEFINTIONS) / <span class="keyword">sizeof</span>(TTM_DMET2_COLUMN_DEFINTIONS[0]) : (<span class="keywordtype">size_t</span>) <span class="keyword">sizeof</span>(TTM_DMET3_COLUMN_DEFINTIONS) / <span class="keyword">sizeof</span>(TTM_DMET3_COLUMN_DEFINTIONS[0]);
<a name="l00154"></a>00154   <span class="keywordtype">bool</span>         okHeaderLine = <span class="keyword">true</span>;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   <span class="keywordflow">if</span> (isDmet2) {
<a name="l00157"></a>00157     <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(ADT_VERBOSE_INPUT_FILES, <span class="stringliteral">&quot;DMET2 translation file format detected.&quot;</span>);
<a name="l00158"></a>00158   } <span class="keywordflow">else</span> {
<a name="l00159"></a>00159     <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(ADT_VERBOSE_INPUT_FILES, <span class="stringliteral">&quot;DMET3 translation file format detected.&quot;</span>);
<a name="l00160"></a>00160   }
<a name="l00161"></a>00161 
<a name="l00162"></a>00162   <span class="comment">// STATIC column definitions</span>
<a name="l00163"></a>00163   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numStaticDefinitions; i++) {
<a name="l00164"></a>00164 
<a name="l00165"></a>00165     <span class="keywordflow">if</span> (isDmet2) {
<a name="l00166"></a>00166       <a class="code" href="Err_8h.html#ad024208f4ba6a4e75df4499ea1639a05" title="Calls Err::apt_err_assert with the filename and linenumber set. /// We want to avoid evaluating the m...">APT_ERR_ASSERT</a>(TTM_DMET2_COLUMN_DEFINTIONS[i].m_index == i, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00167"></a>00167       ttmTCD.push_back(TTM_DMET2_COLUMN_DEFINTIONS[i]);
<a name="l00168"></a>00168     } <span class="keywordflow">else</span> {
<a name="l00169"></a>00169       <a class="code" href="Err_8h.html#ad024208f4ba6a4e75df4499ea1639a05" title="Calls Err::apt_err_assert with the filename and linenumber set. /// We want to avoid evaluating the m...">APT_ERR_ASSERT</a>(TTM_DMET3_COLUMN_DEFINTIONS[i].m_index == i, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00170"></a>00170       ttmTCD.push_back(TTM_DMET3_COLUMN_DEFINTIONS[i]);
<a name="l00171"></a>00171     }
<a name="l00172"></a>00172     ttmTCD.back().m_ignoreRE = <span class="keyword">new</span> pcrecpp::RE(<span class="stringliteral">&quot;^\\#&quot;</span>);
<a name="l00173"></a>00173   }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175   <span class="comment">// The allele columns are dynamic and not fixed.</span>
<a name="l00176"></a>00176   <span class="comment">// Scan the TsvFile headers and pick up the columns that match A\d+.</span>
<a name="l00177"></a>00177 
<a name="l00178"></a>00178   <a class="code" href="classaffx_1_1TsvFile.html" title="A class for reading and writing Tab Seperated Value (TSV) files. /// See the TsvFile format document ...">TsvFile</a> tsv;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180   <span class="comment">//</span>
<a name="l00181"></a>00181   tsv.<a class="code" href="classaffx_1_1TsvFile.html#a0b08c1eea21d4b6a893f57df16521a46" title="remove whitespace from value?">m_optAutoTrim</a>   = <span class="keyword">true</span>; <span class="comment">// remove &#39;&quot;&#39;s</span>
<a name="l00182"></a>00182   tsv.<a class="code" href="classaffx_1_1TsvFile.html#a7b96cab331d9eaec414cfeed75a55e3d" title="Quoting Character.">m_optQuoteChar1</a> = 0;    <span class="comment">// ignore &quot;&#39;&quot;s</span>
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   <span class="keywordflow">if</span> (tsv.<a class="code" href="classaffx_1_1TsvFile.html#a763ce0bbf19b4134d0445aa58e0f5011" title="Opens a file -- attempts to guess some defaults.">open</a>(ttableFileName) != TSV_OK) {
<a name="l00185"></a>00185     <a class="code" href="Err_8h.html#a7e26a673d8901b5bc880dfab285f5309" title="Calls Err::apt_err_abort with the filename and linenumber set.">APT_ERR_ABORT</a>(ttableFileName + <span class="stringliteral">&quot;: failed opening input Tsv file.&quot;</span>);
<a name="l00186"></a>00186   }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188   pcrecpp::RE re(<span class="stringliteral">&quot;^A[\\d]+$&quot;</span>);
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="keywordtype">int</span> numAlleleColumns = 0;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192   <span class="comment">// DYNAMIC Allele column definitions.</span>
<a name="l00193"></a>00193   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = numStaticDefinitions; i &lt; tsv.<a class="code" href="classaffx_1_1TsvFile.html#a94ad901d12ab05cce0f050f99665970f" title="The number of columns for this level ///.">getColumnCount</a>(0) ; i++) {
<a name="l00194"></a>00194 
<a name="l00195"></a>00195     std::string columnName;
<a name="l00196"></a>00196     <span class="keywordtype">bool</span> okAlleleColumn = <span class="keyword">true</span>;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198     <span class="keywordflow">if</span> (tsv.<a class="code" href="classaffx_1_1TsvFile.html#a0958f996be8dea8c5e5d2a0bac36819b" title="Get the name of a column by its level and index.">cidx2cname</a>(0, i, columnName) == TSV_OK) {
<a name="l00199"></a>00199 
<a name="l00200"></a>00200       <span class="keywordflow">if</span> (re.FullMatch(columnName)) {
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="keywordtype">int</span> alleleNum = atoi(columnName.substr(1).c_str());
<a name="l00203"></a>00203 
<a name="l00204"></a>00204         <span class="comment">// Columns must be in consecutive order A1, A2, ... AN</span>
<a name="l00205"></a>00205         <span class="keywordflow">if</span> (alleleNum == (i - numStaticDefinitions + 1)) {
<a name="l00206"></a>00206           numAlleleColumns++;
<a name="l00207"></a>00207           <a class="code" href="classTittmColumnDefinition.html">TittmColumnDefinition</a> alleleTCD = ALLELE_COLUMN_TEMPLATE;
<a name="l00208"></a>00208           alleleTCD.m_index = i;
<a name="l00209"></a>00209           alleleTCD.m_columnName = columnName;
<a name="l00210"></a>00210           ttmTCD.push_back(alleleTCD);
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         } <span class="keywordflow">else</span> {
<a name="l00213"></a>00213           okAlleleColumn = <span class="keyword">false</span>;
<a name="l00214"></a>00214         } <span class="comment">// if the column count matches.</span>
<a name="l00215"></a>00215       } <span class="keywordflow">else</span> {
<a name="l00216"></a>00216         okAlleleColumn = <span class="keyword">false</span>;
<a name="l00217"></a>00217       } <span class="comment">// if the column name matches</span>
<a name="l00218"></a>00218     } <span class="comment">// if the tsv file parsed ok</span>
<a name="l00219"></a>00219     <span class="keywordflow">else</span> {
<a name="l00220"></a>00220       <a class="code" href="Err_8h.html#a7e26a673d8901b5bc880dfab285f5309" title="Calls Err::apt_err_abort with the filename and linenumber set.">APT_ERR_ABORT</a>(<span class="stringliteral">&quot;tsv.cidx2cname returned unexpected error&quot;</span>);
<a name="l00221"></a>00221     } <span class="comment">// if there was a TSV_ERROR</span>
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="keywordflow">if</span> (!okAlleleColumn) {
<a name="l00224"></a>00224       okHeaderLine = <span class="keyword">false</span>;
<a name="l00225"></a>00225       msgSStr &lt;&lt; ttableFileName &lt;&lt; <span class="stringliteral">&quot;: invalid TsvFile header first-line, &quot;</span>;
<a name="l00226"></a>00226       msgSStr &lt;&lt; <span class="stringliteral">&quot;column [&quot;</span> &lt;&lt; (i + 1) &lt;&lt; <span class="stringliteral">&quot;]: found \&quot;&quot;</span> &lt;&lt; columnName &lt;&lt; <span class="stringliteral">&quot;\&quot; but was expecting a consecutive Allele column name with format of A[0-9]+.&quot;</span>;
<a name="l00227"></a>00227       msgSStr &lt;&lt; endl;
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   } <span class="comment">// for each column, inspect it for an Allele name.</span>
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   <span class="keywordflow">if</span> (numAlleleColumns == 0) {
<a name="l00233"></a>00233     okHeaderLine = <span class="keyword">false</span>;
<a name="l00234"></a>00234     msgSStr &lt;&lt; ttableFileName &lt;&lt; <span class="stringliteral">&quot;: invalid TsvFile header first-line, &quot;</span>;
<a name="l00235"></a>00235     msgSStr &lt;&lt; <span class="stringliteral">&quot;no Allele Columns found.&quot;</span> &lt;&lt; endl;
<a name="l00236"></a>00236 
<a name="l00237"></a>00237   }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239   tsv.<a class="code" href="classaffx_1_1TsvFile.html#ae7932be2156c04a562f327b53833aed7" title="Close the file.">close</a>();
<a name="l00240"></a>00240 
<a name="l00241"></a>00241   <span class="keywordflow">if</span> (!okHeaderLine) {
<a name="l00242"></a>00242     <span class="keywordflow">if</span> (numAlleleColumns &gt; 4) {
<a name="l00243"></a>00243       <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(ADT_VERBOSE_NORMAL, msgSStr.str(), <span class="keyword">false</span>);
<a name="l00244"></a>00244     } <span class="keywordflow">else</span> {
<a name="l00245"></a>00245       <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(ADT_VERBOSE_NORMAL, ttableFileName + <span class="stringliteral">&quot;: invalid TsvFile is missing the header line.&quot;</span>, <span class="keyword">false</span>);
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247   }
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   <span class="keywordflow">return</span> okHeaderLine;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 }
<a name="l00252"></a>00252 <span class="comment">// end convertTCDArrayToVector</span>
<a name="l00253"></a>00253 <span class="comment">/*****************************************************************************/</span>
<a name="l00254"></a>00254 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00255"></a>00255 <span class="comment">/**</span>
<a name="l00256"></a>00256 <span class="comment"> * TranslationTableModel::getTranslationTableFileType (STATIC)</span>
<a name="l00257"></a>00257 <span class="comment"> * Synopsis:</span>
<a name="l00258"></a>00258 <span class="comment"> *</span>
<a name="l00259"></a>00259 <span class="comment"> * DMET2 or DMET3 indicator method.</span>
<a name="l00260"></a>00260 <span class="comment"> * </span>
<a name="l00261"></a>00261 <span class="comment"> * The translation table can be either DMET2 or DMET3 format, return</span>
<a name="l00262"></a>00262 <span class="comment"> * the format. Determine the format by inspection. A single DMET common</span>
<a name="l00263"></a>00263 <span class="comment"> * column &quot;Gene&quot; is used to validate the file is a translation table.</span>
<a name="l00264"></a>00264 <span class="comment"> * A specific DMET3 column is used to deferentiate between DMET2 and DMET3.</span>
<a name="l00265"></a>00265 <span class="comment"> *</span>
<a name="l00266"></a>00266 <span class="comment"> * @param ttableFileName - the file to inspect.</span>
<a name="l00267"></a>00267 <span class="comment"> *</span>
<a name="l00268"></a>00268 <span class="comment"> * @return - DMET2, DMET3 or invalid.</span>
<a name="l00269"></a>00269 <span class="comment"> */</span>
<a name="l00270"></a>00270 <span class="comment">/*****************************************************************************/</span>
<a name="l00271"></a><a class="code" href="classTranslationTableModel.html#a680504b5c68e44e743f1063075f8472b">00271</a> <a class="code" href="ADTOptions_8h.html#ad017e2db89620c56dd6aeae86fbe30ef" title="DMET2 and DMET3 are differentiated by column names.">ADT_TRANSLATION_TABLE_TYPE_ENUM</a> <a class="code" href="classTranslationTableModel.html#a680504b5c68e44e743f1063075f8472b" title="TranslationTableModel::getTranslationTableFileType (STATIC) Synopsis:">TranslationTableModel::getTranslationTableFileType</a>(<span class="keyword">const</span> std::string &amp; ttableFileName)
<a name="l00272"></a>00272 {
<a name="l00273"></a>00273 
<a name="l00274"></a>00274   <span class="keywordflow">if</span> (ttableFileName.empty()) {
<a name="l00275"></a>00275     <span class="keywordflow">return</span> ADT_TRANSLATION_TABLE_TYPE_INVALID;
<a name="l00276"></a>00276   }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278   <a class="code" href="classaffx_1_1TsvFile.html" title="A class for reading and writing Tab Seperated Value (TSV) files. /// See the TsvFile format document ...">TsvFile</a> tsv;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280   <span class="comment">//</span>
<a name="l00281"></a>00281   tsv.<a class="code" href="classaffx_1_1TsvFile.html#a0b08c1eea21d4b6a893f57df16521a46" title="remove whitespace from value?">m_optAutoTrim</a>   = <span class="keyword">true</span>; <span class="comment">// remove &#39;&quot;&#39;s</span>
<a name="l00282"></a>00282   tsv.<a class="code" href="classaffx_1_1TsvFile.html#a7b96cab331d9eaec414cfeed75a55e3d" title="Quoting Character.">m_optQuoteChar1</a> = 0;    <span class="comment">// ignore &quot;&#39;&quot;s</span>
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   <span class="keywordflow">if</span> (tsv.<a class="code" href="classaffx_1_1TsvFile.html#a763ce0bbf19b4134d0445aa58e0f5011" title="Opens a file -- attempts to guess some defaults.">open</a>(ttableFileName) != TSV_OK) {
<a name="l00285"></a>00285     <a class="code" href="Err_8h.html#a7e26a673d8901b5bc880dfab285f5309" title="Calls Err::apt_err_abort with the filename and linenumber set.">APT_ERR_ABORT</a>(ttableFileName + <span class="stringliteral">&quot;: failed opening input Tsv file.&quot;</span>);
<a name="l00286"></a>00286   }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   <span class="keyword">const</span> std::string commonName = <span class="stringliteral">&quot;Gene&quot;</span>;
<a name="l00289"></a>00289   <span class="keywordtype">bool</span> commonNameFound = <span class="keyword">false</span>;
<a name="l00290"></a>00290 
<a name="l00291"></a>00291   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; tsv.<a class="code" href="classaffx_1_1TsvFile.html#a94ad901d12ab05cce0f050f99665970f" title="The number of columns for this level ///.">getColumnCount</a>(0) ; i++) {
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     std::string columnName;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295     <span class="keywordflow">if</span> (tsv.<a class="code" href="classaffx_1_1TsvFile.html#a0958f996be8dea8c5e5d2a0bac36819b" title="Get the name of a column by its level and index.">cidx2cname</a>(0, i, columnName) == TSV_OK) {
<a name="l00296"></a>00296 
<a name="l00297"></a>00297       <span class="keywordflow">if</span> (columnName == commonName) {
<a name="l00298"></a>00298         commonNameFound = <span class="keyword">true</span>;
<a name="l00299"></a>00299       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (commonNameFound &amp;&amp; (pcrecpp::RE(<span class="stringliteral">&quot;Switch.Design.Strand&quot;</span>).PartialMatch(columnName))) {
<a name="l00300"></a>00300         <span class="keywordflow">return</span> ADT_TRANSLATION_TABLE_TYPE_DMET3;
<a name="l00301"></a>00301       }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305   }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="keywordflow">if</span> (commonNameFound) {
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="keywordflow">return</span> ADT_TRANSLATION_TABLE_TYPE_DMET2;
<a name="l00311"></a>00311   }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   <span class="keywordflow">return</span> ADT_TRANSLATION_TABLE_TYPE_INVALID;
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 }
<a name="l00316"></a>00316 <span class="comment">// end TranslationTableModel::getTranslationTableFileType</span>
<a name="l00317"></a>00317 <span class="comment">/*****************************************************************************/</span>
<a name="l00318"></a>00318 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00319"></a>00319 <span class="comment">/**</span>
<a name="l00320"></a>00320 <span class="comment"> * TranslationTableModel::TranslationTableModel</span>
<a name="l00321"></a>00321 <span class="comment"> * Synopsis:</span>
<a name="l00322"></a>00322 <span class="comment"> *</span>
<a name="l00323"></a>00323 <span class="comment"> * Main constructor that slurps in the input allele</span>
<a name="l00324"></a>00324 <span class="comment"> * translation table file into main memory a table.</span>
<a name="l00325"></a>00325 <span class="comment"> *</span>
<a name="l00326"></a>00326 <span class="comment"> * @param rte - the run single instance time envrionemnt</span>
<a name="l00327"></a>00327 <span class="comment"> * @param ttableFileName - the translation table to slurp into memory</span>
<a name="l00328"></a>00328 <span class="comment"> * @param ttableFileType - DMET2 or DMET3</span>
<a name="l00329"></a>00329 <span class="comment"> *</span>
<a name="l00330"></a>00330 <span class="comment"> */</span>
<a name="l00331"></a>00331 <span class="comment">/*****************************************************************************/</span>
<a name="l00332"></a>00332 <span class="comment">/*****************************************************************************/</span>
<a name="l00333"></a><a class="code" href="classTranslationTableModel.html#a5c834bd3579ff885f993ed04aa5048f2">00333</a> <a class="code" href="classTranslationTableModel.html#a5c834bd3579ff885f993ed04aa5048f2" title="TranslationTableModel::TranslationTableModel Synopsis:">TranslationTableModel::TranslationTableModel</a>(<span class="keyword">const</span> <a class="code" href="classRunTimeEnvironment.html">RunTimeEnvironment</a> &amp;rte,
<a name="l00334"></a>00334     <span class="keyword">const</span> std::string &amp; ttableFileName,
<a name="l00335"></a>00335     <a class="code" href="ADTOptions_8h.html#ad017e2db89620c56dd6aeae86fbe30ef" title="DMET2 and DMET3 are differentiated by column names.">ADT_TRANSLATION_TABLE_TYPE_ENUM</a> ttableFileType)
<a name="l00336"></a>00336     :
<a name="l00337"></a>00337     <a class="code" href="classTranslationInputTsvTableModel.html">TranslationInputTsvTableModel</a>(rte,
<a name="l00338"></a>00338                                   ttableFileName,
<a name="l00339"></a>00339                                   (ttableFileType == ADT_TRANSLATION_TABLE_TYPE_DMET2) ?  TTM_DMET2_COLUMN_DEFINTIONS : TTM_DMET2_COLUMN_DEFINTIONS,
<a name="l00340"></a>00340                                   (ttableFileType == ADT_TRANSLATION_TABLE_TYPE_DMET2) ? (size_t) sizeof(TTM_DMET2_COLUMN_DEFINTIONS) / sizeof(TTM_DMET2_COLUMN_DEFINTIONS[0]) : (size_t) sizeof(TTM_DMET3_COLUMN_DEFINTIONS) / sizeof(TTM_DMET3_COLUMN_DEFINTIONS[0]),
<a name="l00341"></a>00341                                   false,
<a name="l00342"></a>00342                                   &amp;convertTCDArrayToVector), m_ttableFileType(ttableFileType)
<a name="l00343"></a>00343 {
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   std::string prevGene;
<a name="l00346"></a>00346   std::string gene;
<a name="l00347"></a>00347 
<a name="l00348"></a>00348   <span class="comment">// DMET2 translation table converstion from DMET3 column</span>
<a name="l00349"></a>00349 
<a name="l00350"></a>00350   <span class="keywordtype">int</span> numDmet2Columns = (int) <span class="keyword">sizeof</span>(DMET3_TO_DMET2_COLUMN_MAP) / <span class="keyword">sizeof</span>(DMET3_TO_DMET2_COLUMN_MAP[0]);
<a name="l00351"></a>00351 
<a name="l00352"></a>00352   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numDmet2Columns; i++) {
<a name="l00353"></a>00353     m_dmet3ToDmet2ColumnIndex[DMET3_TO_DMET2_COLUMN_MAP[i].m_dmet3Index]
<a name="l00354"></a>00354     = DMET3_TO_DMET2_COLUMN_MAP[i].m_dmet2Index;
<a name="l00355"></a>00355   }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 
<a name="l00358"></a>00358   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, headerRow = 0; i &lt; m_rows.size(); i++, prevGene = gene) {
<a name="l00359"></a>00359 
<a name="l00360"></a>00360     gene = m_rows[i][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_GENE)];
<a name="l00361"></a>00361 
<a name="l00362"></a>00362     <span class="keywordflow">if</span> (prevGene != gene) {
<a name="l00363"></a>00363       m_geneCopyNumberIndicator[gene] = <span class="keyword">false</span>;
<a name="l00364"></a>00364       headerRow = i;
<a name="l00365"></a>00365     } <span class="keywordflow">else</span> {
<a name="l00366"></a>00366       <span class="comment">// Ok, for tri-allelic markers an probeSet will repeat and not be Unique.</span>
<a name="l00367"></a>00367       <span class="comment">// However, an probeSet can never be in both a Hapoltype group and</span>
<a name="l00368"></a>00368       <span class="comment">// non-Haplotype so repeats are guaranteed to always be the same value.</span>
<a name="l00369"></a>00369       <span class="comment">// Setting multiple times is no harm, no foul.</span>
<a name="l00370"></a>00370       std::string probeSet = m_rows[i][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_PROBE_SET_ID)];
<a name="l00371"></a>00371       m_probeSetToIsHaplotypeMarker[probeSet]
<a name="l00372"></a>00372       = (m_rows[i][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_HAPLOTYPE)] == <span class="stringliteral">&quot;Y&quot;</span>);
<a name="l00373"></a>00373 
<a name="l00374"></a>00374       m_probeSetRowIndex[probeSet].push_back(i);
<a name="l00375"></a>00375       <span class="comment">// Used in probe set filtering.</span>
<a name="l00376"></a>00376       m_probeSetHeaderRowIndex[probeSet] = headerRow;
<a name="l00377"></a>00377     }
<a name="l00378"></a>00378     m_rowHeaderRowIndex[i]             = headerRow;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   }
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 <span class="comment">// end TranslationTableModel::TranslationTableModel</span>
<a name="l00384"></a>00384 <span class="comment">/*****************************************************************************/</span>
<a name="l00385"></a>00385 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00386"></a>00386 <span class="comment">/**</span>
<a name="l00387"></a>00387 <span class="comment"> * TranslationTableModel::probeSetFilter:</span>
<a name="l00388"></a>00388 <span class="comment"> * Synopsis:</span>
<a name="l00389"></a>00389 <span class="comment"> * Filter the translation table with a set of probe set ids passed in</span>
<a name="l00390"></a>00390 <span class="comment"> * using the marker list option (-m, --marker-list).</span>
<a name="l00391"></a>00391 <span class="comment"> *</span>
<a name="l00392"></a>00392 <span class="comment"> * Suppress ProbeSet Ids not in the probe set list within the translation</span>
<a name="l00393"></a>00393 <span class="comment"> * table by ignoring rows in the  &quot;m_rows&quot; data structure. T</span>
<a name="l00394"></a>00394 <span class="comment"> * that would be it pretty much, easy peasy,</span>
<a name="l00395"></a>00395 <span class="comment"> * except we need to collapse overlapping allele names.</span>
<a name="l00396"></a>00396 <span class="comment"> *</span>
<a name="l00397"></a>00397 <span class="comment"> * @param rte - the single instance run time environment</span>
<a name="l00398"></a>00398 <span class="comment"> * @param mlm - The single instance marker list table model (1 column) of probes to use.</span>
<a name="l00399"></a>00399 <span class="comment"> *</span>
<a name="l00400"></a>00400 <span class="comment"> * @return true - if it&#39;s ok to continue runnning.</span>
<a name="l00401"></a>00401 <span class="comment"> */</span>
<a name="l00402"></a>00402 <span class="comment">/*****************************************************************************/</span>
<a name="l00403"></a><a class="code" href="classTranslationTableModel.html#a11d5d4945adc4dec65a4d8521a572b60">00403</a> <span class="keywordtype">bool</span> <a class="code" href="classTranslationTableModel.html#a11d5d4945adc4dec65a4d8521a572b60" title="TranslationTableModel::probeSetFilter: Synopsis: Filter the translation table with a set of probe set...">TranslationTableModel::probeSetFilter</a>(<span class="keyword">const</span> <a class="code" href="classRunTimeEnvironment.html">RunTimeEnvironment</a> &amp; rte, <a class="code" href="classMarkerListModel.html">MarkerListModel</a> &amp; mlm)
<a name="l00404"></a>00404 {
<a name="l00405"></a>00405 
<a name="l00406"></a>00406   <span class="keywordtype">bool</span> okToContinue = <span class="keyword">true</span>;
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 
<a name="l00409"></a>00409   <span class="comment">// deletion in the m_rows is tricky. Deleting the row will</span>
<a name="l00410"></a>00410   <span class="comment">// move the relative positions.</span>
<a name="l00411"></a>00411 
<a name="l00412"></a>00412   std::list&lt; std::string &gt; deleteProbeSetList;
<a name="l00413"></a>00413   std::list&lt; int &gt; deleteRows;
<a name="l00414"></a>00414   std::list&lt; int &gt; deletedHaplotypeMarkers;
<a name="l00415"></a>00415 
<a name="l00416"></a>00416   std::map&lt; std::string, std::vector&lt; int &gt;  &gt;::const_iterator itSVS;
<a name="l00417"></a>00417 
<a name="l00418"></a>00418   <span class="comment">// Put all probe sets into the delete list so they can then be deleted.  </span>
<a name="l00419"></a>00419   <span class="keywordflow">for</span> (itSVS = m_probeSetRowIndex.begin(); itSVS != m_probeSetRowIndex.end(); itSVS++) {
<a name="l00420"></a>00420     deleteProbeSetList.push_back(itSVS-&gt;first);
<a name="l00421"></a>00421   }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423   <span class="comment">// Delete the indicated markers in the delete list.</span>
<a name="l00424"></a>00424   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; okToContinue &amp;&amp; (i &lt; mlm.m_probeSetList.size()); i++) {
<a name="l00425"></a>00425 
<a name="l00426"></a>00426     <span class="keywordflow">if</span> (m_probeSetRowIndex.count(mlm.m_probeSetList[i])) {
<a name="l00427"></a>00427 
<a name="l00428"></a>00428       deleteProbeSetList.remove(mlm.m_probeSetList[i]);
<a name="l00429"></a>00429     }
<a name="l00430"></a>00430   }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432   <span class="keywordflow">if</span> (! okToContinue) {
<a name="l00433"></a>00433     <span class="keywordflow">return</span> okToContinue;
<a name="l00434"></a>00434   }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436   std::list&lt; std::string &gt;::const_iterator itLS;
<a name="l00437"></a>00437 
<a name="l00438"></a>00438   <span class="keywordflow">for</span> (itLS = deleteProbeSetList.begin();
<a name="l00439"></a>00439        (itLS != deleteProbeSetList.end()) &amp;&amp; okToContinue; itLS++) {
<a name="l00440"></a>00440 
<a name="l00441"></a>00441     std::string probeSet = *itLS;
<a name="l00442"></a>00442 
<a name="l00443"></a>00443     <span class="comment">// Multi-allelic probe sets have multiple rows. </span>
<a name="l00444"></a>00444     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m_probeSetRowIndex[probeSet].size(); j++) {
<a name="l00445"></a>00445 
<a name="l00446"></a>00446       <span class="comment">// Do NOT delete the row erstwhile we have indexes that would need</span>
<a name="l00447"></a>00447       <span class="comment">// to be rebuilt. Instead, just mark the row as one to be ignored.</span>
<a name="l00448"></a>00448       <a class="code" href="classTranslationTableModel.html#a590375d07f5f5bf813275858d0466114" title="TranslationTableModel::ignoreRow Synopsis: A setter and getter for ignoring rows in the translation t...">ignoreRow</a>(m_probeSetRowIndex[probeSet][j], <span class="keyword">true</span>);
<a name="l00449"></a>00449 
<a name="l00450"></a>00450       <span class="keywordflow">if</span> (<a class="code" href="classTranslationTableModel.html#a6cdb03c7403f576e8ec4d932072ac446" title="TranslationTableModel::isHaplotypeMarker Synopsis: Is a row a Haplotype row? Yes if the &amp;#39;Haplotyp...">isHaplotypeMarker</a>(probeSet)) {
<a name="l00451"></a>00451         deletedHaplotypeMarkers.push_back(m_probeSetRowIndex[probeSet][j]);
<a name="l00452"></a>00452       }
<a name="l00453"></a>00453     }
<a name="l00454"></a>00454     m_probeSetRowIndex.erase(probeSet);
<a name="l00455"></a>00455   }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   <span class="keywordflow">if</span> (okToContinue &amp;&amp; !deletedHaplotypeMarkers.empty()) {
<a name="l00458"></a>00458     okToContinue = _reconcileDeletedHaplotypeRows(rte, deletedHaplotypeMarkers);
<a name="l00459"></a>00459   }
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="keywordflow">if</span> (m_probeSetRowIndex.size() == 0) {
<a name="l00462"></a>00462     <a class="code" href="Err_8h.html#a7e26a673d8901b5bc880dfab285f5309" title="Calls Err::apt_err_abort with the filename and linenumber set.">APT_ERR_ABORT</a>(<span class="stringliteral">&quot;The translation file has no markers in the supplied marker list.&quot;</span>);
<a name="l00463"></a>00463   }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465   <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(ADT_VERBOSE_NORMAL, <span class="stringliteral">&quot;The translation file has &quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(m_probeSetRowIndex.size()) + <span class="stringliteral">&quot; markers in the supplied marker list.&quot;</span>);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   <span class="comment">// Fix up any indexes that were based upon table row position.</span>
<a name="l00468"></a>00468 
<a name="l00469"></a>00469   <span class="keywordflow">return</span> okToContinue;
<a name="l00470"></a>00470 }
<a name="l00471"></a>00471 <span class="comment">// end TranslationTableModel::probeSetFilter</span>
<a name="l00472"></a>00472 <span class="comment">/*****************************************************************************/</span>
<a name="l00473"></a>00473 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00474"></a>00474 <span class="comment">/**</span>
<a name="l00475"></a>00475 <span class="comment"> * TranslationTableModel::getColumnIndex:</span>
<a name="l00476"></a>00476 <span class="comment"> * Synopsis:</span>
<a name="l00477"></a>00477 <span class="comment"> * DMET2 &amp; DMET3 columns can be retrieved via this API without knowing</span>
<a name="l00478"></a>00478 <span class="comment"> * the table type if the column is shared. For columns distinct to the</span>
<a name="l00479"></a>00479 <span class="comment"> * type, use the ENUM provided for the table. </span>
<a name="l00480"></a>00480 <span class="comment"> *</span>
<a name="l00481"></a>00481 <span class="comment"></span>
<a name="l00482"></a>00482 <span class="comment"> * @param dmet3Column - enum in the header file.</span>
<a name="l00483"></a>00483 <span class="comment"> *</span>
<a name="l00484"></a>00484 <span class="comment"> * @return - the index</span>
<a name="l00485"></a>00485 <span class="comment"> */</span>
<a name="l00486"></a>00486 <span class="comment">/*****************************************************************************/</span>
<a name="l00487"></a><a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041">00487</a> <span class="keywordtype">int</span> <a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">TranslationTableModel::getColumnIndex</a>(ADT_DMET3_TT_COLUMNS_ENUM dmet3Column)<span class="keyword"> const</span>
<a name="l00488"></a>00488 <span class="keyword"></span>{
<a name="l00489"></a>00489 
<a name="l00490"></a>00490   <span class="keywordflow">if</span> (getType() == ADT_TRANSLATION_TABLE_TYPE_DMET3) {
<a name="l00491"></a>00491     <span class="keywordflow">return</span> dmet3Column;
<a name="l00492"></a>00492   }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <span class="keywordflow">if</span> (m_dmet3ToDmet2ColumnIndex.count(dmet3Column) == 0) {
<a name="l00496"></a>00496     <a class="code" href="Err_8h.html#a7e26a673d8901b5bc880dfab285f5309" title="Calls Err::apt_err_abort with the filename and linenumber set.">APT_ERR_ABORT</a>(<a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(dmet3Column) + <span class="stringliteral">&quot;:invalid column index passed to getColumnIndex.&quot;</span>);
<a name="l00497"></a>00497   }
<a name="l00498"></a>00498   <a class="code" href="Err_8h.html#ad024208f4ba6a4e75df4499ea1639a05" title="Calls Err::apt_err_assert with the filename and linenumber set. /// We want to avoid evaluating the m...">APT_ERR_ASSERT</a>(m_dmet3ToDmet2ColumnIndex.count(dmet3Column) &gt; 0, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00499"></a>00499 
<a name="l00500"></a>00500   std::map&lt; ADT_DMET3_TT_COLUMNS_ENUM, ADT_DMET2_TT_COLUMNS_ENUM &gt;::const_iterator it;
<a name="l00501"></a>00501 
<a name="l00502"></a>00502   it = m_dmet3ToDmet2ColumnIndex.find(dmet3Column);
<a name="l00503"></a>00503 
<a name="l00504"></a>00504   <a class="code" href="Err_8h.html#ad024208f4ba6a4e75df4499ea1639a05" title="Calls Err::apt_err_assert with the filename and linenumber set. /// We want to avoid evaluating the m...">APT_ERR_ASSERT</a>(it != m_dmet3ToDmet2ColumnIndex.end(), <span class="stringliteral">&quot;&quot;</span>);
<a name="l00505"></a>00505 
<a name="l00506"></a>00506   <span class="keywordflow">return</span> it-&gt;second;
<a name="l00507"></a>00507 
<a name="l00508"></a>00508 }
<a name="l00509"></a>00509 <span class="comment">// end getColumnIndex</span>
<a name="l00510"></a>00510 <span class="comment">/*****************************************************************************/</span>
<a name="l00511"></a>00511 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00512"></a>00512 <span class="comment">/**</span>
<a name="l00513"></a>00513 <span class="comment"> * getColumnRegex:</span>
<a name="l00514"></a>00514 <span class="comment"> * Synopsis:</span>
<a name="l00515"></a>00515 <span class="comment"> *</span>
<a name="l00516"></a>00516 <span class="comment"> * Returns the validation regular expression std::string for the column.</span>
<a name="l00517"></a>00517 <span class="comment"> *</span>
<a name="l00518"></a>00518 <span class="comment"> * @param index - column index</span>
<a name="l00519"></a>00519 <span class="comment"> *</span>
<a name="l00520"></a>00520 <span class="comment"> * @return - the regex as pcrecpp::RE</span>
<a name="l00521"></a>00521 <span class="comment"> */</span>
<a name="l00522"></a>00522 <span class="comment">/*****************************************************************************/</span>
<a name="l00523"></a><a class="code" href="classTranslationTableModel.html#a2fa9361d15dbd4dd70ba289b9b998e23">00523</a> pcrecpp::RE <a class="code" href="classTranslationTableModel.html#a2fa9361d15dbd4dd70ba289b9b998e23" title="getColumnRegex: Synopsis:">TranslationTableModel::getColumnRegex</a>(<span class="keywordtype">int</span> index)
<a name="l00524"></a>00524 {
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   <span class="keywordflow">if</span> (index &lt; m_columnDefinition.size()) {
<a name="l00527"></a>00527 
<a name="l00528"></a>00528     <span class="keywordflow">return</span> m_columnDefinition[index].m_validRE;
<a name="l00529"></a>00529   }
<a name="l00530"></a>00530 
<a name="l00531"></a>00531   <span class="comment">// convert int to std::string</span>
<a name="l00532"></a>00532   std::stringstream ss;
<a name="l00533"></a>00533   ss &lt;&lt; index;
<a name="l00534"></a>00534   std::string indexAsString = ss.str();
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   <a class="code" href="Err_8h.html#a7e26a673d8901b5bc880dfab285f5309" title="Calls Err::apt_err_abort with the filename and linenumber set.">APT_ERR_ABORT</a>(indexAsString + std::string(<span class="stringliteral">&quot;: programing Error: bad column index passed to TranslationTableModel::getColumnIndex&quot;</span>));
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   <span class="keywordflow">return</span> pcrecpp::RE(<span class="stringliteral">&quot;&quot;</span>);
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 }
<a name="l00541"></a>00541 <span class="comment">// end TranslationTableModel::getColumnRegex</span>
<a name="l00542"></a>00542 <span class="comment">/*****************************************************************************/</span>
<a name="l00543"></a>00543 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00544"></a>00544 <span class="comment">/**</span>
<a name="l00545"></a>00545 <span class="comment"> * TranslationTableModel::getCopyNumberColumn:</span>
<a name="l00546"></a>00546 <span class="comment"> * Synopsis:</span>
<a name="l00547"></a>00547 <span class="comment"> *</span>
<a name="l00548"></a>00548 <span class="comment"> * The allele columns A1 - AN do not normally parsed for the non-haploypte</span>
<a name="l00549"></a>00549 <span class="comment"> * markers. However, the copy number column is the</span>
<a name="l00550"></a>00550 <span class="comment"> * exception. This API returns the ANN column of the copy number designation</span>
<a name="l00551"></a>00551 <span class="comment"> * or -1 if no copy number column is found.</span>
<a name="l00552"></a>00552 <span class="comment"> *</span>
<a name="l00553"></a>00553 <span class="comment"> *</span>
<a name="l00554"></a>00554 <span class="comment"> * @param row - A data row in the translation table model</span>
<a name="l00555"></a>00555 <span class="comment"> *</span>
<a name="l00556"></a>00556 <span class="comment"> * @return - the column index if found or -1 else.</span>
<a name="l00557"></a>00557 <span class="comment"> */</span>
<a name="l00558"></a>00558 <span class="comment">/*****************************************************************************/</span>
<a name="l00559"></a><a class="code" href="classTranslationTableModel.html#a9748ec04f92938fdd4e04bf685d86186">00559</a> <span class="keywordtype">int</span> <a class="code" href="classTranslationTableModel.html#a9748ec04f92938fdd4e04bf685d86186" title="TranslationTableModel::getCopyNumberColumn: Synopsis:">TranslationTableModel::getCopyNumberColumn</a>(<span class="keywordtype">int</span> row)
<a name="l00560"></a>00560 {
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   <span class="keywordflow">if</span> (m_rowCopyNumberColumn.count(row) &gt; 0) {
<a name="l00563"></a>00563     <span class="keywordflow">return</span> m_rowCopyNumberColumn[row];
<a name="l00564"></a>00564   }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566   m_rowCopyNumberColumn[row] = -1;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_ALLELE_START); i &lt; <a class="code" href="classTranslationInputTsvTableModel.html#ae33ba37f59967a7bd0caefe58de785ed" title="TranslationInputTsvTableModel::columnCount Synopsis:">columnCount</a>(); i++) {
<a name="l00569"></a>00569 
<a name="l00570"></a>00570     <span class="keywordflow">if</span> (m_rows[row][i] == <span class="stringliteral">&quot;0&quot;</span>) {
<a name="l00571"></a>00571       m_rowCopyNumberColumn[row] = i;
<a name="l00572"></a>00572       <span class="keywordflow">break</span>;
<a name="l00573"></a>00573     }
<a name="l00574"></a>00574   }
<a name="l00575"></a>00575 
<a name="l00576"></a>00576   <span class="keywordflow">return</span>  m_rowCopyNumberColumn[row] ;
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 }
<a name="l00579"></a>00579 <span class="comment">// end TranslationTableModel::getCopyNumberColumn</span>
<a name="l00580"></a>00580 <span class="comment">/*****************************************************************************/</span>
<a name="l00581"></a>00581 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00582"></a>00582 <span class="comment">/**</span>
<a name="l00583"></a>00583 <span class="comment"> * TranslationTableModel::getHaplotypeAlleleColumns</span>
<a name="l00584"></a>00584 <span class="comment"> * Synopsis:</span>
<a name="l00585"></a>00585 <span class="comment"> * </span>
<a name="l00586"></a>00586 <span class="comment"> * If a  Translation Table row is Haplotype then there will be</span>
<a name="l00587"></a>00587 <span class="comment"> * one or more allele name columns (A1 - A29) with an entry.</span>
<a name="l00588"></a>00588 <span class="comment"> *</span>
<a name="l00589"></a>00589 <span class="comment"> * If this method returns a size() of 0 then this means the row</span>
<a name="l00590"></a>00590 <span class="comment"> * was non-descriptive, technically an illegal condition for a Haplotype.</span>
<a name="l00591"></a>00591 <span class="comment"> * The exception is  not thrown  here but</span>
<a name="l00592"></a>00592 <span class="comment"> * rather the responsiblity of the callee.</span>
<a name="l00593"></a>00593 <span class="comment"> *</span>
<a name="l00594"></a>00594 <span class="comment"> * @param row - integer of the row, 0 based</span>
<a name="l00595"></a>00595 <span class="comment"> * @param sartColumn - typically &quot;Reference&quot;.</span>
<a name="l00596"></a>00596 <span class="comment"> * </span>
<a name="l00597"></a>00597 <span class="comment"> * @return alleleCols- the std::vector&lt;int&gt; of columns that have stuff.</span>
<a name="l00598"></a>00598 <span class="comment"> */</span>
<a name="l00599"></a>00599 <span class="comment">/*****************************************************************************/</span>
<a name="l00600"></a><a class="code" href="classTranslationTableModel.html#af072cea2e362c21c8433939b9f6bde66">00600</a> std::vector&lt;int&gt; <a class="code" href="classTranslationTableModel.html#af072cea2e362c21c8433939b9f6bde66" title="TranslationTableModel::getHaplotypeAlleleColumns Synopsis:">TranslationTableModel::getHaplotypeAlleleColumns</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> row ,
<a name="l00601"></a>00601     <span class="keyword">const</span> <span class="keywordtype">int</span> startColumn)
<a name="l00602"></a>00602 {
<a name="l00603"></a>00603 
<a name="l00604"></a>00604   std::vector&lt;int&gt; alleleCols;
<a name="l00605"></a>00605 
<a name="l00606"></a>00606   <span class="keywordtype">int</span> startIndex = <a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_REFERENCE);
<a name="l00607"></a>00607 
<a name="l00608"></a>00608   <span class="keywordflow">if</span> (startColumn &gt;= 0) {
<a name="l00609"></a>00609     startIndex = startColumn;
<a name="l00610"></a>00610   }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   pcrecpp::RE re(<span class="stringliteral">&quot;^\\s*#&quot;</span>);
<a name="l00613"></a>00613   <span class="comment">// Skip commented out column names.</span>
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j =  startIndex;j &lt; <a class="code" href="classTranslationInputTsvTableModel.html#ae33ba37f59967a7bd0caefe58de785ed" title="TranslationInputTsvTableModel::columnCount Synopsis:">columnCount</a>(); j++) {
<a name="l00616"></a>00616 
<a name="l00617"></a>00617     std::string alleleName = m_rows[row][j];
<a name="l00618"></a>00618     <span class="keywordflow">if</span> (! alleleName.empty() &amp;&amp; !re.PartialMatch(alleleName)) {
<a name="l00619"></a>00619       alleleCols.push_back(j);
<a name="l00620"></a>00620     }
<a name="l00621"></a>00621   }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623   <span class="keywordflow">return</span> alleleCols;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 }
<a name="l00626"></a>00626 <span class="comment">// end TranslationTableModel::getHaplotypeAlleleColumns</span>
<a name="l00627"></a>00627 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00628"></a>00628 <span class="comment">/**</span>
<a name="l00629"></a>00629 <span class="comment"> * TranslationTableModel::getHeaderRowgetHeaderRow:</span>
<a name="l00630"></a>00630 <span class="comment"> * Synopsis:</span>
<a name="l00631"></a>00631 <span class="comment"> *</span>
<a name="l00632"></a>00632 <span class="comment"> * Given some arbitrary row in the table this routine looks</span>
<a name="l00633"></a>00633 <span class="comment"> *  back (up) for the first lower index row header corresponsing to the</span>
<a name="l00634"></a>00634 <span class="comment"> *  later child row. An invalid row will case an assert error.</span>
<a name="l00635"></a>00635 <span class="comment"> *</span>
<a name="l00636"></a>00636 <span class="comment"> * @param childRow - the child row in question.</span>
<a name="l00637"></a>00637 <span class="comment"> *</span>
<a name="l00638"></a>00638 <span class="comment"> * @return row - an integer in the set [0-childRow) corresponding to the gene heeader for that marker. </span>
<a name="l00639"></a>00639 <span class="comment"> */</span>
<a name="l00640"></a>00640 <span class="comment">/*****************************************************************************/</span>
<a name="l00641"></a><a class="code" href="classTranslationTableModel.html#abd5a952b613ca007ed4fc4ac4e12f524">00641</a> <span class="keywordtype">int</span> <a class="code" href="classTranslationTableModel.html#abd5a952b613ca007ed4fc4ac4e12f524" title="TranslationTableModel::getHeaderRowgetHeaderRow: Synopsis:">TranslationTableModel::getHeaderRow</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> childRow)
<a name="l00642"></a>00642 {
<a name="l00643"></a>00643 
<a name="l00644"></a>00644   std::map&lt; int, int&gt;::const_iterator itSI
<a name="l00645"></a>00645   = m_rowHeaderRowIndex.find(childRow);
<a name="l00646"></a>00646 
<a name="l00647"></a>00647   <span class="keywordflow">if</span> (itSI == m_rowHeaderRowIndex.end()) {
<a name="l00648"></a>00648     cerr &lt;&lt; <span class="stringliteral">&quot;getHeaderRow: programming error with invalid childRow: &quot;</span>;
<a name="l00649"></a>00649     cerr &lt;&lt; childRow &lt;&lt; endl;
<a name="l00650"></a>00650     <a class="code" href="Err_8h.html#ad024208f4ba6a4e75df4499ea1639a05" title="Calls Err::apt_err_assert with the filename and linenumber set. /// We want to avoid evaluating the m...">APT_ERR_ASSERT</a>(itSI != m_rowHeaderRowIndex.end(), <span class="stringliteral">&quot;&quot;</span>);
<a name="l00651"></a>00651   }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653   <span class="keywordflow">return</span> itSI-&gt;second;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655 }
<a name="l00656"></a>00656 <span class="comment">// end TranslationTableModel::getHeaderRow</span>
<a name="l00657"></a>00657 <span class="comment">/*****************************************************************************/</span>
<a name="l00658"></a>00658 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00659"></a>00659 <span class="comment">/**</span>
<a name="l00660"></a>00660 <span class="comment"> * TranslationTableModel::getHeaderRowColumnName</span>
<a name="l00661"></a>00661 <span class="comment"> * Synopsis:</span>
<a name="l00662"></a>00662 <span class="comment"> * A header row repeats the descriptive headers for common columns and</span>
<a name="l00663"></a>00663 <span class="comment"> * has custom headings for allele columns. Sometimes we can&#39;t just use the</span>
<a name="l00664"></a>00664 <span class="comment"> * headings provided in the Translation Table for business purposes. For</span>
<a name="l00665"></a>00665 <span class="comment"> * those cases we std::map the column to the business requirement.</span>
<a name="l00666"></a>00666 <span class="comment"> *</span>
<a name="l00667"></a>00667 <span class="comment"> *</span>
<a name="l00668"></a>00668 <span class="comment"> * @param headerRow - integer of the row, 0 based which contains a header</span>
<a name="l00669"></a>00669 <span class="comment"> * @param column   - integer of the column</span>
<a name="l00670"></a>00670 <span class="comment"> *</span>
<a name="l00671"></a>00671 <span class="comment"> * @returns columnName - may be different than the data for business purposes.</span>
<a name="l00672"></a>00672 <span class="comment"> */</span>
<a name="l00673"></a>00673 <span class="comment">/*****************************************************************************/</span>
<a name="l00674"></a><a class="code" href="classTranslationTableModel.html#a9569cee6d0e635259f07dbd8cbd99596">00674</a> std::string <a class="code" href="classTranslationTableModel.html#a9569cee6d0e635259f07dbd8cbd99596" title="TranslationTableModel::getHeaderRowColumnName Synopsis: A header row repeats the descriptive headers ...">TranslationTableModel::getHeaderRowColumnName</a>(<span class="keywordtype">int</span> headerRow,
<a name="l00675"></a>00675     <span class="keywordtype">int</span> column)
<a name="l00676"></a>00676 {
<a name="l00677"></a>00677 
<a name="l00678"></a>00678 
<a name="l00679"></a>00679   <a class="code" href="classTranslationTableModel.html#acf1658f2cce028d22fa3f8666682acde" title="TranslationTableModel::validateRowIsHeader Synopsis:">validateRowIsHeader</a>(headerRow);
<a name="l00680"></a>00680 
<a name="l00681"></a>00681   std::string columnName;
<a name="l00682"></a>00682 
<a name="l00683"></a>00683   <span class="keywordflow">if</span> (column == <a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_REFERENCE)) {
<a name="l00684"></a>00684     columnName = <span class="stringliteral">&quot;Ref&quot;</span>;
<a name="l00685"></a>00685   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (column == <a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_VARIANT)) {
<a name="l00686"></a>00686     columnName = <span class="stringliteral">&quot;Var&quot;</span>;
<a name="l00687"></a>00687   } <span class="keywordflow">else</span> {
<a name="l00688"></a>00688     columnName = m_rows[headerRow][column];
<a name="l00689"></a>00689   }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691   <span class="keywordflow">return</span> columnName;
<a name="l00692"></a>00692 
<a name="l00693"></a>00693 }
<a name="l00694"></a>00694 <span class="comment">// end TranslationTableModel::getHeaderRowColumnName</span>
<a name="l00695"></a>00695 <span class="comment">/*****************************************************************************/</span>
<a name="l00696"></a>00696 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00697"></a>00697 <span class="comment">/**</span>
<a name="l00698"></a>00698 <span class="comment"> * TranslationTableModel::getProbeSetRowIndex</span>
<a name="l00699"></a>00699 <span class="comment"> * Synopsis:</span>
<a name="l00700"></a>00700 <span class="comment"> *</span>
<a name="l00701"></a>00701 <span class="comment"> *  Gets a probe set (assay id) row index. For multi-allelic probes with</span>
<a name="l00702"></a>00702 <span class="comment"> *  multiple rows in the translation table then a relative row (0,1,..count)</span>
<a name="l00703"></a>00703 <span class="comment"> *  needs to be supplied.</span>
<a name="l00704"></a>00704 <span class="comment"> *</span>
<a name="l00705"></a>00705 <span class="comment"> * @param probeSet - the assay id</span>
<a name="l00706"></a>00706 <span class="comment"> * @param multiAllelicRow - the relative row based upon the count, typically</span>
<a name="l00707"></a>00707 <span class="comment"> *                          just 0 or 1.</span>
<a name="l00708"></a>00708 <span class="comment"> *</span>
<a name="l00709"></a>00709 <span class="comment"> * @return - the row in the translation table, -1 of the probeSet is not found.</span>
<a name="l00710"></a>00710 <span class="comment"> */</span>
<a name="l00711"></a>00711 <span class="comment">/*****************************************************************************/</span>
<a name="l00712"></a><a class="code" href="classTranslationTableModel.html#a078d4379d11cfc09e6d074c2ac0155c1">00712</a> <span class="keywordtype">int</span> <a class="code" href="classTranslationTableModel.html#a078d4379d11cfc09e6d074c2ac0155c1" title="TranslationTableModel::getProbeSetRowIndex Synopsis:">TranslationTableModel::getProbeSetRowIndex</a>(<span class="keyword">const</span> std::string &amp; probeSet, <span class="keywordtype">int</span> multiAllelicRow)<span class="keyword"> const</span>
<a name="l00713"></a>00713 <span class="keyword"></span>{
<a name="l00714"></a>00714 
<a name="l00715"></a>00715   std::map&lt;std::string, std::vector&lt;int&gt; &gt;::const_iterator itSI;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717   itSI = m_probeSetRowIndex.find(probeSet);
<a name="l00718"></a>00718 
<a name="l00719"></a>00719   <span class="keywordflow">if</span> (itSI == m_probeSetRowIndex.end()) {
<a name="l00720"></a>00720     <span class="keywordflow">return</span> -1;
<a name="l00721"></a>00721   }
<a name="l00722"></a>00722 
<a name="l00723"></a>00723   <a class="code" href="Err_8h.html#ad024208f4ba6a4e75df4499ea1639a05" title="Calls Err::apt_err_assert with the filename and linenumber set. /// We want to avoid evaluating the m...">APT_ERR_ASSERT</a>(multiAllelicRow &lt; itSI-&gt;second.size(), <span class="stringliteral">&quot;&quot;</span>);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725   <span class="keywordflow">return</span> (itSI-&gt;second[multiAllelicRow]);
<a name="l00726"></a>00726 
<a name="l00727"></a>00727 }
<a name="l00728"></a>00728 <span class="comment">// end TranslationTableModel::getProbeSetRowIndex</span>
<a name="l00729"></a>00729 <span class="comment">/*****************************************************************************/</span>
<a name="l00730"></a>00730 
<a name="l00731"></a>00731 <span class="keywordtype">int</span> TranslationTableModel::getProbeSetNumRows(<span class="keyword">const</span> std::string &amp; probeSet)<span class="keyword"> const</span>
<a name="l00732"></a>00732 <span class="keyword"></span>{
<a name="l00733"></a>00733 
<a name="l00734"></a>00734   std::map&lt;std::string, std::vector&lt;int&gt; &gt;::const_iterator itSI;
<a name="l00735"></a>00735 
<a name="l00736"></a>00736   itSI = m_probeSetRowIndex.find(probeSet);
<a name="l00737"></a>00737 
<a name="l00738"></a>00738   <span class="keywordflow">if</span> (itSI == m_probeSetRowIndex.end()) {
<a name="l00739"></a>00739     <span class="keywordflow">return</span> 0;
<a name="l00740"></a>00740   }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742   <span class="keywordflow">return</span> itSI-&gt;second.size();
<a name="l00743"></a>00743 }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00746"></a>00746 <span class="comment">/**</span>
<a name="l00747"></a>00747 <span class="comment"> * TranslationTableModel::getProbeSetRowIndexSize</span>
<a name="l00748"></a>00748 <span class="comment"> * Synopsis:</span>
<a name="l00749"></a>00749 <span class="comment"> *</span>
<a name="l00750"></a>00750 <span class="comment"> * Counts the number rows a probe set (assay id) appears in the translation</span>
<a name="l00751"></a>00751 <span class="comment"> * table. Multi-allelic will appear more than once. </span>
<a name="l00752"></a>00752 <span class="comment"> *</span>
<a name="l00753"></a>00753 <span class="comment"> * @param probeSet - the assay id</span>
<a name="l00754"></a>00754 <span class="comment"> * @param multiAllelicRow - the relative row based upon the count, typically</span>
<a name="l00755"></a>00755 <span class="comment"> *                          just 0 or 1.</span>
<a name="l00756"></a>00756 <span class="comment"> *</span>
<a name="l00757"></a>00757 <span class="comment"> * @return - the size (number of rows, i.e. 1 for bi-allelic), -1 if the</span>
<a name="l00758"></a>00758 <span class="comment"> *           probeSet is not found.</span>
<a name="l00759"></a>00759 <span class="comment"> */</span>
<a name="l00760"></a>00760 <span class="comment">/*****************************************************************************/</span>
<a name="l00761"></a><a class="code" href="classTranslationTableModel.html#a03b5a73047860a99af4be49f9c358b2b">00761</a> <span class="keywordtype">int</span> <a class="code" href="classTranslationTableModel.html#a03b5a73047860a99af4be49f9c358b2b" title="TranslationTableModel::getProbeSetRowIndexSize Synopsis:">TranslationTableModel::getProbeSetRowIndexSize</a>(<span class="keyword">const</span>  std::string &amp; probeSet)<span class="keyword"> const</span>
<a name="l00762"></a>00762 <span class="keyword"></span>{
<a name="l00763"></a>00763 
<a name="l00764"></a>00764   std::map&lt;std::string, std::vector&lt;int&gt; &gt;::const_iterator itSI;
<a name="l00765"></a>00765 
<a name="l00766"></a>00766   itSI = m_probeSetRowIndex.find(probeSet);
<a name="l00767"></a>00767 
<a name="l00768"></a>00768   <span class="keywordflow">if</span> (itSI == m_probeSetRowIndex.end()) {
<a name="l00769"></a>00769     <span class="keywordflow">return</span> -1;
<a name="l00770"></a>00770   }
<a name="l00771"></a>00771 
<a name="l00772"></a>00772   <span class="keywordflow">return</span> (itSI-&gt;second.size());
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 }
<a name="l00775"></a>00775 <span class="comment">// end TranslationTableModel::getProbeSetRowIndexSize</span>
<a name="l00776"></a>00776 <span class="comment">/*****************************************************************************/</span>
<a name="l00777"></a>00777 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00778"></a>00778 <span class="comment">/**</span>
<a name="l00779"></a>00779 <span class="comment"> * TranslationTableModel::getReportAllele</span>
<a name="l00780"></a>00780 <span class="comment"> * Synopsis:</span>
<a name="l00781"></a>00781 <span class="comment"> * </span>
<a name="l00782"></a>00782 <span class="comment"> * A lookup into the previously set &quot;m_reportAlleles&quot; index. </span>
<a name="l00783"></a>00783 <span class="comment"> *</span>
<a name="l00784"></a>00784 <span class="comment"> * @param probeSet - half the key</span>
<a name="l00785"></a>00785 <span class="comment"> * @param allele -  the other haf of the key </span>
<a name="l00786"></a>00786 <span class="comment"> * </span>
<a name="l00787"></a>00787 <span class="comment"> *</span>
<a name="l00788"></a>00788 <span class="comment"> * @return reportAllele - the report allele if it exists. </span>
<a name="l00789"></a>00789 <span class="comment"> */</span>
<a name="l00790"></a>00790 <span class="comment">/*****************************************************************************/</span>
<a name="l00791"></a><a class="code" href="classTranslationTableModel.html#a0d5cf32bb7c3a56543767bf15b51834b">00791</a> std::string <a class="code" href="classTranslationTableModel.html#a0d5cf32bb7c3a56543767bf15b51834b" title="TranslationTableModel::getReportAllele Synopsis:">TranslationTableModel::getReportAllele</a>( <span class="keyword">const</span> std::string probeSet, <span class="keyword">const</span> std::string allele ) {
<a name="l00792"></a>00792 
<a name="l00793"></a>00793   std::string key = probeSet + <span class="stringliteral">&quot;:&quot;</span> + allele;
<a name="l00794"></a>00794 
<a name="l00795"></a>00795   <span class="keywordflow">if</span> ( m_reportAlleles.count( key ) &gt; 0 ) {
<a name="l00796"></a>00796     <span class="keywordflow">return</span> m_reportAlleles[key];
<a name="l00797"></a>00797   }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799   <span class="keywordflow">return</span> allele;
<a name="l00800"></a>00800 
<a name="l00801"></a>00801 }
<a name="l00802"></a>00802 <span class="comment">// end TranslationTableModel::getReportAllele</span>
<a name="l00803"></a>00803 <span class="comment">/*****************************************************************************/</span>
<a name="l00804"></a>00804 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00805"></a>00805 <span class="comment">/**</span>
<a name="l00806"></a>00806 <span class="comment"> * TranslationTableModel::ignoreRow</span>
<a name="l00807"></a>00807 <span class="comment"> * Synopsis:</span>
<a name="l00808"></a>00808 <span class="comment"> * A setter and getter for ignoring rows in the translation table</span>
<a name="l00809"></a>00809 <span class="comment"> * via a commented out probe set id column.</span>
<a name="l00810"></a>00810 <span class="comment"> * </span>
<a name="l00811"></a>00811 <span class="comment"> * Business logic surrounding when a translation table row is to be</span>
<a name="l00812"></a>00812 <span class="comment"> * ignored. Currently this is only when the ProbeSet column begins with</span>
<a name="l00813"></a>00813 <span class="comment"> * &#39;#&#39;. If this every changes add the business logic here.</span>
<a name="l00814"></a>00814 <span class="comment"> *</span>
<a name="l00815"></a>00815 <span class="comment"> * @param row - the row in question, 0 based.</span>
<a name="l00816"></a>00816 <span class="comment"> * @param bool - assignIgnore, set rather than get which results in &#39;#&#39; being prepended to the probe set id.</span>
<a name="l00817"></a>00817 <span class="comment"> *</span>
<a name="l00818"></a>00818 <span class="comment"> * @return true - indicates to ignore this row.</span>
<a name="l00819"></a>00819 <span class="comment"> */</span>
<a name="l00820"></a>00820 <span class="comment">/*****************************************************************************/</span>
<a name="l00821"></a><a class="code" href="classTranslationTableModel.html#a590375d07f5f5bf813275858d0466114">00821</a> <span class="keywordtype">bool</span> <a class="code" href="classTranslationTableModel.html#a590375d07f5f5bf813275858d0466114" title="TranslationTableModel::ignoreRow Synopsis: A setter and getter for ignoring rows in the translation t...">TranslationTableModel::ignoreRow</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> row, <span class="keywordtype">bool</span> assignIgnore)
<a name="l00822"></a>00822 {
<a name="l00823"></a>00823 
<a name="l00824"></a>00824 
<a name="l00825"></a>00825   <span class="keywordtype">bool</span> okRow = <span class="keyword">true</span>;
<a name="l00826"></a>00826 
<a name="l00827"></a>00827   <a class="code" href="Err_8h.html#ad024208f4ba6a4e75df4499ea1639a05" title="Calls Err::apt_err_assert with the filename and linenumber set. /// We want to avoid evaluating the m...">APT_ERR_ASSERT</a>((row &gt;= 0) &amp;&amp; (row &lt; m_rows.size()), <span class="stringliteral">&quot;&quot;</span>);
<a name="l00828"></a>00828 
<a name="l00829"></a>00829   <span class="keywordflow">if</span> (assignIgnore) {
<a name="l00830"></a>00830     m_rows[row][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_PROBE_SET_ID)] = <span class="stringliteral">&quot;#&quot;</span> + m_rows[row][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_PROBE_SET_ID)];
<a name="l00831"></a>00831   } <span class="keywordflow">else</span> {
<a name="l00832"></a>00832 
<a name="l00833"></a>00833     okRow = RE_IGNORE_ROW.PartialMatch(m_rows[row][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_PROBE_SET_ID)]);
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   }
<a name="l00836"></a>00836 
<a name="l00837"></a>00837   <span class="keywordflow">return</span> okRow;
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 }
<a name="l00840"></a>00840 <span class="comment">// end TranslationTableModel::ignoreRow</span>
<a name="l00841"></a>00841 <span class="comment">/*****************************************************************************/</span>
<a name="l00842"></a>00842 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00843"></a>00843 <span class="comment">/**</span>
<a name="l00844"></a>00844 <span class="comment"> * TranslationTableModel::isHaplotypeMarker</span>
<a name="l00845"></a>00845 <span class="comment"> * Synopsis:</span>
<a name="l00846"></a>00846 <span class="comment"> * Is a row a Haplotype row? Yes if the &#39;Haplotype&#39; column contains a &#39;Y&#39;.</span>
<a name="l00847"></a>00847 <span class="comment"> *  </span>
<a name="l00848"></a>00848 <span class="comment"> * Vagaries of the STL std::map. If an access to a std::map key doesn&#39;t exist it</span>
<a name="l00849"></a>00849 <span class="comment"> * gets created. We don&#39;t want that. Therefore we break out this</span>
<a name="l00850"></a>00850 <span class="comment"> * function to do the iterator look up.</span>
<a name="l00851"></a>00851 <span class="comment"> * If an unknown probeSet is passed then false is returned.</span>
<a name="l00852"></a>00852 <span class="comment"> *</span>
<a name="l00853"></a>00853 <span class="comment"> *</span>
<a name="l00854"></a>00854 <span class="comment"> * @param probeSet - probeSet within the translation table.</span>
<a name="l00855"></a>00855 <span class="comment"> * </span>
<a name="l00856"></a>00856 <span class="comment"> * @return true - the probeSet exists and Haplotype column is marked &#39;Y&#39;.</span>
<a name="l00857"></a>00857 <span class="comment"> */</span>
<a name="l00858"></a>00858 <span class="comment">/*****************************************************************************/</span>
<a name="l00859"></a><a class="code" href="classTranslationTableModel.html#a6cdb03c7403f576e8ec4d932072ac446">00859</a> <span class="keywordtype">bool</span> <a class="code" href="classTranslationTableModel.html#a6cdb03c7403f576e8ec4d932072ac446" title="TranslationTableModel::isHaplotypeMarker Synopsis: Is a row a Haplotype row? Yes if the &amp;#39;Haplotyp...">TranslationTableModel::isHaplotypeMarker</a>(<span class="keyword">const</span> std::string &amp; probeSet)<span class="keyword"> const</span>
<a name="l00860"></a>00860 <span class="keyword"></span>{
<a name="l00861"></a>00861 
<a name="l00862"></a>00862   <span class="keywordflow">if</span> (m_probeSetToIsHaplotypeMarker.count(probeSet) == 0) {
<a name="l00863"></a>00863     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00864"></a>00864   }
<a name="l00865"></a>00865 
<a name="l00866"></a>00866   std::map&lt; std::string, bool &gt;::const_iterator it =  m_probeSetToIsHaplotypeMarker.find(probeSet);
<a name="l00867"></a>00867 
<a name="l00868"></a>00868   <span class="keywordflow">if</span> ((it != m_probeSetToIsHaplotypeMarker.end()) &amp;&amp; (it-&gt;second  == <span class="keyword">true</span>)) {
<a name="l00869"></a>00869     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00870"></a>00870   }
<a name="l00871"></a>00871 
<a name="l00872"></a>00872   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00873"></a>00873 
<a name="l00874"></a>00874 }
<a name="l00875"></a>00875 <span class="comment">// end TranslationTableModel::isHaplotypeMarker</span>
<a name="l00876"></a>00876 <span class="comment">/*****************************************************************************/</span>
<a name="l00877"></a>00877 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00878"></a>00878 <span class="comment">/**</span>
<a name="l00879"></a>00879 <span class="comment"> * TranslationTableModel::isRowHaplotype</span>
<a name="l00880"></a>00880 <span class="comment"> * Synopsis:</span>
<a name="l00881"></a>00881 <span class="comment"> * </span>
<a name="l00882"></a>00882 <span class="comment"> * Used only to validate that the input file for the Translation Table</span>
<a name="l00883"></a>00883 <span class="comment"> * has a header which names the gene Allele possible translations</span>
<a name="l00884"></a>00884 <span class="comment"> * before reading any records for a gene.</span>
<a name="l00885"></a>00885 <span class="comment"> *</span>
<a name="l00886"></a>00886 <span class="comment"> *</span>
<a name="l00887"></a>00887 <span class="comment"> * @param ttm - TranslationTableModel.</span>
<a name="l00888"></a>00888 <span class="comment"> * @param row - the row in question, 0 based.</span>
<a name="l00889"></a>00889 <span class="comment"> *</span>
<a name="l00890"></a>00890 <span class="comment"> * @return true - if the row is indeed a header row.</span>
<a name="l00891"></a>00891 <span class="comment"> */</span>
<a name="l00892"></a>00892 <span class="comment">/*****************************************************************************/</span>
<a name="l00893"></a><a class="code" href="classTranslationTableModel.html#af313345b99cd8a53fa1efd617d671be2">00893</a> <span class="keywordtype">bool</span> <a class="code" href="classTranslationTableModel.html#af313345b99cd8a53fa1efd617d671be2" title="TranslationTableModel::isRowHaplotype Synopsis:">TranslationTableModel::isRowHaplotype</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> row)
<a name="l00894"></a>00894 {
<a name="l00895"></a>00895 
<a name="l00896"></a>00896   <a class="code" href="Err_8h.html#ad024208f4ba6a4e75df4499ea1639a05" title="Calls Err::apt_err_assert with the filename and linenumber set. /// We want to avoid evaluating the m...">APT_ERR_ASSERT</a>((row &gt;= 0) &amp;&amp; (row &lt; m_rows.size()), <span class="stringliteral">&quot;&quot;</span>);
<a name="l00897"></a>00897 
<a name="l00898"></a>00898   pcrecpp::RE re(<span class="stringliteral">&quot;[Y]&quot;</span>);
<a name="l00899"></a>00899 
<a name="l00900"></a>00900   <span class="keywordflow">return</span> re.FullMatch(m_rows[row][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_HAPLOTYPE)]);
<a name="l00901"></a>00901 
<a name="l00902"></a>00902 }
<a name="l00903"></a>00903 <span class="comment">// end TranslationTableModel::isRowHaplotype</span>
<a name="l00904"></a>00904 <span class="comment">/*****************************************************************************/</span>
<a name="l00905"></a>00905 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l00906"></a>00906 <span class="comment">/**</span>
<a name="l00907"></a>00907 <span class="comment"> * TranslationTableModel::setReportAlleles</span>
<a name="l00908"></a>00908 <span class="comment"> * Synopsis: </span>
<a name="l00909"></a>00909 <span class="comment"> *</span>
<a name="l00910"></a>00910 <span class="comment"> * Hash a probeset:TranslationTableAllele - ReportAllele.</span>
<a name="l00911"></a>00911 <span class="comment"> * Note that this method cannot be put in the constructer because</span>
<a name="l00912"></a>00912 <span class="comment"> * the requisite GenoCallCoder must be instiated with headers from the</span>
<a name="l00913"></a>00913 <span class="comment"> * first CHP file. Parsing the first CHP file comes far later down stream</span>
<a name="l00914"></a>00914 <span class="comment"> * then when the constructor is called. </span>
<a name="l00915"></a>00915 <span class="comment"> *</span>
<a name="l00916"></a>00916 <span class="comment"> *</span>
<a name="l00917"></a>00917 <span class="comment"> * @param gcc - The genoCallCoder initialized with the first CHP</span>
<a name="l00918"></a>00918 <span class="comment"> *              headers. </span>
<a name="l00919"></a>00919 <span class="comment"> */</span>
<a name="l00920"></a>00920 <span class="comment">/*****************************************************************************/</span>
<a name="l00921"></a><a class="code" href="classTranslationTableModel.html#a101b8a8c3530648d99137c542b500a46">00921</a> <span class="keywordtype">void</span> <a class="code" href="classTranslationTableModel.html#a101b8a8c3530648d99137c542b500a46" title="TranslationTableModel::setReportAlleles Synopsis:">TranslationTableModel::setReportAlleles</a>( <a class="code" href="classGenoCallCoder.html" title="GenoCallCoder - Class for encoding and decoding numeric genotype call codes to and from allele string...">GenoCallCoder</a> &amp; gcc ) {
<a name="l00922"></a>00922 
<a name="l00923"></a>00923   <span class="keywordtype">int</span> markerCount = 0;
<a name="l00924"></a>00924   <span class="keywordtype">int</span> reportCount = 0;
<a name="l00925"></a>00925   <span class="keywordtype">int</span> switchStrandCount = 0;
<a name="l00926"></a>00926   <span class="keywordtype">int</span> differenceCount = 0;
<a name="l00927"></a>00927 
<a name="l00928"></a>00928   std::stringstream reportSStr;
<a name="l00929"></a>00929   
<a name="l00930"></a>00930   <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> row = 0; row &lt; size() ; row++ ) {
<a name="l00931"></a>00931 
<a name="l00932"></a>00932     <span class="keywordflow">if</span> (<a class="code" href="classTranslationTableModel.html#a590375d07f5f5bf813275858d0466114" title="TranslationTableModel::ignoreRow Synopsis: A setter and getter for ignoring rows in the translation t...">ignoreRow</a>(row)) {
<a name="l00933"></a>00933       <span class="keywordflow">continue</span>;
<a name="l00934"></a>00934     }
<a name="l00935"></a>00935 
<a name="l00936"></a>00936     <span class="comment">// Ignore header rows.</span>
<a name="l00937"></a>00937     std::string switchStrand = m_rows[row][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_SWITCH_STRAND)];
<a name="l00938"></a>00938     <span class="keywordflow">if</span> ( !((switchStrand == <span class="stringliteral">&quot;N&quot;</span>) || (switchStrand == <span class="stringliteral">&quot;Y&quot;</span>)) ) {
<a name="l00939"></a>00939       <span class="keywordflow">continue</span>;
<a name="l00940"></a>00940     }
<a name="l00941"></a>00941 
<a name="l00942"></a>00942 
<a name="l00943"></a>00943     markerCount++;
<a name="l00944"></a>00944     
<a name="l00945"></a>00945     std::string probeSet    = m_rows[row][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_PROBE_SET_ID)];
<a name="l00946"></a>00946     std::string reference   = m_rows[row][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_REFERENCE)];
<a name="l00947"></a>00947     std::string variant     = m_rows[row][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_VARIANT)];
<a name="l00948"></a>00948     <span class="keywordtype">bool</span> useComplement = switchStrand == <span class="stringliteral">&quot;Y&quot;</span>;
<a name="l00949"></a>00949 
<a name="l00950"></a>00950     std::string ttReference = reference;
<a name="l00951"></a>00951     std::string ttVariant = variant;
<a name="l00952"></a>00952 
<a name="l00953"></a>00953     <span class="keywordflow">if</span> ( useComplement ) {
<a name="l00954"></a>00954       switchStrandCount++;
<a name="l00955"></a>00955       reference = <a class="code" href="classCallElement.html#a11386b2d1d7a7a2497f51a3112567f9a" title="CallElement::reverseComplement.">CallElement::reverseComplement</a>(reference);
<a name="l00956"></a>00956       variant  = <a class="code" href="classCallElement.html#a11386b2d1d7a7a2497f51a3112567f9a" title="CallElement::reverseComplement.">CallElement::reverseComplement</a>(variant);
<a name="l00957"></a>00957     }
<a name="l00958"></a>00958     
<a name="l00959"></a>00959     std::string key = probeSet + <span class="stringliteral">&quot;:&quot;</span> + ttReference;
<a name="l00960"></a>00960     std::string reportAllele;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962     
<a name="l00963"></a>00963     <span class="keywordflow">if</span> ( m_reportAlleles.count(key) == 0 ) {
<a name="l00964"></a>00964 
<a name="l00965"></a>00965       <span class="keywordflow">try</span> {
<a name="l00966"></a>00966         reportAllele = gcc.<a class="code" href="classGenoCallCoder.html#aabc6df8e3bb2e28c6a752373431d5f68" title="Translate design allele name to reporting allele name for given probeset id.">referenceAlleleToReportAllele</a>( probeSet, reference );
<a name="l00967"></a>00967         <span class="keywordflow">if</span> ( !reportAllele.empty() &amp;&amp; reportAllele != reference ) {
<a name="l00968"></a>00968           reportCount++;
<a name="l00969"></a>00969           m_reportAlleles[key] = reportAllele;
<a name="l00970"></a>00970         }
<a name="l00971"></a>00971         <span class="keywordflow">if</span> ( ttReference != reportAllele ) {
<a name="l00972"></a>00972           differenceCount++;
<a name="l00973"></a>00973         }
<a name="l00974"></a>00974         reportSStr &lt;&lt; markerCount &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; reportCount &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; differenceCount &lt;&lt; <span class="stringliteral">&quot;{&quot;</span> &lt;&lt; switchStrand &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; switchStrandCount &lt;&lt; <span class="stringliteral">&quot;} Ref &quot;</span> &lt;&lt; key &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; ttReference &lt;&lt; <span class="stringliteral">&quot;) =&gt; &quot;</span> &lt;&lt; reportAllele &lt;&lt; endl;
<a name="l00975"></a>00975       }
<a name="l00976"></a>00976       <span class="keywordflow">catch</span> (...) {
<a name="l00977"></a>00977       }
<a name="l00978"></a>00978     }
<a name="l00979"></a>00979     key = probeSet + <span class="stringliteral">&quot;:&quot;</span> + ttVariant;
<a name="l00980"></a>00980     <span class="keywordflow">if</span> ( m_reportAlleles.count(key) == 0 ) {
<a name="l00981"></a>00981       <span class="keywordflow">try</span> {
<a name="l00982"></a>00982         reportAllele = gcc.<a class="code" href="classGenoCallCoder.html#aabc6df8e3bb2e28c6a752373431d5f68" title="Translate design allele name to reporting allele name for given probeset id.">referenceAlleleToReportAllele</a>( probeSet, variant );
<a name="l00983"></a>00983         <span class="keywordflow">if</span> ( !reportAllele.empty() &amp;&amp; reportAllele != variant ) {
<a name="l00984"></a>00984           reportCount++;
<a name="l00985"></a>00985           m_reportAlleles[key] = reportAllele;
<a name="l00986"></a>00986         }
<a name="l00987"></a>00987         <span class="keywordflow">if</span> ( ttVariant != reportAllele ) {
<a name="l00988"></a>00988           differenceCount++;
<a name="l00989"></a>00989         }
<a name="l00990"></a>00990         reportSStr &lt;&lt; markerCount &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; reportCount &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; differenceCount &lt;&lt; <span class="stringliteral">&quot;{&quot;</span> &lt;&lt; switchStrand &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; switchStrandCount &lt;&lt; <span class="stringliteral">&quot;} Var &quot;</span> &lt;&lt; key &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; ttVariant &lt;&lt; <span class="stringliteral">&quot;) =&gt; &quot;</span> &lt;&lt; reportAllele &lt;&lt; endl;
<a name="l00991"></a>00991           
<a name="l00992"></a>00992       }
<a name="l00993"></a>00993       <span class="keywordflow">catch</span> (...) {
<a name="l00994"></a>00994       }
<a name="l00995"></a>00995     }
<a name="l00996"></a>00996   }
<a name="l00997"></a>00997 
<a name="l00998"></a>00998   reportSStr &lt;&lt; <span class="stringliteral">&quot;Total Markers: &quot;</span> &lt;&lt; markerCount &lt;&lt; endl;
<a name="l00999"></a>00999   reportSStr &lt;&lt; <span class="stringliteral">&quot;Total Report Makers different from translation table: &quot;</span> &lt;&lt; differenceCount &lt;&lt; endl;
<a name="l01000"></a>01000   reportSStr &lt;&lt; <span class="stringliteral">&quot;Total Switch Strand = &#39;Y&#39; count: &quot;</span> &lt;&lt; switchStrandCount &lt;&lt; endl;
<a name="l01001"></a>01001   <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(ADT_VERBOSE_INPUT_FILES, reportSStr.str());
<a name="l01002"></a>01002   
<a name="l01003"></a>01003   
<a name="l01004"></a>01004 }
<a name="l01005"></a>01005 <span class="comment">// end TranslationTableModel::setReportAlleles</span>
<a name="l01006"></a>01006 <span class="comment">/*****************************************************************************/</span>
<a name="l01007"></a>01007 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l01008"></a>01008 <span class="comment">/**</span>
<a name="l01009"></a>01009 <span class="comment"> * TranslationTableModel::validateRowIsHeader</span>
<a name="l01010"></a>01010 <span class="comment"> * Synopsis:</span>
<a name="l01011"></a>01011 <span class="comment"> * </span>
<a name="l01012"></a>01012 <span class="comment"> * Used to validate that the input file for the Translation Table has a header</span>
<a name="l01013"></a>01013 <span class="comment"> * which names the gene Allele possible translations before reading any</span>
<a name="l01014"></a>01014 <span class="comment"> * records for a gene.</span>
<a name="l01015"></a>01015 <span class="comment"> *</span>
<a name="l01016"></a>01016 <span class="comment"> * An member attribute caches the result after the first assessment so</span>
<a name="l01017"></a>01017 <span class="comment"> * use with impunity. </span>
<a name="l01018"></a>01018 <span class="comment"> *</span>
<a name="l01019"></a>01019 <span class="comment"> *</span>
<a name="l01020"></a>01020 <span class="comment"> * SAMPLE:</span>
<a name="l01021"></a>01021 <span class="comment"> * ABCB1 Reference Link ProbeSet refSNP ID Defining cDNA Nucleotide Position Genomic Nucleotide Position Change External ID Validated Haplotype Reference Variant WT *14 A893S A893T  N44S I829V S400N A599T V801M</span>
<a name="l01022"></a>01022 <span class="comment"> *</span>
<a name="l01023"></a>01023 <span class="comment"> *</span>
<a name="l01024"></a>01024 <span class="comment"> * @param row - the row in question, 0 based.</span>
<a name="l01025"></a>01025 <span class="comment"> * @param giveWarning - boolean indicator for messaging</span>
<a name="l01026"></a>01026 <span class="comment"> *</span>
<a name="l01027"></a>01027 <span class="comment"> * @return true - if the row is indeed a header row.</span>
<a name="l01028"></a>01028 <span class="comment"> */</span>
<a name="l01029"></a>01029 <span class="comment">/*****************************************************************************/</span>
<a name="l01030"></a><a class="code" href="classTranslationTableModel.html#acf1658f2cce028d22fa3f8666682acde">01030</a> <span class="keywordtype">bool</span> <a class="code" href="classTranslationTableModel.html#acf1658f2cce028d22fa3f8666682acde" title="TranslationTableModel::validateRowIsHeader Synopsis:">TranslationTableModel::validateRowIsHeader</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> row, <span class="keywordtype">bool</span> giveWarning)
<a name="l01031"></a>01031 {
<a name="l01032"></a>01032 
<a name="l01033"></a>01033   <a class="code" href="Err_8h.html#ad024208f4ba6a4e75df4499ea1639a05" title="Calls Err::apt_err_assert with the filename and linenumber set. /// We want to avoid evaluating the m...">APT_ERR_ASSERT</a>((row &gt;= 0) &amp;&amp; (row &lt; m_rows.size()), <span class="stringliteral">&quot;&quot;</span>);
<a name="l01034"></a>01034 
<a name="l01035"></a>01035   <span class="keywordtype">bool</span> okToContinue = <span class="keyword">true</span>;
<a name="l01036"></a>01036 
<a name="l01037"></a>01037   <span class="keywordflow">if</span> (m_validatedHeaderRows.count(row)) {
<a name="l01038"></a>01038     <span class="keywordflow">return</span> okToContinue;
<a name="l01039"></a>01039   }
<a name="l01040"></a>01040 
<a name="l01041"></a>01041   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; (j &lt; <a class="code" href="classTranslationInputTsvTableModel.html#ae33ba37f59967a7bd0caefe58de785ed" title="TranslationInputTsvTableModel::columnCount Synopsis:">columnCount</a>()) &amp;&amp; okToContinue; j++) {
<a name="l01042"></a>01042 
<a name="l01043"></a>01043     pcrecpp::RE regex = <a class="code" href="classTranslationTableModel.html#a2fa9361d15dbd4dd70ba289b9b998e23" title="getColumnRegex: Synopsis:">getColumnRegex</a>(<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_ALLELE_START));
<a name="l01044"></a>01044 
<a name="l01045"></a>01045     <span class="keywordflow">if</span> (j &lt; <a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_ALLELE_START)) {
<a name="l01046"></a>01046       regex = <a class="code" href="classTranslationTableModel.html#a2fa9361d15dbd4dd70ba289b9b998e23" title="getColumnRegex: Synopsis:">getColumnRegex</a>(j);
<a name="l01047"></a>01047     }
<a name="l01048"></a>01048 
<a name="l01049"></a>01049     <span class="keywordflow">if</span> (!(regex.FullMatch(m_rows[row][j]))) {
<a name="l01050"></a>01050       <span class="keywordflow">if</span> (giveWarning) {
<a name="l01051"></a>01051         std::stringstream msg;
<a name="l01052"></a>01052 
<a name="l01053"></a>01053         msg &lt;&lt; <span class="stringliteral">&quot;Invalid row(&quot;</span> &lt;&lt; m_fileRowIndex[row] &lt;&lt; <span class="stringliteral">&quot;), column(&quot;</span>;
<a name="l01054"></a>01054         msg &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot; ) entry of \&quot;&quot;</span> &lt;&lt; m_rows[row][j] &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;
<a name="l01055"></a>01055         msg &lt;&lt; <span class="stringliteral">&quot;[ ROW &quot;</span> &lt;&lt; m_fileRowIndex[row] &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>;
<a name="l01056"></a>01056         msg &lt;&lt; <a class="code" href="classTranslationInputTsvTableModel.html#ac209f9165791ba0d30aa905965eba1f6" title="TranslationInputTsvTableModel::getRowAsString Synopsis:">getRowAsString</a>(row) &lt;&lt; endl;
<a name="l01057"></a>01057         <a class="code" href="classVerbose.html#a34e1d936178741eeb78de93c5497e1b8" title="Print a warning message.">Verbose::warn</a>(ADT_VERBOSE_EXCEPTION,  msg.str());
<a name="l01058"></a>01058       }
<a name="l01059"></a>01059       okToContinue = <span class="keyword">false</span>;
<a name="l01060"></a>01060     }
<a name="l01061"></a>01061   }
<a name="l01062"></a>01062 
<a name="l01063"></a>01063   <span class="keywordflow">if</span> (okToContinue) {
<a name="l01064"></a>01064     m_validatedHeaderRows.insert(row);
<a name="l01065"></a>01065   }
<a name="l01066"></a>01066 
<a name="l01067"></a>01067   <span class="keywordflow">return</span> okToContinue;
<a name="l01068"></a>01068 
<a name="l01069"></a>01069 }
<a name="l01070"></a>01070 <span class="comment">// end TranslationTableModel::validateRowIsHeader</span>
<a name="l01071"></a>01071 <span class="comment">/*****************************************************************************/</span>
<a name="l01072"></a>01072 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l01073"></a>01073 <span class="comment">/**</span>
<a name="l01074"></a>01074 <span class="comment"> * TranslationTableModel::_reconcileDeletedHaplotypeRows</span>
<a name="l01075"></a>01075 <span class="comment"> * Synopsis:</span>
<a name="l01076"></a>01076 <span class="comment"> *</span>
<a name="l01077"></a>01077 <span class="comment"> * When haplotype rows are deleted, like with the probe set filter,</span>
<a name="l01078"></a>01078 <span class="comment"> * this routine fixes up the haplotype allele names, condensing duplicate</span>
<a name="l01079"></a>01079 <span class="comment"> * calls to one call. Two calls are equivalent after a marker has been</span>
<a name="l01080"></a>01080 <span class="comment"> * deleted if two  new groups are equivalent. In that case, one allele</span>
<a name="l01081"></a>01081 <span class="comment"> * call column is designated as the combined column and any matching</span>
<a name="l01082"></a>01082 <span class="comment"> * columns are commented out (i.e. the allele name). The allele name</span>
<a name="l01083"></a>01083 <span class="comment"> * for commented out columns is then appended to the designated call</span>
<a name="l01084"></a>01084 <span class="comment"> * column.</span>
<a name="l01085"></a>01085 <span class="comment"> *</span>
<a name="l01086"></a>01086 <span class="comment"> * @param rte - the single instance run time environment. a</span>
<a name="l01087"></a>01087 <span class="comment"> * @param deletedRows - those haplotype group markers that were deleted.</span>
<a name="l01088"></a>01088 <span class="comment"> *</span>
<a name="l01089"></a>01089 <span class="comment"> * @return - true if program execution is ok to continue.</span>
<a name="l01090"></a>01090 <span class="comment"> */</span>
<a name="l01091"></a>01091 <span class="comment">/*****************************************************************************/</span>
<a name="l01092"></a>01092 <span class="keywordtype">bool</span> TranslationTableModel::_reconcileDeletedHaplotypeRows(<span class="keyword">const</span> <a class="code" href="classRunTimeEnvironment.html">RunTimeEnvironment</a> &amp; rte, std::list&lt; int &gt; deletedRows)
<a name="l01093"></a>01093 {
<a name="l01094"></a>01094 
<a name="l01095"></a>01095   <span class="keywordtype">bool</span> okToContinue = <span class="keyword">true</span>;
<a name="l01096"></a>01096 
<a name="l01097"></a>01097   <span class="comment">// Multiple rows may participate in the same gene.</span>
<a name="l01098"></a>01098   <span class="comment">// Therefore first we isolate the distinct headers.</span>
<a name="l01099"></a>01099   set&lt; int &gt; reconcileHeaderRows;
<a name="l01100"></a>01100 
<a name="l01101"></a>01101 
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   pcrecpp::RE reSkip(<span class="stringliteral">&quot;^\\s*#&quot;</span>);
<a name="l01104"></a>01104   std::list&lt; int &gt;::iterator itLI;
<a name="l01105"></a>01105 
<a name="l01106"></a>01106   <span class="keywordflow">for</span> (itLI = deletedRows.begin(); itLI !=  deletedRows.end(); itLI++) {
<a name="l01107"></a>01107     <span class="keywordtype">int</span> headerRow = <a class="code" href="classTranslationTableModel.html#abd5a952b613ca007ed4fc4ac4e12f524" title="TranslationTableModel::getHeaderRowgetHeaderRow: Synopsis:">getHeaderRow</a>(*itLI);
<a name="l01108"></a>01108     <span class="keywordflow">if</span> (reconcileHeaderRows.count(headerRow) == 0) {
<a name="l01109"></a>01109       reconcileHeaderRows.insert(headerRow);
<a name="l01110"></a>01110     }
<a name="l01111"></a>01111   }
<a name="l01112"></a>01112 
<a name="l01113"></a>01113   <span class="comment">// Now we have a list of just the genes we care about. Create CallSet objects</span>
<a name="l01114"></a>01114   <span class="comment">// for each group. We capitalize on the operator== in the CallSet to</span>
<a name="l01115"></a>01115   <span class="comment">// compare groups.</span>
<a name="l01116"></a>01116 
<a name="l01117"></a>01117   set&lt; int &gt;::iterator itSI;
<a name="l01118"></a>01118   <span class="keywordflow">for</span> (itSI = reconcileHeaderRows.begin();
<a name="l01119"></a>01119        itSI !=  reconcileHeaderRows.end(); itSI++) {
<a name="l01120"></a>01120 
<a name="l01121"></a>01121     <span class="keywordtype">int</span> headerRow = *itSI;
<a name="l01122"></a>01122 
<a name="l01123"></a>01123     std::vector&lt; int &gt; alleleCols = <a class="code" href="classTranslationTableModel.html#af072cea2e362c21c8433939b9f6bde66" title="TranslationTableModel::getHaplotypeAlleleColumns Synopsis:">getHaplotypeAlleleColumns</a>(headerRow, <a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_ALLELE_START));
<a name="l01124"></a>01124     std::map&lt; int,  CallSet &gt; haplotypeGroup;
<a name="l01125"></a>01125 
<a name="l01126"></a>01126 
<a name="l01127"></a>01127     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> row = headerRow + 1;
<a name="l01128"></a>01128          (row &lt; m_rows.size()) &amp;&amp; (<a class="code" href="classTranslationTableModel.html#abd5a952b613ca007ed4fc4ac4e12f524" title="TranslationTableModel::getHeaderRowgetHeaderRow: Synopsis:">getHeaderRow</a>(row) == headerRow)
<a name="l01129"></a>01129          ; row++) {
<a name="l01130"></a>01130 
<a name="l01131"></a>01131       <span class="keywordflow">if</span> (<a class="code" href="classTranslationTableModel.html#a590375d07f5f5bf813275858d0466114" title="TranslationTableModel::ignoreRow Synopsis: A setter and getter for ignoring rows in the translation t...">ignoreRow</a>(row)) {
<a name="l01132"></a>01132         <span class="keywordflow">continue</span>;
<a name="l01133"></a>01133       }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; alleleCols.size(); j++) {
<a name="l01136"></a>01136 
<a name="l01137"></a>01137         <span class="keywordtype">int</span> col = alleleCols[j];
<a name="l01138"></a>01138 
<a name="l01139"></a>01139         <span class="comment">// Wierd side effect of std::maps. Accessing an element that doesn&#39;t</span>
<a name="l01140"></a>01140         <span class="comment">// exist creates it. In this case we want to create the</span>
<a name="l01141"></a>01141         <span class="comment">// empty CallSet. This is a side effect of the translation</span>
<a name="l01142"></a>01142         <span class="comment">// table as well where the &quot;reference&quot; allele has all empty</span>
<a name="l01143"></a>01143         <span class="comment">// columns. We need to create the empty CallSet in that case.</span>
<a name="l01144"></a>01144         <span class="comment">// Also, the common case will be that a group with a filtered</span>
<a name="l01145"></a>01145         <span class="comment">// probe set will have an empty CallSet for the allele that</span>
<a name="l01146"></a>01146         <span class="comment">// corresponded to that probe set.</span>
<a name="l01147"></a>01147 
<a name="l01148"></a>01148         <span class="keywordflow">if</span> (haplotypeGroup.count(col) == 0) {
<a name="l01149"></a>01149           haplotypeGroup[col].m_name = m_rows[headerRow][col];
<a name="l01150"></a>01150           haplotypeGroup[col].m_isDescriptive = <span class="keyword">true</span>;
<a name="l01151"></a>01151         }
<a name="l01152"></a>01152         <span class="keywordflow">if</span> (! m_rows[row][col].empty()) {
<a name="l01153"></a>01153           haplotypeGroup[col].addCallElement(*<span class="keyword">this</span>, row, col, <span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l01154"></a>01154         }
<a name="l01155"></a>01155 
<a name="l01156"></a>01156       } <span class="comment">// for each gene column</span>
<a name="l01157"></a>01157 
<a name="l01158"></a>01158     } <span class="comment">// for each gene row</span>
<a name="l01159"></a>01159 
<a name="l01160"></a>01160     std::map&lt; int, CallSet &gt;::iterator itMIC;
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     <span class="keywordflow">for</span> (itMIC = haplotypeGroup.begin(); itMIC != haplotypeGroup.end(); itMIC++) {
<a name="l01163"></a>01163 
<a name="l01164"></a>01164 
<a name="l01165"></a>01165       std::map&lt; int, CallSet &gt;::iterator jtMIC;
<a name="l01166"></a>01166 
<a name="l01167"></a>01167       <span class="keywordflow">for</span> (jtMIC = itMIC, jtMIC++; jtMIC != haplotypeGroup.end(); jtMIC++) {
<a name="l01168"></a>01168 
<a name="l01169"></a>01169         <span class="comment">// Skip this column if it has already been commented out,</span>
<a name="l01170"></a>01170         <span class="comment">// i.e. combined with another group.</span>
<a name="l01171"></a>01171         <span class="keywordflow">if</span> (reSkip.PartialMatch(m_rows[headerRow][jtMIC-&gt;first]) ||
<a name="l01172"></a>01172             (!jtMIC-&gt;second.isEmpty() &amp;&amp; ( jtMIC-&gt;second.getCallType() != ADT_CALL_TYPE_HAPLOTYPE_GROUP ) )) {
<a name="l01173"></a>01173           <span class="keywordflow">continue</span>;
<a name="l01174"></a>01174         }
<a name="l01175"></a>01175 
<a name="l01176"></a>01176         <span class="comment">// Compare the CallSet groups.</span>
<a name="l01177"></a>01177 
<a name="l01178"></a>01178         <span class="keywordflow">if</span> (itMIC-&gt;second == jtMIC-&gt;second) {
<a name="l01179"></a>01179 
<a name="l01180"></a>01180           <span class="comment">// Rolling up the names was added back in as an option</span>
<a name="l01181"></a>01181           <span class="comment">// on 10/15/2008.</span>
<a name="l01182"></a>01182 
<a name="l01183"></a>01183           <span class="keywordflow">if</span> (rte.m_adtOpts.m_useFirstDupAlleleDef) {
<a name="l01184"></a>01184 
<a name="l01185"></a>01185             <span class="comment">//Comment out the combined allele name so it will be skipped</span>
<a name="l01186"></a>01186             <span class="comment">// for any processing down stream.</span>
<a name="l01187"></a>01187             m_rows[headerRow][jtMIC-&gt;first] = <span class="stringliteral">&quot;#&quot;</span> + m_rows[headerRow][jtMIC-&gt;first];
<a name="l01188"></a>01188           } <span class="keywordflow">else</span> {
<a name="l01189"></a>01189             <span class="comment">// Rolling up the names was canceled</span>
<a name="l01190"></a>01190             <span class="comment">// by Elaine and Carsten on 10/01/2008</span>
<a name="l01191"></a>01191             <span class="comment">// Code left in place in case they change their mind.</span>
<a name="l01192"></a>01192             std::stringstream alleleCombinedNameSStr;
<a name="l01193"></a>01193             alleleCombinedNameSStr &lt;&lt; m_rows[headerRow][itMIC-&gt;first] &lt;&lt; <span class="stringliteral">&quot;_or_&quot;</span>;
<a name="l01194"></a>01194             alleleCombinedNameSStr &lt;&lt; m_rows[headerRow][jtMIC-&gt;first];
<a name="l01195"></a>01195             m_rows[headerRow][itMIC-&gt;first] = alleleCombinedNameSStr.str();
<a name="l01196"></a>01196             <a class="code" href="classVerbose.html#ac4034f68f4c8d2b49cd6340984b940ce" title="Print a message to the stream.">Verbose::out</a>(ADT_VERBOSE_INPUT_FILES, <span class="stringliteral">&quot;Combined allele &quot;</span> +  m_rows[headerRow][jtMIC-&gt;first] + <span class="stringliteral">&quot; with &quot;</span> +  m_rows[headerRow][itMIC-&gt;first]);
<a name="l01197"></a>01197           }
<a name="l01198"></a>01198 
<a name="l01199"></a>01199         }
<a name="l01200"></a>01200       }
<a name="l01201"></a>01201     }
<a name="l01202"></a>01202 
<a name="l01203"></a>01203   } <span class="comment">// foreach gene row header that needs reconciled</span>
<a name="l01204"></a>01204 
<a name="l01205"></a>01205 
<a name="l01206"></a>01206 
<a name="l01207"></a>01207   <span class="keywordflow">return</span> okToContinue;
<a name="l01208"></a>01208 
<a name="l01209"></a>01209 }
<a name="l01210"></a>01210 
<a name="l01211"></a>01211 <span class="comment">// end TranslationTableModel::_reconcileDeletedHaplotypeRows</span>
<a name="l01212"></a>01212 <span class="comment">/*****************************************************************************/</span>
<a name="l01213"></a>01213 <span class="comment">/*****************************************************************************/</span><span class="comment"></span>
<a name="l01214"></a>01214 <span class="comment">/**</span>
<a name="l01215"></a>01215 <span class="comment"> * TranslationTableModel::generateGeneMarkerList</span>
<a name="l01216"></a>01216 <span class="comment"> * Synopsis:</span>
<a name="l01217"></a>01217 <span class="comment"> *</span>
<a name="l01218"></a>01218 <span class="comment"> * Copy Number Zero operations require the set of all markers or probe</span>
<a name="l01219"></a>01219 <span class="comment"> * sets for a gene during validation and reporting. This API builds</span>
<a name="l01220"></a>01220 <span class="comment"> * this list. Broken out as a separate API and not part of the</span>
<a name="l01221"></a>01221 <span class="comment"> * constructor because the MarkerList filter needs to be applied</span>
<a name="l01222"></a>01222 <span class="comment"> * before this API is called. The MarkerList filter happens outside</span>
<a name="l01223"></a>01223 <span class="comment"> * the constructor and therefore so does this operation. </span>
<a name="l01224"></a>01224 <span class="comment"> *</span>
<a name="l01225"></a>01225 <span class="comment"> *</span>
<a name="l01226"></a>01226 <span class="comment"> */</span>
<a name="l01227"></a>01227 <span class="comment">/*****************************************************************************/</span>
<a name="l01228"></a><a class="code" href="classTranslationTableModel.html#a5fb16210f4de482f8cd815228cf99017">01228</a> <span class="keywordtype">void</span> <a class="code" href="classTranslationTableModel.html#a5fb16210f4de482f8cd815228cf99017" title="TranslationTableModel::generateGeneMarkerList Synopsis:">TranslationTableModel::generateGeneMarkerList</a>()  {
<a name="l01229"></a>01229 
<a name="l01230"></a>01230   std::map&lt; std::string, std::vector&lt; int &gt;  &gt;::const_iterator itSVI;
<a name="l01231"></a>01231 
<a name="l01232"></a>01232   <span class="comment">// The m_probeSetRowIndex is filtered with only the filtered ids. </span>
<a name="l01233"></a>01233   <span class="keywordflow">for</span> (itSVI = m_probeSetRowIndex.begin(); itSVI != m_probeSetRowIndex.end(); itSVI++) {
<a name="l01234"></a>01234 
<a name="l01235"></a>01235     m_geneMarkers[m_rows[itSVI-&gt;second[0]][<a class="code" href="classTranslationTableModel.html#a8e519cfda65a7d4399dc0de52f7a4041" title="TranslationTableModel::getColumnIndex: Synopsis: DMET2 &amp;amp; DMET3 columns can be retrieved via this ...">getColumnIndex</a>(ADT_DMET3_TT_GENE)]].push_back( itSVI-&gt;first ) ;
<a name="l01236"></a>01236 
<a name="l01237"></a>01237   }
<a name="l01238"></a>01238 
<a name="l01239"></a>01239   <span class="keywordflow">return</span>;
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 }
<a name="l01242"></a>01242 <span class="comment">// end TranslationTableModel::generateGeneMarkerList</span>
<a name="l01243"></a>01243 <span class="comment">/*****************************************************************************/</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2016 12:59:04 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
