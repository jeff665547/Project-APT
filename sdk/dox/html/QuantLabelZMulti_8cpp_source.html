<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Affymetrix Power Tools: chipstream/QuantLabelZMulti.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="dir_fa2ccd765111060c049013d9614ef4eb.html">chipstream</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>QuantLabelZMulti.cpp</h1>  </div>
</div>
<div class="contents">
<a href="QuantLabelZMulti_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00002"></a>00002 <span class="comment"></span><span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// Copyright (C) 2005 Affymetrix, Inc.</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// This program is free software; you can redistribute it and/or modify </span>
<a name="l00006"></a>00006 <span class="comment">// it under the terms of the GNU General Public License (version 2) as </span>
<a name="l00007"></a>00007 <span class="comment">// published by the Free Software Foundation.</span>
<a name="l00008"></a>00008 <span class="comment">// </span>
<a name="l00009"></a>00009 <span class="comment">// This program is distributed in the hope that it will be useful, </span>
<a name="l00010"></a>00010 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of </span>
<a name="l00011"></a>00011 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU </span>
<a name="l00012"></a>00012 <span class="comment">// General Public License for more details.</span>
<a name="l00013"></a>00013 <span class="comment">// </span>
<a name="l00014"></a>00014 <span class="comment">// You should have received a copy of the GNU General Public License </span>
<a name="l00015"></a>00015 <span class="comment">// along with this program;if not, write to the </span>
<a name="l00016"></a>00016 <span class="comment">// </span>
<a name="l00017"></a>00017 <span class="comment">// Free Software Foundation, Inc., </span>
<a name="l00018"></a>00018 <span class="comment">// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<a name="l00019"></a>00019 <span class="comment">//</span><span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">////////////////////////////////////////////////////////////////</span>
<a name="l00021"></a>00021 <span class="comment"></span><span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">/**</span>
<a name="l00023"></a>00023 <span class="comment"> * @file   QuantLabelZMulti.cpp</span>
<a name="l00024"></a>00024 <span class="comment"> * @author Martin Gilchrist </span>
<a name="l00025"></a>00025 <span class="comment"> * @date   Tue Jun 24 1:50:00 2008</span>
<a name="l00026"></a>00026 <span class="comment"> *</span>
<a name="l00027"></a>00027 <span class="comment"> *</span>
<a name="l00028"></a>00028 <span class="comment"> */</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="comment">// The following typedefs are here for quick reference, avoids having to bring up .h file.</span>
<a name="l00031"></a>00031 <span class="comment">/*</span>
<a name="l00032"></a>00032 <span class="comment">typedef vector&lt;double&gt; SampleSummaries;</span>
<a name="l00033"></a>00033 <span class="comment">typedef map&lt;int, SampleSummaries&gt; ContextMap;</span>
<a name="l00034"></a>00034 <span class="comment">typedef map&lt;int, ContextMap&gt; AlleleMap;</span>
<a name="l00035"></a>00035 <span class="comment"></span>
<a name="l00036"></a>00036 <span class="comment">typedef pair&lt;int, int&gt; AlleleContext;</span>
<a name="l00037"></a>00037 <span class="comment">typedef pair&lt;AlleleContext, double&gt; ASummary;</span>
<a name="l00038"></a>00038 <span class="comment">typedef vector&lt;ASummary&gt; AlleleVector;</span>
<a name="l00039"></a>00039 <span class="comment">typedef vector&lt;ASummary&gt;  MaxContextVector;</span>
<a name="l00040"></a>00040 <span class="comment">typedef vector&lt;MaxContextVector&gt; SampleMaxs;</span>
<a name="l00041"></a>00041 <span class="comment">*/</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="QuantLabelZMulti_8h.html" title="Interface for methods computing SNP genotyping calls.">chipstream/QuantLabelZMulti.h</a>&quot;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &quot;chipstream/QuantLabelZIO.h&quot;</span>
<a name="l00044"></a>00044 <span class="comment">//</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="ProbeSet_8h.html" title="Container class for probe sets.">chipstream/ProbeSet.h</a>&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="QuantMethodFactory_8h.html" title="Factory class for making chip streams based on a string representation.">chipstream/QuantMethodFactory.h</a>&quot;</span>
<a name="l00047"></a>00047 <span class="comment">//</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="GenoCallCoder_8h.html" title="Genotype call en/decoder.">calvin_files/utils/src/GenoCallCoder.h</a>&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;<a class="code" href="AffxString_8h.html" title="This header contains the AffxString class definition.">util/AffxString.h</a>&quot;</span>
<a name="l00050"></a>00050 <span class="comment">//</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00052"></a>00052 <span class="comment">//</span>
<a name="l00053"></a>00053 <span class="comment"></span>
<a name="l00054"></a>00054 <span class="comment">/**</span>
<a name="l00055"></a>00055 <span class="comment">  @brief  Gets the integer valued (not affx::GType) forced call for the probeset. </span>
<a name="l00056"></a>00056 <span class="comment">*/</span>
<a name="l00057"></a><a class="code" href="classQuantLabelZMulti.html#a1fe65ef25ea84634417064769673e14e">00057</a> <span class="keywordtype">int</span> <a class="code" href="classQuantLabelZMulti.html#a1fe65ef25ea84634417064769673e14e" title="Gets the integer valued (not affx::GType) forced call for the probeset.">QuantLabelZMulti::getForcedCall</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index) {
<a name="l00058"></a>00058   <span class="keywordflow">if</span>(index &gt;= m_CallsMulti.size()) {
<a name="l00059"></a>00059     <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;Asking for call at index &quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(index) + <span class="stringliteral">&quot; when Probeset &quot;</span> +
<a name="l00060"></a>00060                 <a class="code" href="classQuantGTypeMethod.html#ab4ce64f2ef8bc3ec6d554fa0c1f13212" title="Name of current probeset.">m_ProbesetName</a> + <span class="stringliteral">&quot; has only &quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(m_CallsMulti.size()) + <span class="stringliteral">&quot; calls.&quot;</span>);
<a name="l00061"></a>00061   }
<a name="l00062"></a>00062   <span class="keywordflow">return</span> m_CallsMulti[index];
<a name="l00063"></a>00063 }
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">/**</span>
<a name="l00067"></a>00067 <span class="comment">  @brief  Gets the integer valued (not affx::GType) call for the probeset. </span>
<a name="l00068"></a>00068 <span class="comment">*/</span>
<a name="l00069"></a><a class="code" href="classQuantLabelZMulti.html#a4d961567ab1e43868246c7300ef5b7c1">00069</a> <span class="keywordtype">int</span> <a class="code" href="classQuantLabelZMulti.html#a4d961567ab1e43868246c7300ef5b7c1" title="Gets the integer valued (not affx::GType) call for the probeset.">QuantLabelZMulti::getCall</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index) {
<a name="l00070"></a>00070   <span class="keywordtype">int</span> call = <a class="code" href="classQuantLabelZMulti.html#a1fe65ef25ea84634417064769673e14e" title="Gets the integer valued (not affx::GType) forced call for the probeset.">getForcedCall</a>(index);
<a name="l00071"></a>00071   <span class="keywordtype">double</span> conf = <a class="code" href="classQuantLabelZ.html#a91aac61561a7fc442acb8292cbd2063d" title="Get our confidence value for a particular call in a particular sample.">getConfidence</a>(index);
<a name="l00072"></a>00072 
<a name="l00073"></a>00073   <span class="keywordflow">if</span>(m_CopyNumbers[index]==0)
<a name="l00074"></a>00074     <span class="keywordflow">return</span> (m_coder-&gt;<a class="code" href="classGenoCallCoder.html#ab9ff7b3ee450048176b2ce5669a1899d" title="Decode from call code number to allele name string for given probeset id.">abstractAlleleToGenotypeCallNum</a>(<span class="stringliteral">&quot;ZeroCopyNumber&quot;</span>));
<a name="l00075"></a>00075   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_PriorObs[index] &lt; m_PraThresh)
<a name="l00076"></a>00076       <span class="keywordflow">return</span>(m_coder-&gt;<a class="code" href="classGenoCallCoder.html#ab9ff7b3ee450048176b2ce5669a1899d" title="Decode from call code number to allele name string for given probeset id.">abstractAlleleToGenotypeCallNum</a>(<span class="stringliteral">&quot;PossibleRareAllele&quot;</span>));
<a name="l00077"></a>00077   <span class="keywordflow">else</span> <span class="keywordflow">if</span>((conf &gt;= <a class="code" href="classQuantLabelZ.html#af1fedebd9a757f82da747b717154121f" title="Get the min value for a call.">getMinThresh</a>()) &amp;&amp; (conf &lt;= <a class="code" href="classQuantLabelZ.html#a15e614024267b86c0ad74281a6d851e1" title="Get the max value for a call.">getMaxThresh</a>()))
<a name="l00078"></a>00078       <span class="keywordflow">return</span> call;
<a name="l00079"></a>00079   <span class="keywordflow">else</span>
<a name="l00080"></a>00080       <span class="keywordflow">return</span>(m_coder-&gt;<a class="code" href="classGenoCallCoder.html#ab9ff7b3ee450048176b2ce5669a1899d" title="Decode from call code number to allele name string for given probeset id.">abstractAlleleToGenotypeCallNum</a>(<span class="stringliteral">&quot;NoCall&quot;</span>));
<a name="l00081"></a>00081 }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="comment"></span>
<a name="l00084"></a>00084 <span class="comment">/** </span>
<a name="l00085"></a>00085 <span class="comment"> * Get the genotype forced call at specified index (sample).</span>
<a name="l00086"></a>00086 <span class="comment"> * @param index - sample of interest.</span>
<a name="l00087"></a>00087 <span class="comment"> * @return - Genotyping call made.</span>
<a name="l00088"></a>00088 <span class="comment"> */</span>
<a name="l00089"></a><a class="code" href="classQuantLabelZMulti.html#a722af5cb77b5dec8e7a7343099eb27b4">00089</a> affx::GType <a class="code" href="classQuantLabelZMulti.html#a722af5cb77b5dec8e7a7343099eb27b4" title="Get the genotype forced call at specified index (sample).">QuantLabelZMulti::getGTypeForcedCall</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index) {
<a name="l00090"></a>00090   <span class="keywordflow">if</span>(index &gt;= m_Calls.size()) {
<a name="l00091"></a>00091     <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;Asking for call at index &quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(index) + <span class="stringliteral">&quot; when Probeset &quot;</span> +
<a name="l00092"></a>00092                   <a class="code" href="classQuantGTypeMethod.html#ab4ce64f2ef8bc3ec6d554fa0c1f13212" title="Name of current probeset.">m_ProbesetName</a> + <span class="stringliteral">&quot; has only &quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(m_Calls.size()) + <span class="stringliteral">&quot; calls.&quot;</span>);
<a name="l00093"></a>00093   }
<a name="l00094"></a>00094   <span class="keywordflow">return</span> m_Calls[index];
<a name="l00095"></a>00095 }
<a name="l00096"></a>00096 <span class="comment"></span>
<a name="l00097"></a>00097 <span class="comment">/** </span>
<a name="l00098"></a>00098 <span class="comment"> * Get the genotype call at specified index (sample).</span>
<a name="l00099"></a>00099 <span class="comment"> * @param index - sample of interest.</span>
<a name="l00100"></a>00100 <span class="comment"> * @return - Genotyping call made.</span>
<a name="l00101"></a>00101 <span class="comment">**/</span>
<a name="l00102"></a><a class="code" href="classQuantLabelZMulti.html#a47a7aa62c0443b65d872c1b3bf370c3b">00102</a> affx::GType <a class="code" href="classQuantLabelZMulti.html#a47a7aa62c0443b65d872c1b3bf370c3b" title="Get the genotype call at specified index (sample).">QuantLabelZMulti::getGTypeCall</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index) {
<a name="l00103"></a>00103   affx::GType call = <a class="code" href="classQuantLabelZMulti.html#a722af5cb77b5dec8e7a7343099eb27b4" title="Get the genotype forced call at specified index (sample).">getGTypeForcedCall</a>(index);
<a name="l00104"></a>00104   <span class="keywordflow">if</span>(m_CopyNumbers[index]==0)<span class="comment"></span>
<a name="l00105"></a>00105 <span class="comment">    ///@todo  This only works since Summary statistics only need hom vs. het information.</span>
<a name="l00106"></a>00106 <span class="comment"></span>    <span class="keywordflow">return</span> affx::AA;
<a name="l00107"></a>00107   <span class="keywordtype">double</span> conf = <a class="code" href="classQuantLabelZ.html#a91aac61561a7fc442acb8292cbd2063d" title="Get our confidence value for a particular call in a particular sample.">getConfidence</a>(index);
<a name="l00108"></a>00108   <span class="keywordflow">if</span>((conf &gt;= <a class="code" href="classQuantLabelZ.html#af1fedebd9a757f82da747b717154121f" title="Get the min value for a call.">getMinThresh</a>()) &amp;&amp; (conf &lt;= <a class="code" href="classQuantLabelZ.html#a15e614024267b86c0ad74281a6d851e1" title="Get the max value for a call.">getMaxThresh</a>()))
<a name="l00109"></a>00109       <span class="keywordflow">return</span> call;
<a name="l00110"></a>00110   <span class="keywordflow">else</span>
<a name="l00111"></a>00111       <span class="keywordflow">return</span> affx::NN;
<a name="l00112"></a>00112 }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="comment"></span>
<a name="l00115"></a>00115 <span class="comment">/** Fill in our self documentation from current state. */</span>
<a name="l00116"></a><a class="code" href="classQuantLabelZMulti.html#a2c5fe9639d18fee9a4f98430b48529ba">00116</a> <span class="keywordtype">void</span> <a class="code" href="classQuantLabelZMulti.html#a2c5fe9639d18fee9a4f98430b48529ba" title="Fill in our self documentation from current state.">QuantLabelZMulti::setupSelfDoc</a>(<a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a> &amp;doc) {
<a name="l00117"></a>00117   doc.<a class="code" href="classSelfDoc.html#a51db8ea9abfa958f92fb5bc601ad68dc" title="Setter method for name appearing in doc.">setDocName</a>(QUANTBRLMMPMULTI);
<a name="l00118"></a>00118   doc.<a class="code" href="classSelfDoc.html#acd4638b447701d1a642effb6b8d2a396" title="Setter method for description appearing in doc.">setDocDescription</a>(<span class="stringliteral">&quot;Do genotyping calls with BRLMM-P-MULTI (perfect match) algorithm.&quot;</span>);
<a name="l00119"></a>00119   std::vector&lt;SelfDoc::Opt&gt; opts = <a class="code" href="classQuantLabelZ.html#a0da80e2dbed413e783338e1ae66c8b43" title="Default Getter method for parameters and their documentation.">QuantLabelZ::getDefaultDocOptions</a>();
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a> praThresh = {<span class="stringliteral">&quot;pra-thresh&quot;</span>,SelfDoc::Opt::Integer,<span class="stringliteral">&quot;0&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,<span class="stringliteral">&quot;NA&quot;</span>,
<a name="l00122"></a>00122                          <span class="stringliteral">&quot;Threshold on cluster mean strength below which a PRA is called.&quot;</span>};
<a name="l00123"></a>00123   opts.push_back(praThresh);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125   <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a> ccAlleles = {<span class="stringliteral">&quot;cc-alleles&quot;</span>,SelfDoc::Opt::Integer,<span class="stringliteral">&quot;6&quot;</span>,<span class="stringliteral">&quot;6&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,<span class="stringliteral">&quot;NA&quot;</span>,
<a name="l00126"></a>00126                          <span class="stringliteral">&quot;The max number of alleles for call encoding/decoding.&quot;</span>};
<a name="l00127"></a>00127   opts.push_back(ccAlleles);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129   <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a> ccType = {<span class="stringliteral">&quot;cc-type&quot;</span>,SelfDoc::Opt::String,<span class="stringliteral">&quot;UCHAR&quot;</span>,<span class="stringliteral">&quot;UCHAR&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,<span class="stringliteral">&quot;NA&quot;</span>,
<a name="l00130"></a>00130                          <span class="stringliteral">&quot;Call encoding/decoding data size.&quot;</span>};
<a name="l00131"></a>00131   opts.push_back(ccType);
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   <a class="code" href="classSelfDoc_1_1Opt.html" title="Description of one possible option/parameter for a self describing class.">SelfDoc::Opt</a> ccVersion = {<span class="stringliteral">&quot;cc-version&quot;</span>,SelfDoc::Opt::String,<span class="stringliteral">&quot;1.0&quot;</span>,<span class="stringliteral">&quot;1.0&quot;</span>,<span class="stringliteral">&quot;0&quot;</span>,<span class="stringliteral">&quot;NA&quot;</span>,
<a name="l00134"></a>00134                          <span class="stringliteral">&quot;Call encoding/decoding version.&quot;</span>};
<a name="l00135"></a>00135   opts.push_back(ccVersion);
<a name="l00136"></a>00136 
<a name="l00137"></a>00137   doc.<a class="code" href="classSelfDoc.html#aa43e6721e35792413711e07bda90861d" title="Setter method for parameters and their documentation.">setDocOptions</a>(opts);
<a name="l00138"></a>00138 }
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="comment"></span>
<a name="l00142"></a>00142 <span class="comment">/**</span>
<a name="l00143"></a>00143 <span class="comment"> * @brief Supply a little how/what/why about the algorithms this</span>
<a name="l00144"></a>00144 <span class="comment"> * class performs and what parameters it takes.</span>
<a name="l00145"></a>00145 <span class="comment"> * @return SelfDoc</span>
<a name="l00146"></a>00146 <span class="comment"> */</span>
<a name="l00147"></a><a class="code" href="classQuantLabelZMulti.html#a186beaa8237d8291026fa2b0b542beab">00147</a> <a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a> <a class="code" href="classQuantLabelZMulti.html#a186beaa8237d8291026fa2b0b542beab" title="Supply a little how/what/why about the algorithms this class performs and what parameters it takes...">QuantLabelZMulti::explainSelf</a>() {
<a name="l00148"></a>00148   <a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a> doc;
<a name="l00149"></a>00149   <a class="code" href="classQuantLabelZMulti.html#a2c5fe9639d18fee9a4f98430b48529ba" title="Fill in our self documentation from current state.">setupSelfDoc</a>(doc);
<a name="l00150"></a>00150   <span class="keywordflow">return</span> doc;
<a name="l00151"></a>00151 }
<a name="l00152"></a>00152 <span class="comment"></span>
<a name="l00153"></a>00153 <span class="comment">/**</span>
<a name="l00154"></a>00154 <span class="comment"> * @brief This static function should be overridden by child classes</span>
<a name="l00155"></a>00155 <span class="comment"> * to return an object of the correct type initialized correctly</span>
<a name="l00156"></a>00156 <span class="comment"> * with the parameters in the string, string map. All objects</span>
<a name="l00157"></a>00157 <span class="comment"> * created this way should be deleted when finished using.</span>
<a name="l00158"></a>00158 <span class="comment"> *</span>
<a name="l00159"></a>00159 <span class="comment"> * @param param - Map of key/value pairs to initialize the object.</span>
<a name="l00160"></a>00160 <span class="comment"> *</span>
<a name="l00161"></a>00161 <span class="comment"> * @return Pointer toCreate object, this should be sub casted as necessary.</span>
<a name="l00162"></a>00162 <span class="comment"> */</span>
<a name="l00163"></a><a class="code" href="classQuantLabelZMulti.html#abe2ff0f9ec0b2f21835b5600cf9e0a42">00163</a> <a class="code" href="classSelfCreate.html" title="Small interface for functions that know how to make an instance of themselves given a map of key...">SelfCreate</a> *<a class="code" href="classQuantLabelZMulti.html#abe2ff0f9ec0b2f21835b5600cf9e0a42" title="This static function should be overridden by child classes to return an object of the correct type in...">QuantLabelZMulti::newObject</a>(std::map&lt;std::string,std::string&gt; &amp;param) {
<a name="l00164"></a>00164   <a class="code" href="classSelfDoc.html" title="Small interface to for algorithmic classes that can explain themselves.">SelfDoc</a> doc = <a class="code" href="classQuantLabelZMulti.html#a186beaa8237d8291026fa2b0b542beab" title="Supply a little how/what/why about the algorithms this class performs and what parameters it takes...">explainSelf</a>();
<a name="l00165"></a>00165   <span class="keywordtype">bool</span> lowprecision = <span class="keyword">false</span>;
<a name="l00166"></a>00166   <span class="keyword">enum</span> <a class="code" href="GenoUtility_8h.html#a0176e2f61ce5ea7a3495a511cf46b2c1">Transformation</a> <a class="code" href="classQuantLabelZ.html#a0ec9313e121ec2cc1304350a7bb4a909" title="Transform allele estimates.">transform</a> = CCS;
<a name="l00167"></a>00167   <span class="keywordtype">double</span> K=4;
<a name="l00168"></a>00168   <span class="keywordtype">int</span> praThresh = 3;
<a name="l00169"></a>00169   <span class="keywordtype">string</span> transformStr;
<a name="l00170"></a>00170   <span class="keywordtype">int</span> ccAlleles = 6;
<a name="l00171"></a>00171   <span class="keywordtype">string</span> ccType = <span class="stringliteral">&quot;UCHAR&quot;</span>;
<a name="l00172"></a>00172   <span class="keywordtype">string</span> ccVersion = <span class="stringliteral">&quot;1.0&quot;</span>;
<a name="l00173"></a>00173   map&lt;string,string&gt;::iterator iter;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175   fillInValue(K, <span class="stringliteral">&quot;K&quot;</span>, param, doc);
<a name="l00176"></a>00176   fillInValue(praThresh, <span class="stringliteral">&quot;pra-thresh&quot;</span>, param, doc);
<a name="l00177"></a>00177   fillInValue(ccAlleles, <span class="stringliteral">&quot;cc-alleles&quot;</span>, param, doc);
<a name="l00178"></a>00178   fillInValue(ccType, <span class="stringliteral">&quot;cc-type&quot;</span>, param, doc);
<a name="l00179"></a>00179   fillInValue(ccVersion, <span class="stringliteral">&quot;cc-version&quot;</span>, param, doc);
<a name="l00180"></a>00180 
<a name="l00181"></a>00181   fillInValue(transformStr, <span class="stringliteral">&quot;transform&quot;</span>, param, doc);
<a name="l00182"></a>00182   transform = <a class="code" href="GenoUtility_8cpp.html#ab5c8b5877412aebfe6eb80db02bbc096" title="Convert a (text insensitive) text repesentation of a transformation into the enumration.">transformationForString</a>(transformStr);
<a name="l00183"></a>00183   <a class="code" href="classQuantLabelZMulti.html">QuantLabelZMulti</a> *labelz = <span class="keyword">new</span> <a class="code" href="classQuantLabelZMulti.html">QuantLabelZMulti</a>(transform, K, lowprecision, praThresh, ccAlleles, ccType, ccVersion);
<a name="l00184"></a>00184 
<a name="l00185"></a>00185   <a class="code" href="classsnp__param.html" title="this holds all the parameters for a snp, including alg choices">snp_param</a> ts;
<a name="l00186"></a>00186   ts.<a class="code" href="classsnp__param.html#a956b62e64130e43f407662c31f54b372" title="initialize to some useful defaults">Initialize</a>();
<a name="l00187"></a>00187   <span class="comment">// prior strength</span>
<a name="l00188"></a>00188   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a7325d44177912f9851253b1af5893ee3" title="aa allele cluster">aa</a>.<a class="code" href="classcluster__data.html#a09bcd6068f14afa7d1f52c270e3a2be7" title="strength of mean (pseudo-observations)">k</a>,<span class="stringliteral">&quot;KX&quot;</span>,param,doc);
<a name="l00189"></a>00189   ts.prior.<a class="code" href="classsnp__distribution.html#a65361a16c9c09a1870492f441ab9e299" title="bb genotype cluster">bb</a>.<a class="code" href="classcluster__data.html#a09bcd6068f14afa7d1f52c270e3a2be7" title="strength of mean (pseudo-observations)">k</a>=ts.prior.<a class="code" href="classsnp__distribution.html#a7325d44177912f9851253b1af5893ee3" title="aa allele cluster">aa</a>.<a class="code" href="classcluster__data.html#a09bcd6068f14afa7d1f52c270e3a2be7" title="strength of mean (pseudo-observations)">k</a>;
<a name="l00190"></a>00190   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#a09bcd6068f14afa7d1f52c270e3a2be7" title="strength of mean (pseudo-observations)">k</a>,<span class="stringliteral">&quot;KH&quot;</span>,param,doc);
<a name="l00191"></a>00191 
<a name="l00192"></a>00192   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#aaaf1dec521d21ec061d6d9e7c3b1e78c" title="strength of variance (pseudo-observations)">v</a>,<span class="stringliteral">&quot;V&quot;</span>,param,doc);
<a name="l00193"></a>00193   ts.prior.<a class="code" href="classsnp__distribution.html#a7325d44177912f9851253b1af5893ee3" title="aa allele cluster">aa</a>.<a class="code" href="classcluster__data.html#aaaf1dec521d21ec061d6d9e7c3b1e78c" title="strength of variance (pseudo-observations)">v</a>=ts.prior.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#aaaf1dec521d21ec061d6d9e7c3b1e78c" title="strength of variance (pseudo-observations)">v</a>;
<a name="l00194"></a>00194   ts.prior.<a class="code" href="classsnp__distribution.html#a65361a16c9c09a1870492f441ab9e299" title="bb genotype cluster">bb</a>.<a class="code" href="classcluster__data.html#aaaf1dec521d21ec061d6d9e7c3b1e78c" title="strength of variance (pseudo-observations)">v</a>=ts.prior.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#aaaf1dec521d21ec061d6d9e7c3b1e78c" title="strength of variance (pseudo-observations)">v</a>;
<a name="l00195"></a>00195   <span class="comment">// prior centers</span>
<a name="l00196"></a>00196   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a65361a16c9c09a1870492f441ab9e299" title="bb genotype cluster">bb</a>.<a class="code" href="classcluster__data.html#a6d6d0888d2b43c15e866d2beaaf63643" title="mean of cluster">m</a>,<span class="stringliteral">&quot;BBM&quot;</span>,param,doc);
<a name="l00197"></a>00197   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#a6d6d0888d2b43c15e866d2beaaf63643" title="mean of cluster">m</a>,<span class="stringliteral">&quot;ABM&quot;</span>,param,doc);
<a name="l00198"></a>00198   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a7325d44177912f9851253b1af5893ee3" title="aa allele cluster">aa</a>.<a class="code" href="classcluster__data.html#a6d6d0888d2b43c15e866d2beaaf63643" title="mean of cluster">m</a>,<span class="stringliteral">&quot;AAM&quot;</span>,param,doc);
<a name="l00199"></a>00199   <span class="comment">// prior y coordinates</span>
<a name="l00200"></a>00200   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a65361a16c9c09a1870492f441ab9e299" title="bb genotype cluster">bb</a>.<a class="code" href="classcluster__data.html#a574a5134fb9a0d351afb6c08421f74c4" title="mean of cluster in other dimension">ym</a>,<span class="stringliteral">&quot;BBY&quot;</span>,param,doc);
<a name="l00201"></a>00201   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#a574a5134fb9a0d351afb6c08421f74c4" title="mean of cluster in other dimension">ym</a>,<span class="stringliteral">&quot;ABY&quot;</span>,param,doc);
<a name="l00202"></a>00202   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a7325d44177912f9851253b1af5893ee3" title="aa allele cluster">aa</a>.<a class="code" href="classcluster__data.html#a574a5134fb9a0d351afb6c08421f74c4" title="mean of cluster in other dimension">ym</a>,<span class="stringliteral">&quot;AAY&quot;</span>,param,doc);
<a name="l00203"></a>00203   <span class="comment">// prior variances</span>
<a name="l00204"></a>00204   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a7325d44177912f9851253b1af5893ee3" title="aa allele cluster">aa</a>.<a class="code" href="classcluster__data.html#ab5687aae0f32c286b69bd0cf5e0d9d37" title="variance of cluster">ss</a>,<span class="stringliteral">&quot;AAV&quot;</span>,param,doc);
<a name="l00205"></a>00205   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a65361a16c9c09a1870492f441ab9e299" title="bb genotype cluster">bb</a>.<a class="code" href="classcluster__data.html#ab5687aae0f32c286b69bd0cf5e0d9d37" title="variance of cluster">ss</a>,<span class="stringliteral">&quot;BBV&quot;</span>,param,doc);
<a name="l00206"></a>00206   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#ab5687aae0f32c286b69bd0cf5e0d9d37" title="variance of cluster">ss</a>,<span class="stringliteral">&quot;ABV&quot;</span>,param,doc);
<a name="l00207"></a>00207   <span class="comment">// prior y variances</span>
<a name="l00208"></a>00208   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a7325d44177912f9851253b1af5893ee3" title="aa allele cluster">aa</a>.<a class="code" href="classcluster__data.html#a1ef1f56306029c073109d5fcc9922e1d" title="variance of cluster in other dimension">yss</a>,<span class="stringliteral">&quot;AAYV&quot;</span>,param,doc);
<a name="l00209"></a>00209   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#a1ef1f56306029c073109d5fcc9922e1d" title="variance of cluster in other dimension">yss</a>,<span class="stringliteral">&quot;ABYV&quot;</span>,param,doc);
<a name="l00210"></a>00210   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a65361a16c9c09a1870492f441ab9e299" title="bb genotype cluster">bb</a>.<a class="code" href="classcluster__data.html#a1ef1f56306029c073109d5fcc9922e1d" title="variance of cluster in other dimension">yss</a>,<span class="stringliteral">&quot;BBYV&quot;</span>,param,doc);
<a name="l00211"></a>00211   <span class="comment">// prior xy covariances</span>
<a name="l00212"></a>00212   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a7325d44177912f9851253b1af5893ee3" title="aa allele cluster">aa</a>.<a class="code" href="classcluster__data.html#ab37cdb91afcdf8b3c0924a150b31b4ed" title="covariance of cluster in both directions">xyss</a>,<span class="stringliteral">&quot;AAXY&quot;</span>,param,doc);
<a name="l00213"></a>00213   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#ab37cdb91afcdf8b3c0924a150b31b4ed" title="covariance of cluster in both directions">xyss</a>,<span class="stringliteral">&quot;ABXY&quot;</span>,param,doc);
<a name="l00214"></a>00214   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a65361a16c9c09a1870492f441ab9e299" title="bb genotype cluster">bb</a>.<a class="code" href="classcluster__data.html#ab37cdb91afcdf8b3c0924a150b31b4ed" title="covariance of cluster in both directions">xyss</a>,<span class="stringliteral">&quot;BBXY&quot;</span>,param,doc);
<a name="l00215"></a>00215   <span class="comment">// X-X covariances between clusters</span>
<a name="l00216"></a>00216    fillInValue(ts.prior.xab,<span class="stringliteral">&quot;KXX&quot;</span>,param,doc);
<a name="l00217"></a>00217   fillInValue(ts.prior.xah,<span class="stringliteral">&quot;KAH&quot;</span>,param,doc);
<a name="l00218"></a>00218   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a7daecf444a60233a0de51e4c32fe7091" title="cross-correlation terms between clusters x">xhb</a>,<span class="stringliteral">&quot;KHB&quot;</span>,param,doc);
<a name="l00219"></a>00219   <span class="comment">// Y-Y covariances between clusters</span>
<a name="l00220"></a>00220   fillInValue(ts.prior.yah,<span class="stringliteral">&quot;KYAH&quot;</span>,param,doc);
<a name="l00221"></a>00221   fillInValue(ts.prior.yab,<span class="stringliteral">&quot;KYAB&quot;</span>,param,doc);
<a name="l00222"></a>00222   fillInValue(ts.prior.<a class="code" href="classsnp__distribution.html#a2bd112107fcbccf699b612f410aaa73c" title="cross-correlation terms between clusters y">yhb</a>,<span class="stringliteral">&quot;KYHB&quot;</span>,param,doc);
<a name="l00223"></a>00223   <span class="comment">// wacky parameters</span>
<a name="l00224"></a>00224   fillInValue(ts.<a class="code" href="classsnp__param.html#a5996056f7436f5974c6e6b6bd7925a27" title="do we use common variances for all clusters?">comvar</a>,<span class="stringliteral">&quot;COMVAR&quot;</span>,param,doc);
<a name="l00225"></a>00225   fillInValue(ts.<a class="code" href="classsnp__param.html#a1900bf669c78de37107156241c6adcd4" title="do we stop cluster centers from being too close?">hardshell</a>,<span class="stringliteral">&quot;HARD&quot;</span>,param,doc);
<a name="l00226"></a>00226   fillInValue(ts.<a class="code" href="classsnp__param.html#aea03fd76d67d7a0ebf46827c26f684e9" title="how close can cluster centers be?">shellbarrier</a>,<span class="stringliteral">&quot;SB&quot;</span>,param,doc);
<a name="l00227"></a>00227   fillInValue(ts.<a class="code" href="classsnp__param.html#ac6c59acd942ff43d8aa6baa17ad6364b" title="do we use raw labels or posterior distributions?">callmethod</a>,<span class="stringliteral">&quot;CM&quot;</span>,param,doc);
<a name="l00228"></a>00228   fillInValue(ts.<a class="code" href="classsnp__param.html#ab106a36c2ad59a00fdad233b5577d0b6" title="use quick method">bins</a>,<span class="stringliteral">&quot;bins&quot;</span>,param,doc);
<a name="l00229"></a>00229   fillInValue(ts.<a class="code" href="classsnp__param.html#ab10a7ca6260c50da3d78db608ad5faa3" title="use hinted genotypes as reference">hints</a>,<span class="stringliteral">&quot;hints&quot;</span>,param,doc);
<a name="l00230"></a>00230   fillInValue(ts.<a class="code" href="classsnp__param.html#a5bb07d912ac1deddb4be58a2e35f68cf" title="penalty for contradicting a hint">contradictionpenalty</a>, <span class="stringliteral">&quot;CP&quot;</span>,param,doc);
<a name="l00231"></a>00231   fillInValue(ts.<a class="code" href="classsnp__param.html#afc17331895d50682f60ee3912e733c8c" title="allow hints to be flipped in genotype 0,1,2&amp;lt;-&amp;gt;2,1,0">hok</a>,<span class="stringliteral">&quot;Hok&quot;</span>,param,doc);
<a name="l00232"></a>00232   fillInValue(ts.<a class="code" href="classsnp__param.html#ae4dba9978ef175bdadc5a3379289c0ef" title="turn on mixture distribution penalty">mix</a>,<span class="stringliteral">&quot;mix&quot;</span>,param,doc);
<a name="l00233"></a>00233   fillInValue(ts.<a class="code" href="classsnp__param.html#adfe46fd4d9582396882e89eaf3592c5a" title="bic penalty level bic*nparam*log(n)">bic</a>,<span class="stringliteral">&quot;bic&quot;</span>,param,doc);
<a name="l00234"></a>00234   fillInValue(ts.<a class="code" href="classsnp__param.html#ab30f88b4fe7b2476acf77727745ae6ab" title="penalty for FLD separation too low">CSepPen</a>,<span class="stringliteral">&quot;CSepPen&quot;</span>,param,doc);
<a name="l00235"></a>00235   fillInValue(ts.<a class="code" href="classsnp__param.html#a3fad707f15cabcac4f8c7097781fd9b8" title="stop penalizing using Geman-McClure">CSepThr</a>,<span class="stringliteral">&quot;CSepThr&quot;</span>,param,doc);
<a name="l00236"></a>00236   fillInValue(ts.<a class="code" href="classsnp__param.html#adf74b0bee8088a3039b721b11abc585e" title="control mixing of variances if common">lambda</a>,<span class="stringliteral">&quot;lambda&quot;</span>,param,doc);
<a name="l00237"></a>00237   fillInValue(ts.<a class="code" href="classsnp__param.html#aabee7993a0cd2545731ff91f5d6cce4e" title="how much do we allow clusters to shift from prior">wobble</a>,<span class="stringliteral">&quot;wobble&quot;</span>,param,doc);
<a name="l00238"></a>00238   fillInValue(ts.<a class="code" href="classsnp__param.html#a46bef7e8276bb252b9787ebaf8f90f9b" title="check for possible outlier &amp;quot;size&amp;quot; values">copyqc</a>,<span class="stringliteral">&quot;copyqc&quot;</span>,param,doc);
<a name="l00239"></a>00239   fillInValue(ts.<a class="code" href="classsnp__param.html#a1095b75124fb8658e9fafec4140d854d" title="how to handle copy number outlier detection">copytype</a>,<span class="stringliteral">&quot;copytype&quot;</span>,param,doc);
<a name="l00240"></a>00240   fillInValue(ts.<a class="code" href="classsnp__param.html#a5137d727c65f534313add6d70f3be81b" title="do I handle multiple cluster dimensions">clustertype</a>,<span class="stringliteral">&quot;clustertype&quot;</span>,param,doc);
<a name="l00241"></a>00241   fillInValue(ts.<a class="code" href="classsnp__param.html#ad0561d07114f9c66a173dd3b904492a4" title="uniform density to compare weird data points against">ocean</a>,<span class="stringliteral">&quot;ocean&quot;</span>,param,doc);
<a name="l00242"></a>00242   <span class="comment">//printf(&quot;BBM: %f AAM: %f CM: %d\n&quot;,ts.bb.m,ts.aa.m,ts.callmethod);</span>
<a name="l00243"></a>00243   <span class="comment">//ts.aa.Dump();</span>
<a name="l00244"></a>00244   <span class="comment">//ts.ab.Dump();</span>
<a name="l00245"></a>00245   <span class="comment">//ts.bb.Dump();</span>
<a name="l00246"></a>00246   labelz-&gt;<a class="code" href="classQuantLabelZ.html#aac7e6719fad7743dd468cad018f621c2" title="Set the snp-parameters for this run.">setLabelParam</a>(ts);
<a name="l00247"></a>00247   <span class="keywordtype">double</span> t_em_cutoff,t_em_thresh,t_gender_cutoff;
<a name="l00248"></a>00248   fillInValue(t_em_cutoff,<span class="stringliteral">&quot;em_cutoff&quot;</span>,param,doc);
<a name="l00249"></a>00249   fillInValue(t_em_thresh,<span class="stringliteral">&quot;em_thresh&quot;</span>,param,doc);
<a name="l00250"></a>00250   fillInValue(t_gender_cutoff,<span class="stringliteral">&quot;gender_cutoff&quot;</span>,param,doc);
<a name="l00251"></a>00251   labelz-&gt;<a class="code" href="classQuantLabelZ.html#acaef334285a1263ca32c6070f620a184" title="Sets the EM specific parameters for calling genders from chrX snps.">setGenderParam</a>(t_em_thresh,t_em_cutoff,t_gender_cutoff);
<a name="l00252"></a>00252   <span class="keywordtype">double</span> score;
<a name="l00253"></a>00253   fillInValue(score,<span class="stringliteral">&quot;MS&quot;</span>,param,doc);
<a name="l00254"></a>00254   labelz-&gt;<a class="code" href="classQuantLabelZ.html#ac97957acc212aebea23d9f2fbdeb1702" title="sets the max-score used for this analysis method">setMaxScore</a>(score);
<a name="l00255"></a>00255   <span class="keywordtype">int</span> overrideflag;
<a name="l00256"></a>00256   fillInValue(overrideflag,<span class="stringliteral">&quot;override&quot;</span>,param,doc);
<a name="l00257"></a>00257   labelz-&gt;<a class="code" href="classQuantLabelZ.html#acd9b42625edf51edc84489627065f649" title="Set override flag.">setOverride</a>(overrideflag);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <span class="keywordflow">return</span> labelz;
<a name="l00260"></a>00260 }
<a name="l00261"></a>00261 <span class="comment"></span>
<a name="l00262"></a>00262 <span class="comment">/**</span>
<a name="l00263"></a>00263 <span class="comment"> * @brief Set up the quantification method given all the data about the probe</span>
<a name="l00264"></a>00264 <span class="comment"> * set, chip layout and data.</span>
<a name="l00265"></a>00265 <span class="comment"> *</span>
<a name="l00266"></a>00266 <span class="comment"> * @param psGroup - Probes to be used for final estimate.</span>
<a name="l00267"></a>00267 <span class="comment"> * @param layout - Chip layout annotation.</span>
<a name="l00268"></a>00268 <span class="comment"> * @param iMart - Raw data from chips.</span>
<a name="l00269"></a>00269 <span class="comment"> * @param iTrans - Transformations to be applied to data before use.</span>
<a name="l00270"></a>00270 <span class="comment"> * @param pmAdjust - How to estimate background, or MM probe.</span>
<a name="l00271"></a>00271 <span class="comment"> * @return True if setup sucessful, false otherwise.</span>
<a name="l00272"></a>00272 <span class="comment"> */</span>
<a name="l00273"></a><a class="code" href="classQuantLabelZMulti.html#a07dc60f0f55d86880617ea6252255350">00273</a> <span class="keywordtype">bool</span> <a class="code" href="classQuantLabelZMulti.html#a07dc60f0f55d86880617ea6252255350" title="Set up the quantification method given all the data about the probe set, chip layout and data...">QuantLabelZMulti::setUp</a>(<a class="code" href="classProbeSetGroup.html" title="Group of probe sets that should be processed as a single large probe set.">ProbeSetGroup</a> &amp;psGroup, <span class="keyword">const</span> <a class="code" href="classIntensityMart.html" title="IntensityMart.">IntensityMart</a> &amp;iMart, 
<a name="l00274"></a>00274                              std::vector&lt;ChipStream *&gt; &amp;iTrans, <a class="code" href="classPmAdjuster.html" title="Interface for determining a change based on intensity of perfect match.">PmAdjuster</a> &amp;pmAdjust) {
<a name="l00275"></a>00275 
<a name="l00276"></a>00276   <span class="keyword">const</span> <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> *gtPs = NULL; <span class="comment">// Genotyping probeset</span>
<a name="l00277"></a>00277 
<a name="l00278"></a>00278   <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;
<a name="l00279"></a>00279   <span class="comment">/* Sanity checks about probesets. */</span>
<a name="l00280"></a>00280   <span class="keywordflow">if</span>(psGroup.<a class="code" href="classProbeSetGroup.html#aa197d2e48f3c2e8ae67cc8f5d54735ac" title="Vector of probe set pointers.">probeSets</a>.empty())
<a name="l00281"></a>00281     <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;Zero probesets in ProbeSetGroup (group: &quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(psGroup.<a class="code" href="classProbeSetGroup.html#a0eb8ea2dfda45864880e0495539753db" title="Name of probe set group.">name</a>) + <span class="stringliteral">&quot;).&quot;</span>);
<a name="l00282"></a>00282   <span class="keywordflow">if</span>(psGroup.<a class="code" href="classProbeSetGroup.html#aa197d2e48f3c2e8ae67cc8f5d54735ac" title="Vector of probe set pointers.">probeSets</a>.size() &gt; 1)
<a name="l00283"></a>00283     <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;Can&#39;t have multiple probesets in a genotyping ProbeSetGroup (group: &quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(psGroup.<a class="code" href="classProbeSetGroup.html#a0eb8ea2dfda45864880e0495539753db" title="Name of probe set group.">name</a>) + <span class="stringliteral">&quot;).&quot;</span>);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285   <span class="comment">/* Remember this probeset. */</span>
<a name="l00286"></a>00286   gtPs = psGroup.<a class="code" href="classProbeSetGroup.html#aa197d2e48f3c2e8ae67cc8f5d54735ac" title="Vector of probe set pointers.">probeSets</a>[0];
<a name="l00287"></a>00287   success &amp;= <a class="code" href="classQuantLabelZMulti.html#a449585f3ab72b088350ee10ea0b9f1e7" title="Extracts intensities, etc for a probe set, so further analysis can proceed.">SetUpProbeSet</a>(gtPs, iMart, iTrans, pmAdjust, <span class="keyword">true</span>);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289   <span class="keywordflow">return</span> success;
<a name="l00290"></a>00290 }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="keywordtype">void</span> QuantLabelZMulti::amalgamateAtoms( <span class="keyword">const</span> <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a>* gtPs, 
<a name="l00293"></a>00293                                         <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> &amp;amalgamatedProbeset){
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 
<a name="l00296"></a>00296   <span class="comment">// This will the set of indices of the Atoms in gtPs that we amalgamate.  This vector is filled several times,</span>
<a name="l00297"></a>00297   <span class="comment">// once for each allele/context combination that is seen in the Atoms of gtPs. </span>
<a name="l00298"></a>00298   vector&lt;int&gt; toBeAmalgamatedThisTime;
<a name="l00299"></a>00299 
<a name="l00300"></a>00300   <span class="keywordtype">int</span> atomCount=0;
<a name="l00301"></a>00301   <span class="keywordtype">int</span> allele=0;
<a name="l00302"></a>00302   <span class="keywordtype">int</span> context=0;
<a name="l00303"></a>00303   <span class="keywordtype">int</span> numberOfAtoms=gtPs-&gt;<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.size();
<a name="l00304"></a>00304   vector&lt;int&gt; alreadyAmalgamated(numberOfAtoms, 0);
<a name="l00305"></a>00305   <span class="keywordtype">int</span> insertedAtomCount=0; 
<a name="l00306"></a>00306   <span class="keywordflow">while</span>(atomCount &lt; numberOfAtoms){
<a name="l00307"></a>00307     <span class="keywordflow">if</span>( alreadyAmalgamated[atomCount]){
<a name="l00308"></a>00308       atomCount++;
<a name="l00309"></a>00309       <span class="keywordflow">continue</span>;
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311     <span class="comment">//  We have found an Atom indexed by atomCount that has not been amalgamated.  We label it amalgamated.</span>
<a name="l00312"></a>00312     toBeAmalgamatedThisTime.erase(toBeAmalgamatedThisTime.begin(), toBeAmalgamatedThisTime.end());
<a name="l00313"></a>00313     alreadyAmalgamated[atomCount]=1;
<a name="l00314"></a>00314     toBeAmalgamatedThisTime.push_back(atomCount);
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     <span class="comment">//  We find the allele and context values for the Atom in gtPs indexed by &quot;atomCount&quot;. </span>
<a name="l00317"></a>00317     allele=gtPs-&gt;<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[atomCount]-&gt;getAlleleCode();
<a name="l00318"></a>00318     context=gtPs-&gt;<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[atomCount]-&gt;getContextCode();
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     <span class="comment">//  We determine the indices of all the atoms that have the same allele and context values; </span>
<a name="l00321"></a>00321     <span class="comment">//  as the Atom indexed by &quot;atomCount&quot;.</span>
<a name="l00322"></a>00322     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> atomIndex=atomCount+1; atomIndex &lt; numberOfAtoms; atomIndex++){
<a name="l00323"></a>00323 
<a name="l00324"></a>00324       <span class="comment">//  If Atom indexed by atomIndex has already been amalgamated we go on to the next Atom.</span>
<a name="l00325"></a>00325       <span class="keywordflow">if</span>( alreadyAmalgamated[atomIndex])
<a name="l00326"></a>00326         <span class="keywordflow">continue</span>;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328       <span class="comment">//  Determine whether the Atom with index &quot;atomIndex&quot; matches our Atom indexed by &quot;atomCount&quot;.  </span>
<a name="l00329"></a>00329       <span class="keywordflow">if</span>( allele==gtPs-&gt;<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[atomIndex]-&gt;getAlleleCode() &amp;&amp;
<a name="l00330"></a>00330           context==gtPs-&gt;<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[atomIndex]-&gt;getContextCode() ){
<a name="l00331"></a>00331             alreadyAmalgamated[atomIndex]=1;
<a name="l00332"></a>00332             toBeAmalgamatedThisTime.push_back(atomIndex);
<a name="l00333"></a>00333       }<span class="comment">//  end determination of status of Atom indexed by &quot;atomIndex&quot;.   </span>
<a name="l00334"></a>00334     }<span class="comment">// end determination of the indices of all Atoms having the same allele and context  </span>
<a name="l00335"></a>00335      <span class="comment">// values as the Atom indexed by &quot;atomCount&quot;.</span>
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 
<a name="l00338"></a>00338     <span class="comment">// We amalgamate all the atoms in the vector &quot;toBeAmalgamatedThisTime&quot;. </span>
<a name="l00339"></a>00339     <a class="code" href="classAtom.html" title="Represents a collection of probes that make up a unit for an intensity measurement of a particular se...">Atom</a>* atomPointer = amalgamatedProbeset.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[insertedAtomCount];
<a name="l00340"></a>00340     atomPointer-&gt;<a class="code" href="classAtom.html#ae167ab0dd44e020f6c08f6aaa0a65bfc" title="Code of allele (Ray generated?).">allele_code</a> = allele;
<a name="l00341"></a>00341     atomPointer-&gt;<a class="code" href="classAtom.html#afc6c8059250f7bb5f4c7c650ad97fcec" title="Which SNP context is this atom in? (in an arbratry order of contexts).">context_code</a> = context;
<a name="l00342"></a>00342     atomPointer-&gt;<a class="code" href="classAtom.html#a5953a4944a1e24b3f51a20ce92d8def2" title="Vector of probes that make up this atom. Order is important.">probes</a>.clear();
<a name="l00343"></a>00343     vector&lt;int&gt;::iterator begin=toBeAmalgamatedThisTime.begin();
<a name="l00344"></a>00344     vector&lt;int&gt;::iterator end=toBeAmalgamatedThisTime.end();
<a name="l00345"></a>00345     <span class="keywordflow">for</span>( ; begin!=end; begin++){
<a name="l00346"></a>00346       vector&lt;Probe*&gt;::iterator probeIterBegin = ((gtPs-&gt;<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[*begin])-&gt;probes).begin();
<a name="l00347"></a>00347       vector&lt;Probe*&gt;::iterator probeIterEnd = ((gtPs-&gt;<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[*begin])-&gt;probes).end();
<a name="l00348"></a>00348       <span class="keywordflow">for</span>( ; probeIterBegin!=probeIterEnd; probeIterBegin++){
<a name="l00349"></a>00349         atomPointer-&gt;<a class="code" href="classAtom.html#a5953a4944a1e24b3f51a20ce92d8def2" title="Vector of probes that make up this atom. Order is important.">probes</a>.push_back( *probeIterBegin );
<a name="l00350"></a>00350       }
<a name="l00351"></a>00351     } <span class="comment">// end amalgamation process for a single allele/context value. </span>
<a name="l00352"></a>00352 
<a name="l00353"></a>00353     insertedAtomCount++;
<a name="l00354"></a>00354   } <span class="comment">// end of while loop</span>
<a name="l00355"></a>00355   amalgamatedProbeset.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.resize(insertedAtomCount);
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 }
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 <span class="comment">/*</span>
<a name="l00360"></a>00360 <span class="comment"> * Sets up the intensities and summaries for a probe set</span>
<a name="l00361"></a>00361 <span class="comment"> * Separate function, because shared between several routines (gender, normalization, labeling)</span>
<a name="l00362"></a>00362 <span class="comment"> * Ideally, would be inherited from global genotyping class</span>
<a name="l00363"></a>00363 <span class="comment"> *</span>
<a name="l00364"></a>00364 <span class="comment"> * @param gtPs - probe set to be set up</span>
<a name="l00365"></a>00365 <span class="comment"> * @param layout - probes located on chip</span>
<a name="l00366"></a>00366 <span class="comment"> * @param iMart - serves up raw intensities</span>
<a name="l00367"></a>00367 <span class="comment"> * @param iTrans - transforms intensities</span>
<a name="l00368"></a>00368 <span class="comment"> * @param pmAdjust - background adjust</span>
<a name="l00369"></a>00369 <span class="comment"> * @param doReport - throw summaries out to reporters or not</span>
<a name="l00370"></a>00370 <span class="comment"> */</span>
<a name="l00371"></a><a class="code" href="classQuantLabelZMulti.html#a449585f3ab72b088350ee10ea0b9f1e7">00371</a> <span class="keywordtype">bool</span> <a class="code" href="classQuantLabelZMulti.html#a449585f3ab72b088350ee10ea0b9f1e7" title="Extracts intensities, etc for a probe set, so further analysis can proceed.">QuantLabelZMulti::SetUpProbeSet</a>(   <span class="keyword">const</span> <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> *gtPs, 
<a name="l00372"></a>00372                                         <span class="keyword">const</span> <a class="code" href="classIntensityMart.html" title="IntensityMart.">IntensityMart</a> &amp;iMart, 
<a name="l00373"></a>00373                                         std::vector&lt;ChipStream *&gt; &amp;iTrans, 
<a name="l00374"></a>00374                                         <a class="code" href="classPmAdjuster.html" title="Interface for determining a change based on intensity of perfect match.">PmAdjuster</a> &amp;pmAdjust, 
<a name="l00375"></a>00375                                         <span class="keywordtype">bool</span> doReport){ 
<a name="l00376"></a>00376 
<a name="l00377"></a>00377   m_Summaries.erase(m_Summaries.begin(), m_Summaries.end());
<a name="l00378"></a>00378   <span class="keywordtype">bool</span> success=<span class="keyword">true</span>;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   <span class="comment">//  We store the marker name for subsequent use in computeEstimate.</span>
<a name="l00381"></a>00381   <a class="code" href="classQuantGTypeMethod.html#ab4ce64f2ef8bc3ec6d554fa0c1f13212" title="Name of current probeset.">m_ProbesetName</a> = gtPs-&gt;<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a>;
<a name="l00382"></a>00382 
<a name="l00383"></a>00383   <span class="keywordtype">bool</span> report = doReport;
<a name="l00384"></a>00384   <span class="keywordflow">if</span>(m_ProbeSetsToReport != NULL)
<a name="l00385"></a>00385       <span class="keywordflow">if</span>(m_ProbeSetsToReport-&gt;find(<a class="code" href="classQuantGTypeMethod.html#ab4ce64f2ef8bc3ec6d554fa0c1f13212" title="Name of current probeset.">m_ProbesetName</a>.c_str())==m_ProbeSetsToReport-&gt;end())
<a name="l00386"></a>00386           report = <span class="keyword">false</span>;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388 
<a name="l00389"></a>00389   <span class="comment">// Each atom in the probeset gtPs contains the probes for a single allele/context/sense.  Since we need to have</span>
<a name="l00390"></a>00390   <span class="comment">// probes grouped in an atom without regard to the sense parameter, we amalgamate atoms over the sense parameter.</span>
<a name="l00391"></a>00391   <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a>  amalgamatedProbeset;
<a name="l00392"></a>00392 
<a name="l00393"></a>00393   <span class="comment">// We need to add a sufficiently large set of &quot;empty&quot; Atoms to the amalgamatedProbeset due to the fact that a Probeset</span>
<a name="l00394"></a>00394   <span class="comment">// maintains a vector of POINTERS to Atoms.  Thus if we define Atoms within the function &quot;amalgamateAtoms&quot; and then take</span>
<a name="l00395"></a>00395   <span class="comment">// their addresses and insert the pointers in the vector, we lose the Atom itself when the function &quot;amalgamateAtoms&quot; pops.</span>
<a name="l00396"></a>00396   <span class="comment">// The method is thus to create some &quot;empty&quot; atoms and then have the function &quot;amalgamateAtoms&quot; fill them with Probes. </span>
<a name="l00397"></a>00397   <span class="comment">// (Actually they are filled with pointer to Probes.  The management of the memory for these pointers to Probes is assumed</span>
<a name="l00398"></a>00398   <span class="comment">// to be properly maintained by the rest of the program.  This is dangerous, but is something we have lived with and will have</span>
<a name="l00399"></a>00399   <span class="comment">// to live with until the Probeset hierarchy is redone. </span>
<a name="l00400"></a>00400 
<a name="l00401"></a>00401   std::vector&lt;Atom&gt; atomVector(gtPs-&gt;<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.size());
<a name="l00402"></a>00402   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt; gtPs-&gt;<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.size(); i++){
<a name="l00403"></a>00403     amalgamatedProbeset.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.push_back(&amp;(atomVector[i]));
<a name="l00404"></a>00404   }  
<a name="l00405"></a>00405 
<a name="l00406"></a>00406   amalgamateAtoms(gtPs, amalgamatedProbeset);
<a name="l00407"></a>00407 
<a name="l00408"></a>00408   vector&lt;double&gt; summaryValues;
<a name="l00409"></a>00409   <a class="code" href="classProbeSet.html" title="Collection of atoms that measure target that should be absent or present at the same time...">ProbeSet</a> probeSetToBeSummarized;
<a name="l00410"></a>00410   probeSetToBeSummarized.<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> = ProbeSet::Expression;
<a name="l00411"></a>00411   <span class="keywordtype">string</span> name;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="comment">// Here we loop over the atoms in the probeset which has &quot;amalgamated atoms&quot;  and turn them into </span>
<a name="l00414"></a>00414   <span class="comment">// probesets for summarization.</span>
<a name="l00415"></a>00415   map&lt;int,int&gt; alleles;
<a name="l00416"></a>00416   <span class="keywordtype">int</span> numberOfAmalgamatedAtoms = amalgamatedProbeset.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.size();
<a name="l00417"></a>00417   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;numberOfAmalgamatedAtoms; i++) {
<a name="l00418"></a>00418 
<a name="l00419"></a>00419     <span class="comment">// Get an atom and create a probeSet.    </span>
<a name="l00420"></a>00420     probeSetToBeSummarized.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.push_back(amalgamatedProbeset.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[i]);
<a name="l00421"></a>00421     probeSetToBeSummarized.<a class="code" href="classProbeSet.html#aa3e4170184169cc3bee6d958d74940ba" title="What type of probeset is this?">psType</a> = ProbeSet::Expression;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423     <span class="comment">// Arrange a correct name for the probeSet.  That is marker-allele-context.</span>
<a name="l00424"></a>00424     <span class="keywordtype">int</span> suffix1 = amalgamatedProbeset.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[i]-&gt;getAlleleCode();  
<a name="l00425"></a>00425     <span class="keywordtype">int</span> suffix2 = amalgamatedProbeset.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[i]-&gt;getContextCode();  
<a name="l00426"></a>00426     name = <a class="code" href="classQuantGTypeMethod.html#ab4ce64f2ef8bc3ec6d554fa0c1f13212" title="Name of current probeset.">m_ProbesetName</a>;
<a name="l00427"></a>00427     name += <span class="stringliteral">&quot;-&quot;</span>;
<a name="l00428"></a>00428     name += AffxString::intToString(suffix1, <span class="keyword">false</span>);
<a name="l00429"></a>00429     name += <span class="stringliteral">&quot;-&quot;</span>;
<a name="l00430"></a>00430     name += AffxString::intToString(suffix2, <span class="keyword">false</span>);
<a name="l00431"></a>00431 
<a name="l00432"></a>00432     alleles[suffix1]=1;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434     probeSetToBeSummarized.<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a> = <a class="code" href="classUtil.html#a508b7aff9569ed929945d0d37eca384e" title="Create a copy of a string.">Util::cloneString</a>(name.c_str());
<a name="l00435"></a>00435 
<a name="l00436"></a>00436     <span class="comment">// Summarize.</span>
<a name="l00437"></a>00437     success &amp;= <a class="code" href="classQuantGTypeMethod.html#a6561033a69acb59e1b6ac76976f80561" title="summarize this allele">summarizeAllele</a>(&amp;probeSetToBeSummarized, 
<a name="l00438"></a>00438                     summaryValues, iMart, iTrans, 
<a name="l00439"></a>00439                     pmAdjust, <a class="code" href="classQuantLabelZ.html#a80bc774890dba758e37221c24c6f0750" title="This meethod is begin called as part of a copynumber run.">m_QuantMethod</a>, <a class="code" href="classQuantLabelZ.html#a7d599ef51c95cf54041f258872ce6412" title="Various parameters used by the brlmm algorithm.">m_Param</a>.<a class="code" href="classQuantLabelZ_1_1BrlmmParam.html#a42a668a034fcd91cdaf0b4dc7a411960" title="Summary values fed into R are usually truncated, should we do /// that to be compatible? (used for regression tests).">m_LowPrecision</a>, 
<a name="l00440"></a>00440                     report, <a class="code" href="classQuantLabelZ.html#a159af6fa4e27c546d5f8fe0c1f8d9b92" title="Report object for outputting results.">m_Reporters</a>);
<a name="l00441"></a>00441 
<a name="l00442"></a>00442     <span class="comment">//  We store the number of samples to make the algorithms in computeEstimate easier to follow.</span>
<a name="l00443"></a>00443     m_numberOfSamples = summaryValues.size();
<a name="l00444"></a>00444     m_Calls.resize(m_numberOfSamples);
<a name="l00445"></a>00445     m_CallsMulti.resize(m_numberOfSamples);
<a name="l00446"></a>00446     m_PriorObs.resize(m_numberOfSamples);
<a name="l00447"></a>00447     m_Context.resize(m_numberOfSamples);
<a name="l00448"></a>00448     <a class="code" href="classQuantLabelZ.html#a62471aecfb8fb5b0afb172c3413f795a" title="Our resulting confidences in those calls.">m_Confidences</a>.resize(m_numberOfSamples);
<a name="l00449"></a>00449     <a class="code" href="classQuantLabelZ.html#a7e5e595fb3d2bfe39f6e8973ab56a3e6" title="standardized distances from AA, AB, and BB cluster centers">m_Distances</a>.resize(3);
<a name="l00450"></a>00450     <a class="code" href="classQuantLabelZ.html#a7e5e595fb3d2bfe39f6e8973ab56a3e6" title="standardized distances from AA, AB, and BB cluster centers">m_Distances</a>[0].resize(m_numberOfSamples);
<a name="l00451"></a>00451     <a class="code" href="classQuantLabelZ.html#a7e5e595fb3d2bfe39f6e8973ab56a3e6" title="standardized distances from AA, AB, and BB cluster centers">m_Distances</a>[1].resize(m_numberOfSamples);
<a name="l00452"></a>00452     <a class="code" href="classQuantLabelZ.html#a7e5e595fb3d2bfe39f6e8973ab56a3e6" title="standardized distances from AA, AB, and BB cluster centers">m_Distances</a>[2].resize(m_numberOfSamples);
<a name="l00453"></a>00453 
<a name="l00454"></a>00454     ContextMap newContextMap;
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     <span class="comment">// Insert our newly computed summaryValues into our member data structure m_Summaries.</span>
<a name="l00457"></a>00457     <span class="comment">// This data structure is a map of allele values to a map of context values to a vector of summary values.</span>
<a name="l00458"></a>00458     <span class="comment">// Insertion begin.</span>
<a name="l00459"></a>00459     AlleleMap::iterator alleleIterator =  m_Summaries.find(suffix1); 
<a name="l00460"></a>00460     <span class="keywordflow">if</span>(alleleIterator != m_Summaries.end()){
<a name="l00461"></a>00461       <span class="comment">// We have already seen this allele.</span>
<a name="l00462"></a>00462       ContextMap::iterator contextIterator = (alleleIterator-&gt;second).find(suffix2);
<a name="l00463"></a>00463       <span class="keywordflow">if</span>(contextIterator != (alleleIterator-&gt;second).end()){
<a name="l00464"></a>00464         <span class="comment">// We have already seen this context. Should never get here. Error.</span>
<a name="l00465"></a>00465       } <span class="keywordflow">else</span>{
<a name="l00466"></a>00466         <span class="comment">// We put the summary values into the ContextMap for the present allele.</span>
<a name="l00467"></a>00467         (alleleIterator-&gt;second).insert(ContextMap::value_type(suffix2,summaryValues));
<a name="l00468"></a>00468       }
<a name="l00469"></a>00469     } <span class="keywordflow">else</span>{
<a name="l00470"></a>00470       <span class="comment">// We have a new allele not yet seen.</span>
<a name="l00471"></a>00471       newContextMap.clear();
<a name="l00472"></a>00472       newContextMap.insert(ContextMap::value_type(suffix2, summaryValues)); 
<a name="l00473"></a>00473       m_Summaries.insert(AlleleMap::value_type(suffix1, newContextMap));              
<a name="l00474"></a>00474     }
<a name="l00475"></a>00475     <span class="comment">// Insertion complete.</span>
<a name="l00476"></a>00476 
<a name="l00477"></a>00477     <span class="comment">// Clear out the data structures we&#39;ve used for preparation for the next atom.</span>
<a name="l00478"></a>00478     summaryValues.clear();
<a name="l00479"></a>00479     name = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00480"></a>00480     <span class="keyword">delete</span> [] probeSetToBeSummarized.<a class="code" href="classProbeSet.html#af10b2dac78a597ec736691302687c3f3" title="Name of probe set.">name</a>;
<a name="l00481"></a>00481     probeSetToBeSummarized.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.clear();
<a name="l00482"></a>00482   } <span class="comment">// end Atom loop.</span>
<a name="l00483"></a>00483 
<a name="l00484"></a>00484   <span class="comment">// We need to clear out the amalgamatedProbeset&#39;s collection of Atoms, otherwise, when the function pops, the pointers to</span>
<a name="l00485"></a>00485   <span class="comment">// the Probesets within the atoms get deleted.  The memory management for these pointers is elsewhere. Again, we&#39;ll have to</span>
<a name="l00486"></a>00486   <span class="comment">// live with this until the ProbeSet hierarchy gets modified.</span>
<a name="l00487"></a>00487   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; amalgamatedProbeset.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.size(); i++){
<a name="l00488"></a>00488     amalgamatedProbeset.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>[i]-&gt;probes.clear();
<a name="l00489"></a>00489   }
<a name="l00490"></a>00490   amalgamatedProbeset.<a class="code" href="classProbeSet.html#ab92eb06095441bf193a6fce3f758540b" title="Atoms that make up this probe set.">atoms</a>.clear(); 
<a name="l00491"></a>00491 
<a name="l00492"></a>00492   <span class="keywordflow">if</span>(alleles.size() &lt; 2)
<a name="l00493"></a>00493       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <span class="keywordflow">return</span>(success);
<a name="l00496"></a>00496 }  <span class="comment">// end  SetUpProbeSet</span>
<a name="l00497"></a>00497 
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 SampleMaxs QuantLabelZMulti::findMaxContextForEachSample(<span class="keywordtype">int</span> numberOfSamples){
<a name="l00500"></a>00500   SampleMaxs ourSampleMaxs;
<a name="l00501"></a>00501   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;numberOfSamples; i++){
<a name="l00502"></a>00502 
<a name="l00503"></a>00503     AlleleMap::iterator begin = m_Summaries.begin();
<a name="l00504"></a>00504     AlleleMap::iterator end = m_Summaries.end();
<a name="l00505"></a>00505     AlleleVector maxVector;
<a name="l00506"></a>00506 
<a name="l00507"></a>00507     <span class="comment">// Iterate over all alleles and find the max context for each. </span>
<a name="l00508"></a>00508     <span class="keywordflow">for</span>(; begin!=end; begin++){
<a name="l00509"></a>00509       <span class="keywordtype">int</span> allele = (*begin).first;
<a name="l00510"></a>00510       ContextMap presentContext = (*begin).second;
<a name="l00511"></a>00511       ContextMap::iterator contextBegin = presentContext.begin();
<a name="l00512"></a>00512       ContextMap::iterator contextEnd = presentContext.end();
<a name="l00513"></a>00513       <span class="comment">// Iterate over all contexts adding all &lt;&lt;allele,context&gt;, presentSummaries[i]&gt; to presentAlleleVector;</span>
<a name="l00514"></a>00514       AlleleVector presentAlleleVector;
<a name="l00515"></a>00515       <span class="keywordflow">for</span>(; contextBegin!=contextEnd; contextBegin++){
<a name="l00516"></a>00516         <span class="keywordtype">int</span> context = (*contextBegin).first;
<a name="l00517"></a>00517         vector&lt;double&gt; presentSummaries = (*contextBegin).second;
<a name="l00518"></a>00518         AlleleContext data(allele,context);
<a name="l00519"></a>00519         ASummary presentSummary(data, presentSummaries[i]);
<a name="l00520"></a>00520         presentAlleleVector.push_back(presentSummary);
<a name="l00521"></a>00521       }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523       <span class="comment">// After we&#39;ve entered all the summary values for all the contexts for the given allele we sort </span>
<a name="l00524"></a>00524       <span class="comment">// on the size of the summary value.  Then put the largest &lt;&lt;allele,context&gt;,summary&gt; into maxVector, </span>
<a name="l00525"></a>00525       <span class="comment">// then go on to the next allele and do the same thing. </span>
<a name="l00526"></a>00526       sort(presentAlleleVector.begin(), presentAlleleVector.end(), <a class="code" href="classLessThan.html">LessThan</a>());
<a name="l00527"></a>00527       maxVector.push_back(presentAlleleVector[0]);
<a name="l00528"></a>00528       <span class="comment">// Now empty presentAlleleVector so that we can use it for the next allele.</span>
<a name="l00529"></a>00529       presentAlleleVector.erase(presentAlleleVector.begin(), presentAlleleVector.end());
<a name="l00530"></a>00530     }
<a name="l00531"></a>00531 
<a name="l00532"></a>00532     <span class="comment">// After we&#39;ve found the max context for each allele sort and return the two with the largest summary values.</span>
<a name="l00533"></a>00533     sort(maxVector.begin(), maxVector.end(), <a class="code" href="classLessThan.html">LessThan</a>());
<a name="l00534"></a>00534     MaxContextVector sampleContextVector;
<a name="l00535"></a>00535     ASummary summ1 = maxVector[0];
<a name="l00536"></a>00536     ASummary summ2 = maxVector[1];
<a name="l00537"></a>00537     sampleContextVector.push_back(summ1);
<a name="l00538"></a>00538     sampleContextVector.push_back(summ2);
<a name="l00539"></a>00539     <span class="comment">//  We order the two allele context values in the sampleContextVector so as not to do two separate genotyping</span>
<a name="l00540"></a>00540     <span class="comment">//  calls.  ie.  Don&#39;t want to genotype AB and BA separately. </span>
<a name="l00541"></a>00541     sort(sampleContextVector.begin(), sampleContextVector.end(), <a class="code" href="classAlleleLessThan.html">AlleleLessThan</a>()); 
<a name="l00542"></a>00542     ourSampleMaxs.push_back( sampleContextVector );
<a name="l00543"></a>00543     <span class="comment">// Now empty maxVector preparing to use it for the next sample. </span>
<a name="l00544"></a>00544     maxVector.erase(maxVector.begin(), maxVector.end());
<a name="l00545"></a>00545   }
<a name="l00546"></a>00546   <span class="keywordflow">return</span> ourSampleMaxs;
<a name="l00547"></a>00547 }
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 <span class="keywordtype">void</span> QuantLabelZMulti::determineCopyNumber(){
<a name="l00550"></a>00550   <span class="comment">// This function will take into account all the copy number determination for the samples and probeset </span>
<a name="l00551"></a>00551   <span class="comment">// being genotyped.  This info is 1) Input from the copyNumberMap which is usually the place where</span>
<a name="l00552"></a>00552   <span class="comment">// externally computed CN information is held.  2) Gender calculation of CN.</span>
<a name="l00553"></a>00553 
<a name="l00554"></a>00554   <span class="comment">//  The default copy number is 2 so if none of the mechanisms below change the CN we return 2.</span>
<a name="l00555"></a>00555   m_CopyNumbers.resize(m_numberOfSamples);
<a name="l00556"></a>00556   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;m_numberOfSamples; i++){
<a name="l00557"></a>00557     m_CopyNumbers[i] = 2;
<a name="l00558"></a>00558   }
<a name="l00559"></a>00559   <span class="comment">// If the CN has been determined by some external method we accept that CN value </span>
<a name="l00560"></a>00560   map&lt;std::string, std::vector&lt;int&gt; &gt;::iterator iter=m_CopyNumberMap.find(<a class="code" href="classQuantGTypeMethod.html#ab4ce64f2ef8bc3ec6d554fa0c1f13212" title="Name of current probeset.">m_ProbesetName</a>); 
<a name="l00561"></a>00561   <span class="keywordflow">if</span>(iter != m_CopyNumberMap.end()){
<a name="l00562"></a>00562     m_CopyNumbers = iter-&gt;second;
<a name="l00563"></a>00563   }<span class="keywordflow">else</span>{ 
<a name="l00564"></a>00564   <span class="comment">// If not we use the information from the Special Snps file and the gender determination method to fix</span>
<a name="l00565"></a>00565   <span class="comment">// the CN. </span>
<a name="l00566"></a>00566     <span class="keywordtype">int</span> MaleCopy, FemaleCopy; 
<a name="l00567"></a>00567     map&lt;string,pair&lt;int, int&gt; &gt;::iterator test;
<a name="l00568"></a>00568     test=<a class="code" href="classQuantLabelZ.html#acc7830f7121d9a30d4ff7f38acb04ddb" title="index of special snps and their copy numbers">m_SpecialSnps</a>.find(<a class="code" href="classQuantGTypeMethod.html#ab4ce64f2ef8bc3ec6d554fa0c1f13212" title="Name of current probeset.">m_ProbesetName</a>);
<a name="l00569"></a>00569     <span class="keywordflow">if</span>(test==<a class="code" href="classQuantLabelZ.html#acc7830f7121d9a30d4ff7f38acb04ddb" title="index of special snps and their copy numbers">m_SpecialSnps</a>.end()) {
<a name="l00570"></a>00570       MaleCopy=2;
<a name="l00571"></a>00571       FemaleCopy=2;
<a name="l00572"></a>00572     }<span class="keywordflow">else</span>{
<a name="l00573"></a>00573       MaleCopy=test-&gt;second.first;
<a name="l00574"></a>00574       FemaleCopy=test-&gt;second.second;
<a name="l00575"></a>00575     }
<a name="l00576"></a>00576     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;m_numberOfSamples; i++){
<a name="l00577"></a>00577       <span class="keywordflow">if</span>(<a class="code" href="classQuantLabelZ.html#affaf5b9a057a6c13d946d21ab95cf983" title="What gender is each sample?">m_Genders</a>[i] == <a class="code" href="namespaceaffx.html#a1c064510a1a9f30814f840025d73d669ad5afd116ccd5bf71e27bab31a23fac97" title="Has XX chromosomes.">affx::Female</a> || <a class="code" href="classQuantLabelZ.html#affaf5b9a057a6c13d946d21ab95cf983" title="What gender is each sample?">m_Genders</a>[i] == <a class="code" href="namespaceaffx.html#a1c064510a1a9f30814f840025d73d669aa259d114b82ef05d3f1f9d3c81c84719" title="Don&amp;#39;t know genotype, use XX model.">affx::UnknownGender</a>)
<a name="l00578"></a>00578         m_CopyNumbers[i] = FemaleCopy;
<a name="l00579"></a>00579       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classQuantLabelZ.html#affaf5b9a057a6c13d946d21ab95cf983" title="What gender is each sample?">m_Genders</a>[i] == <a class="code" href="namespaceaffx.html#a1c064510a1a9f30814f840025d73d669afdfe578a9e9044b7b274b736ed341a81" title="Has XY chromosomes.">affx::Male</a>)
<a name="l00580"></a>00580         m_CopyNumbers[i] = MaleCopy;
<a name="l00581"></a>00581       <span class="keywordflow">else</span>
<a name="l00582"></a>00582         <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;Unknown gender seen while partitioning samples for brlmmp.&quot;</span> );
<a name="l00583"></a>00583     }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585   }
<a name="l00586"></a>00586 
<a name="l00587"></a>00587   <span class="comment">// We now have the CN predictions and need to translate these into the correct genotyping method.</span>
<a name="l00588"></a>00588   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;m_numberOfSamples; i++){
<a name="l00589"></a>00589     <span class="keywordtype">int</span> copyNumberValue=m_CopyNumbers[i]; 
<a name="l00590"></a>00590     <span class="keywordflow">switch</span>(copyNumberValue){
<a name="l00591"></a>00591       <span class="keywordflow">case</span> -3:
<a name="l00592"></a>00592         <span class="comment">// CN has been determined to be &gt;=1, so we want to use diploid model. </span>
<a name="l00593"></a>00593         m_CopyNumbers[i] = 2;
<a name="l00594"></a>00594         <span class="keywordflow">break</span>;
<a name="l00595"></a>00595 
<a name="l00596"></a>00596       <span class="keywordflow">case</span> -2:
<a name="l00597"></a>00597         <span class="comment">// CN was not available (issue of consent perhaps?) so we want to use a diploid model.</span>
<a name="l00598"></a>00598         m_CopyNumbers[i] = 2;
<a name="l00599"></a>00599         <span class="keywordflow">break</span>;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601       <span class="keywordflow">case</span> -1:
<a name="l00602"></a>00602         <span class="comment">// CN was not successfully determined so we want to use a diploid model.</span>
<a name="l00603"></a>00603         m_CopyNumbers[i] = 2;
<a name="l00604"></a>00604         <span class="keywordflow">break</span>;
<a name="l00605"></a>00605 
<a name="l00606"></a>00606       <span class="keywordflow">case</span> 0:
<a name="l00607"></a>00607         <span class="comment">// CN was determined to be 0 so we assert this fact.</span>
<a name="l00608"></a>00608         m_CopyNumbers[i] = 0;
<a name="l00609"></a>00609         <span class="keywordflow">break</span>;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611       <span class="keywordflow">case</span> 1:
<a name="l00612"></a>00612         <span class="comment">// CN was determined to be 1 so we assert this fact.</span>
<a name="l00613"></a>00613         m_CopyNumbers[i] = 1;
<a name="l00614"></a>00614         <span class="keywordflow">break</span>;
<a name="l00615"></a>00615 
<a name="l00616"></a>00616       <span class="keywordflow">case</span> 2:
<a name="l00617"></a>00617         <span class="comment">// CN was determined to be 2 so we assert this fact.</span>
<a name="l00618"></a>00618         m_CopyNumbers[i] = 2;
<a name="l00619"></a>00619         <span class="keywordflow">break</span>;
<a name="l00620"></a>00620 
<a name="l00621"></a>00621        <span class="keywordflow">default</span>:     
<a name="l00622"></a>00622         <span class="comment">// Unknown CN state reported. This means we need to extend this switch.</span>
<a name="l00623"></a>00623           <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;Unknown copy number state found while partitioning samples.&quot;</span>);
<a name="l00624"></a>00624     }<span class="comment">// end of switch</span>
<a name="l00625"></a>00625 
<a name="l00626"></a>00626   }<span class="comment">// end of for </span>
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 }<span class="comment">// end of determineCopyNumber</span>
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 
<a name="l00631"></a>00631 
<a name="l00632"></a>00632 <span class="keywordtype">int</span> QuantLabelZMulti::translateBrlmmpOutputToCall(<span class="keywordtype">int</span> copyNumber, 
<a name="l00633"></a>00633         <span class="keywordtype">int</span> brlmmpCall, <span class="keywordtype">int</span> firstAllele, <span class="keywordtype">int</span> secondAllele){
<a name="l00634"></a>00634 <span class="comment"></span>
<a name="l00635"></a>00635 <span class="comment">  ///@todo  Since this function was written Ray has added functionality to the encode which will eliminate the switches.</span>
<a name="l00636"></a>00636 <span class="comment"></span>  <span class="keywordtype">string</span> translateThisString;
<a name="l00637"></a>00637   <span class="keywordtype">string</span> firstAlleleString;
<a name="l00638"></a>00638   <span class="keywordtype">string</span> secondAlleleString;
<a name="l00639"></a>00639  
<a name="l00640"></a>00640   <span class="keywordflow">switch</span>(firstAllele){
<a name="l00641"></a>00641     <span class="keywordflow">case</span> 0:
<a name="l00642"></a>00642       firstAlleleString = <span class="stringliteral">&quot;A&quot;</span>;
<a name="l00643"></a>00643       <span class="keywordflow">break</span>;
<a name="l00644"></a>00644 
<a name="l00645"></a>00645     <span class="keywordflow">case</span> 1:
<a name="l00646"></a>00646       firstAlleleString = <span class="stringliteral">&quot;B&quot;</span>;
<a name="l00647"></a>00647       <span class="keywordflow">break</span>;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     <span class="keywordflow">case</span> 2:
<a name="l00650"></a>00650       firstAlleleString = <span class="stringliteral">&quot;C&quot;</span>;
<a name="l00651"></a>00651       <span class="keywordflow">break</span>;
<a name="l00652"></a>00652 
<a name="l00653"></a>00653     <span class="keywordflow">case</span> 3:
<a name="l00654"></a>00654       firstAlleleString = <span class="stringliteral">&quot;D&quot;</span>;
<a name="l00655"></a>00655       <span class="keywordflow">break</span>;
<a name="l00656"></a>00656 
<a name="l00657"></a>00657     <span class="keywordflow">case</span> 4:
<a name="l00658"></a>00658       firstAlleleString = <span class="stringliteral">&quot;E&quot;</span>;
<a name="l00659"></a>00659       <span class="keywordflow">break</span>;
<a name="l00660"></a>00660 
<a name="l00661"></a>00661     <span class="keywordflow">case</span> 5:
<a name="l00662"></a>00662       firstAlleleString = <span class="stringliteral">&quot;F&quot;</span>;
<a name="l00663"></a>00663       <span class="keywordflow">break</span>;
<a name="l00664"></a>00664 
<a name="l00665"></a>00665     <span class="keywordflow">case</span> 6:
<a name="l00666"></a>00666       firstAlleleString = <span class="stringliteral">&quot;G&quot;</span>;
<a name="l00667"></a>00667       <span class="keywordflow">break</span>;
<a name="l00668"></a>00668     <span class="keywordflow">case</span> 7:
<a name="l00669"></a>00669       firstAlleleString = <span class="stringliteral">&quot;H&quot;</span>;
<a name="l00670"></a>00670       <span class="keywordflow">break</span>;
<a name="l00671"></a>00671     <span class="keywordflow">case</span> 8:
<a name="l00672"></a>00672       firstAlleleString = <span class="stringliteral">&quot;I&quot;</span>;
<a name="l00673"></a>00673       <span class="keywordflow">break</span>; 
<a name="l00674"></a>00674    
<a name="l00675"></a>00675   }
<a name="l00676"></a>00676   
<a name="l00677"></a>00677   <span class="keywordflow">switch</span>(secondAllele){
<a name="l00678"></a>00678     <span class="keywordflow">case</span> 0:
<a name="l00679"></a>00679       secondAlleleString = <span class="stringliteral">&quot;A&quot;</span>;
<a name="l00680"></a>00680       <span class="keywordflow">break</span>;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     <span class="keywordflow">case</span> 1:
<a name="l00683"></a>00683       secondAlleleString = <span class="stringliteral">&quot;B&quot;</span>;
<a name="l00684"></a>00684       <span class="keywordflow">break</span>;
<a name="l00685"></a>00685 
<a name="l00686"></a>00686     <span class="keywordflow">case</span> 2:
<a name="l00687"></a>00687       secondAlleleString = <span class="stringliteral">&quot;C&quot;</span>;
<a name="l00688"></a>00688       <span class="keywordflow">break</span>;
<a name="l00689"></a>00689 
<a name="l00690"></a>00690     <span class="keywordflow">case</span> 3:
<a name="l00691"></a>00691       secondAlleleString = <span class="stringliteral">&quot;D&quot;</span>;
<a name="l00692"></a>00692       <span class="keywordflow">break</span>;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694     <span class="keywordflow">case</span> 4:
<a name="l00695"></a>00695       secondAlleleString = <span class="stringliteral">&quot;E&quot;</span>;
<a name="l00696"></a>00696       <span class="keywordflow">break</span>;
<a name="l00697"></a>00697 
<a name="l00698"></a>00698     <span class="keywordflow">case</span> 5:
<a name="l00699"></a>00699       secondAlleleString = <span class="stringliteral">&quot;F&quot;</span>;
<a name="l00700"></a>00700       <span class="keywordflow">break</span>;
<a name="l00701"></a>00701 
<a name="l00702"></a>00702     <span class="keywordflow">case</span> 6:
<a name="l00703"></a>00703       secondAlleleString = <span class="stringliteral">&quot;G&quot;</span>;
<a name="l00704"></a>00704       <span class="keywordflow">break</span>;
<a name="l00705"></a>00705     <span class="keywordflow">case</span> 7:
<a name="l00706"></a>00706       secondAlleleString = <span class="stringliteral">&quot;H&quot;</span>;
<a name="l00707"></a>00707       <span class="keywordflow">break</span>;
<a name="l00708"></a>00708     <span class="keywordflow">case</span> 8:
<a name="l00709"></a>00709       secondAlleleString = <span class="stringliteral">&quot;I&quot;</span>;
<a name="l00710"></a>00710       <span class="keywordflow">break</span>;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712   }
<a name="l00713"></a>00713 
<a name="l00714"></a>00714   <span class="keywordflow">if</span>(copyNumber == 0){
<a name="l00715"></a>00715     translateThisString = <span class="stringliteral">&quot;ZeroCopyNumber&quot;</span>;
<a name="l00716"></a>00716   }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718   <span class="keywordflow">if</span>(copyNumber==1){
<a name="l00719"></a>00719     <span class="keywordflow">if</span>(brlmmpCall == 3){
<a name="l00720"></a>00720       translateThisString = <span class="stringliteral">&quot;NoCall&quot;</span>; 
<a name="l00721"></a>00721     }
<a name="l00722"></a>00722     <span class="keywordflow">if</span>(brlmmpCall == 0){
<a name="l00723"></a>00723       translateThisString = firstAlleleString;
<a name="l00724"></a>00724     }
<a name="l00725"></a>00725     <span class="keywordflow">if</span>(brlmmpCall == 1){
<a name="l00726"></a>00726       <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;Unexpected result -- het call for cn=1!&quot;</span>);
<a name="l00727"></a>00727     }
<a name="l00728"></a>00728     <span class="keywordflow">if</span>(brlmmpCall == 2){
<a name="l00729"></a>00729       translateThisString = secondAlleleString;
<a name="l00730"></a>00730     }
<a name="l00731"></a>00731   }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733   <span class="keywordflow">if</span>(copyNumber==2){
<a name="l00734"></a>00734     <span class="keywordflow">if</span>(brlmmpCall == 3){
<a name="l00735"></a>00735       translateThisString = <span class="stringliteral">&quot;NoCall&quot;</span>;
<a name="l00736"></a>00736     } 
<a name="l00737"></a>00737     <span class="keywordflow">if</span>(brlmmpCall == 0){
<a name="l00738"></a>00738       translateThisString = firstAlleleString + firstAlleleString;
<a name="l00739"></a>00739     } 
<a name="l00740"></a>00740     <span class="keywordflow">if</span>(brlmmpCall == 1){
<a name="l00741"></a>00741       <span class="comment">//  We have to have the following check because the encoder won&#39;t accept BA,  only AB</span>
<a name="l00742"></a>00742       <span class="keywordflow">if</span>(firstAllele &lt; secondAllele){
<a name="l00743"></a>00743         translateThisString = firstAlleleString + secondAlleleString;
<a name="l00744"></a>00744       } <span class="keywordflow">else</span> {
<a name="l00745"></a>00745         translateThisString = secondAlleleString + firstAlleleString;
<a name="l00746"></a>00746       }
<a name="l00747"></a>00747 
<a name="l00748"></a>00748     } 
<a name="l00749"></a>00749     <span class="keywordflow">if</span>(brlmmpCall == 2){
<a name="l00750"></a>00750       translateThisString = secondAlleleString + secondAlleleString;
<a name="l00751"></a>00751     }
<a name="l00752"></a>00752   }
<a name="l00753"></a>00753 
<a name="l00754"></a>00754   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> code;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756   code = m_coder-&gt;<a class="code" href="classGenoCallCoder.html#ab9ff7b3ee450048176b2ce5669a1899d" title="Decode from call code number to allele name string for given probeset id.">abstractAlleleToGenotypeCallNum</a>(translateThisString);   
<a name="l00757"></a>00757   <span class="keywordflow">return</span> code; 
<a name="l00758"></a>00758 } 
<a name="l00759"></a>00759 
<a name="l00760"></a>00760 <span class="keywordtype">void</span> QuantLabelZMulti::getSequentialPrior(std::string &amp;name, <a class="code" href="classsnp__param.html" title="this holds all the parameters for a snp, including alg choices">snp_param</a> &amp;tsp, <a class="code" href="classsnp__labeled__distribution.html">snp_labeled_distribution</a> &amp;sDist) {
<a name="l00761"></a>00761   <span class="keywordflow">if</span> (m_SequentialModelTsv.<a class="code" href="classaffx_1_1TsvFile.html#a2022895d082d1d635e7f59fccab12afb" title="Skip to the next level of data which matches seek_clvl ///.">nextLevel</a>(0) == affx::TSV_OK) {
<a name="l00762"></a>00762     QuantLabelZ__SnpPriorFromStrings(sDist, m_BB, m_AB, m_AA, m_CV);
<a name="l00763"></a>00763     sDist.probeset_id = m_Id;
<a name="l00764"></a>00764     tsp.prior.Copy(sDist.Dist);
<a name="l00765"></a>00765     <span class="keywordflow">if</span> (name != m_Id) {
<a name="l00766"></a>00766       <a class="code" href="Err_8h.html#a7e26a673d8901b5bc880dfab285f5309" title="Calls Err::apt_err_abort with the filename and linenumber set.">APT_ERR_ABORT</a>(<span class="stringliteral">&quot;Expecting: &quot;</span> + name + <span class="stringliteral">&quot; but got: &quot;</span> + m_Id);
<a name="l00767"></a>00767     }
<a name="l00768"></a>00768   }
<a name="l00769"></a>00769   <span class="keywordflow">else</span> {
<a name="l00770"></a>00770     <a class="code" href="Err_8h.html#a7e26a673d8901b5bc880dfab285f5309" title="Calls Err::apt_err_abort with the filename and linenumber set.">APT_ERR_ABORT</a>(<span class="stringliteral">&quot;Expecting model for snp: &quot;</span> + name);
<a name="l00771"></a>00771   }
<a name="l00772"></a>00772 }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 <span class="keywordtype">void</span> QuantLabelZMulti::getPrior(std::string &amp;TmpName, <span class="keywordtype">int</span> presentCopyNumber, <a class="code" href="classsnp__param.html" title="this holds all the parameters for a snp, including alg choices">snp_param</a> &amp;tsp, <a class="code" href="classsnp__labeled__distribution.html">snp_labeled_distribution</a> &amp;sDist) {
<a name="l00775"></a>00775   <span class="keywordflow">if</span> (m_SequentialModelTsv.is_open()) {
<a name="l00776"></a>00776     getSequentialPrior(TmpName, tsp, sDist);
<a name="l00777"></a>00777   }
<a name="l00778"></a>00778   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_vectSnpPriors.getCount() &gt; 0) {
<a name="l00779"></a>00779     <a class="code" href="classsnp__labeled__distribution.html">snp_labeled_distribution</a> objSearch;
<a name="l00780"></a>00780     <a class="code" href="classsnp__labeled__distribution.html">snp_labeled_distribution</a>* p=NULL; 
<a name="l00781"></a>00781     objSearch.probeset_id = TmpName;
<a name="l00782"></a>00782     <span class="keywordtype">int</span> iSearchIndex = m_vectSnpPriors.binarySearch(objSearch, 0);
<a name="l00783"></a>00783     <span class="keywordflow">if</span> (iSearchIndex == -1){
<a name="l00784"></a>00784       <span class="keywordflow">if</span>(presentCopyNumber&lt;2){
<a name="l00785"></a>00785         objSearch.probeset_id = <span class="stringliteral">&quot;GENERIC:&quot;</span> + <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(presentCopyNumber);
<a name="l00786"></a>00786       } <span class="keywordflow">else</span> {
<a name="l00787"></a>00787         objSearch.probeset_id = <span class="stringliteral">&quot;GENERIC&quot;</span>;
<a name="l00788"></a>00788         iSearchIndex = m_vectSnpPriors.binarySearch(objSearch,0);
<a name="l00789"></a>00789       }
<a name="l00790"></a>00790       <span class="keywordflow">if</span>(iSearchIndex==-1){
<a name="l00791"></a>00791         <span class="comment">// should this fail to global prior?</span>
<a name="l00792"></a>00792         <a class="code" href="classErr.html#a121c0cbb1687c93444a1b5f7f6ea56af" title="Print the message supplied and abort program.">Err::errAbort</a>(<span class="stringliteral">&quot;Can&#39;t find model for SNP: &quot;</span> + TmpName);
<a name="l00793"></a>00793       }
<a name="l00794"></a>00794     } <span class="keywordflow">else</span> {
<a name="l00795"></a>00795       p = m_vectSnpPriors.getAt(iSearchIndex);
<a name="l00796"></a>00796       sDist = *p;
<a name="l00797"></a>00797       <span class="comment">// this is really one copy operation!!!</span>
<a name="l00798"></a>00798       tsp.prior.Copy(p-&gt;Dist);
<a name="l00799"></a>00799       <span class="comment">/*</span>
<a name="l00800"></a>00800 <span class="comment">        tsp.prior.aa = p-&gt;Dist.aa;</span>
<a name="l00801"></a>00801 <span class="comment">        tsp.prior.ab = p-&gt;Dist.ab;</span>
<a name="l00802"></a>00802 <span class="comment">        tsp.prior.bb = p-&gt;Dist.bb;</span>
<a name="l00803"></a>00803 <span class="comment">        tsp.prior.xah = p-&gt;Dist.xah;</span>
<a name="l00804"></a>00804 <span class="comment">        tsp.prior.xab = p-&gt;Dist.xab;</span>
<a name="l00805"></a>00805 <span class="comment">        tsp.prior.xhb = p-&gt;Dist.xhb;</span>
<a name="l00806"></a>00806 <span class="comment">        tsp.prior.yah = p-&gt;Dist.yah;</span>
<a name="l00807"></a>00807 <span class="comment">        tsp.prior.yab = p-&gt;Dist.yab;</span>
<a name="l00808"></a>00808 <span class="comment">        tsp.prior.yhb = p-&gt;Dist.yhb;</span>
<a name="l00809"></a>00809 <span class="comment">        tsp.prior.xyah = p-&gt;Dist.xyah;</span>
<a name="l00810"></a>00810 <span class="comment">        tsp.prior.xyab = p-&gt;Dist.xyab;</span>
<a name="l00811"></a>00811 <span class="comment">        tsp.prior.xyhb = p-&gt;Dist.xyhb;</span>
<a name="l00812"></a>00812 <span class="comment">        tsp.prior.yxah = p-&gt;Dist.yxah;</span>
<a name="l00813"></a>00813 <span class="comment">        tsp.prior.yxab = p-&gt;Dist.yxab;</span>
<a name="l00814"></a>00814 <span class="comment">        tsp.prior.yxhb = p-&gt;Dist.yxhb;</span>
<a name="l00815"></a>00815 <span class="comment">      */</span>
<a name="l00816"></a>00816     }
<a name="l00817"></a>00817   }
<a name="l00818"></a>00818 }
<a name="l00819"></a>00819 
<a name="l00820"></a><a class="code" href="classQuantLabelZMulti.html#ab41eb605df414b8e75497b6c8c6c8667">00820</a> <span class="keywordtype">void</span> <a class="code" href="classQuantLabelZMulti.html#ab41eb605df414b8e75497b6c8c6c8667" title="Do the heavy lifting of estimation.">QuantLabelZMulti::computeEstimate</a>(){
<a name="l00821"></a>00821 
<a name="l00822"></a>00822 
<a name="l00823"></a>00823   <span class="comment">// The first task is to determine the copy number applied to the samples and probeset genotyped.</span>
<a name="l00824"></a>00824   <span class="comment">// This information is used in three places.  First for the partitioning of the samples for submission</span>
<a name="l00825"></a>00825   <span class="comment">// to brlmm-p, the choice of priors for this computation and the computation of the &quot;call-code&quot; which</span>
<a name="l00826"></a>00826   <span class="comment">// is the coding of the actual genotyping. </span>
<a name="l00827"></a>00827   determineCopyNumber();
<a name="l00828"></a>00828 
<a name="l00829"></a>00829   <span class="comment">// Input and Output vectors for bayes_label. </span>
<a name="l00830"></a>00830   vector&lt;affx::GType&gt; tcall;
<a name="l00831"></a>00831   vector&lt;double&gt; tconf, tx, ty;
<a name="l00832"></a>00832 
<a name="l00833"></a>00833   <span class="comment">// For each sample find the two alleles and the corresponding contex values which </span>
<a name="l00834"></a>00834   <span class="comment">// have the largest summary values. </span>
<a name="l00835"></a>00835   SampleMaxs ourSampleMaxs = findMaxContextForEachSample(m_numberOfSamples);
<a name="l00836"></a>00836 
<a name="l00837"></a>00837   <span class="comment">//  Create the the input vectors of sample summaries for the strength/contrast computation.</span>
<a name="l00838"></a>00838   vector&lt;double&gt; firstAlleleVector, secondAlleleVector;
<a name="l00839"></a>00839   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;m_numberOfSamples; i++){
<a name="l00840"></a>00840     firstAlleleVector.push_back( ((ourSampleMaxs[i])[0]).second ); 
<a name="l00841"></a>00841     secondAlleleVector.push_back( ((ourSampleMaxs[i])[1]).second ); 
<a name="l00842"></a>00842     m_Context[i] = 
<a name="l00843"></a>00843             <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(((ourSampleMaxs[i][0]).first).first) + <span class="stringliteral">&quot;,&quot;</span> +  <span class="comment">// A Allele: allele code</span>
<a name="l00844"></a>00844             <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(((ourSampleMaxs[i][0]).first).second) + <span class="stringliteral">&quot;,&quot;</span> + <span class="comment">// A Allele: context code</span>
<a name="l00845"></a>00845             <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(((ourSampleMaxs[i][1]).first).first) + <span class="stringliteral">&quot;,&quot;</span> +  <span class="comment">// B Allele: allele code</span>
<a name="l00846"></a>00846             <a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(((ourSampleMaxs[i][1]).first).second)          <span class="comment">// B Allele: context code</span>
<a name="l00847"></a>00847             ;
<a name="l00848"></a>00848   }
<a name="l00849"></a>00849   <span class="comment">// Compute the strength/contrast values and store in original input vectors of summary values.  </span>
<a name="l00850"></a>00850   <a class="code" href="GenoUtility_8cpp.html#a1a2531d6033d567af0446274e94f74a4" title="transform the data vector">GenoUtility_transformData</a>(firstAlleleVector, secondAlleleVector, <a class="code" href="classQuantLabelZ.html#a7d599ef51c95cf54041f258872ce6412" title="Various parameters used by the brlmm algorithm.">m_Param</a>.<a class="code" href="classQuantLabelZ_1_1BrlmmParam.html#aca36e3ccdb2991480dd150165de4083d" title="What transformation of initial data are we feeding into the classifier?">m_Transform</a>,<a class="code" href="classQuantLabelZ.html#a7d599ef51c95cf54041f258872ce6412" title="Various parameters used by the brlmm algorithm.">m_Param</a>.<a class="code" href="classQuantLabelZ_1_1BrlmmParam.html#aeefcaa5a378125462d8586f2ac95796e" title="Scaling Parameter to use in transformations.">m_K</a>); 
<a name="l00851"></a>00851 
<a name="l00852"></a>00852   <span class="comment">// Now begin the main section of computeEstimate where we partition the set of samples according to allele pair values</span>
<a name="l00853"></a>00853   <span class="comment">// and the copy number of each particular sample. We then prepare for submission to the function bayes_label for genotyping. </span>
<a name="l00854"></a>00854   vector&lt;int&gt; alreadyGenotyped(m_numberOfSamples,0);
<a name="l00855"></a>00855   <span class="keywordtype">int</span> allele1, allele2;
<a name="l00856"></a>00856   <span class="keywordtype">int</span> presentCopyNumber=2;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858   <span class="comment">// This will the set of indices of samples that we submit for genotyping to bayes_label. </span>
<a name="l00859"></a>00859   vector&lt;int&gt; toBeGenotypedThisTime; 
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 
<a name="l00862"></a>00862   <span class="comment">//  The method of partitioning the samples is to start with the first sample, find its allele pair and copy</span>
<a name="l00863"></a>00863   <span class="comment">//  values.  Then pass through all the other samples, picking out those with the same characteristics, save</span>
<a name="l00864"></a>00864   <span class="comment">//  their index in &quot;toBeGenotypedThisTime&quot; and mark them as &quot;alreadyGenotyped&quot;. Then pass to the first </span>
<a name="l00865"></a>00865   <span class="comment">//  ungenotyped sample.</span>
<a name="l00866"></a>00866   <span class="keywordtype">int</span> count=0;
<a name="l00867"></a>00867   <span class="keywordflow">while</span>(count &lt; m_numberOfSamples){
<a name="l00868"></a>00868 
<a name="l00869"></a>00869     <span class="comment">//  If already genotyped we go on to the next sample.</span>
<a name="l00870"></a>00870     <span class="keywordflow">if</span>( alreadyGenotyped[count] ){
<a name="l00871"></a>00871       count++;
<a name="l00872"></a>00872       <span class="keywordflow">continue</span>;
<a name="l00873"></a>00873     }
<a name="l00874"></a>00874     <span class="comment">//  We have found a sample indexed by count that has not been genotyped.  We label it genotyped.</span>
<a name="l00875"></a>00875     toBeGenotypedThisTime.erase(toBeGenotypedThisTime.begin(), toBeGenotypedThisTime.end()); 
<a name="l00876"></a>00876     alreadyGenotyped[count]=1;
<a name="l00877"></a>00877     toBeGenotypedThisTime.push_back(count);
<a name="l00878"></a>00878 
<a name="l00879"></a>00879     <span class="comment">//  We find the allele pairs and copy number of the sample indexed by &quot;count&quot;. </span>
<a name="l00880"></a>00880     allele1=((ourSampleMaxs[count])[0]).first.first; 
<a name="l00881"></a>00881     allele2=((ourSampleMaxs[count])[1]).first.first; 
<a name="l00882"></a>00882     presentCopyNumber=m_CopyNumbers[count];
<a name="l00883"></a>00883 
<a name="l00884"></a>00884 
<a name="l00885"></a>00885     <span class="comment">//  We determine the index of all samples that have the same allele pair values and copy number</span>
<a name="l00886"></a>00886     <span class="comment">//  as the sample indexed by &quot;count&quot;.</span>
<a name="l00887"></a>00887     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> sampleIndex=count+1; sampleIndex &lt; m_numberOfSamples; sampleIndex++){
<a name="l00888"></a>00888 
<a name="l00889"></a>00889       <span class="comment">//  If sample indexed by sampleIndex has already been genotyped we go on to the next sample.</span>
<a name="l00890"></a>00890       <span class="keywordflow">if</span>( alreadyGenotyped[sampleIndex])
<a name="l00891"></a>00891         <span class="keywordflow">continue</span>;
<a name="l00892"></a>00892 
<a name="l00893"></a>00893       <span class="comment">//  Determine whether the sample with index &quot;sampleIndex&quot; matches our sample indexed by &quot;count&quot;.  </span>
<a name="l00894"></a>00894       <span class="keywordflow">if</span>( allele1==((ourSampleMaxs[sampleIndex])[0]).first.first &amp;&amp; 
<a name="l00895"></a>00895           allele2==((ourSampleMaxs[sampleIndex])[1]).first.first &amp;&amp; 
<a name="l00896"></a>00896           presentCopyNumber==m_CopyNumbers[sampleIndex]){ 
<a name="l00897"></a>00897      
<a name="l00898"></a>00898             toBeGenotypedThisTime.push_back(sampleIndex);    
<a name="l00899"></a>00899             alreadyGenotyped[sampleIndex]=1;  
<a name="l00900"></a>00900 
<a name="l00901"></a>00901       }<span class="comment">//  end determination of status of sample indexed by &quot;sampleIndex&quot;.   </span>
<a name="l00902"></a>00902     }<span class="comment">// end determination of the indices of all samples having the same allele pair and copy </span>
<a name="l00903"></a>00903      <span class="comment">// number value as the sample indexed by &quot;count&quot;.</span>
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 
<a name="l00906"></a>00906 
<a name="l00907"></a>00907     <span class="comment">//  We now find priors, if they exist, and insert them into the parameters used by bayes_label. </span>
<a name="l00908"></a>00908     <span class="comment">//  We submit all those samples whose index is in the vector &quot;toBeGenotypedThisTime&quot;.</span>
<a name="l00909"></a>00909     <span class="comment">//  We will use priors for the allele pair values of allele1, allele2 and copy number value of presentCopyNumber. </span>
<a name="l00910"></a>00910 
<a name="l00911"></a>00911     <span class="keywordtype">int</span> numberToBeGenotyped = toBeGenotypedThisTime.size();
<a name="l00912"></a>00912     <a class="code" href="classsnp__param.html" title="this holds all the parameters for a snp, including alg choices">snp_param</a> tsp;
<a name="l00913"></a>00913     tsp.<a class="code" href="classsnp__param.html#a73c1d4ba7af3924f444007aaa2e802ce" title="copy parameters">copy</a>(<a class="code" href="classQuantLabelZ.html#ac7ffc86985526812b186af719bbc02be" title="parameters used by labeling">sp</a>);
<a name="l00914"></a>00914     tsp.<a class="code" href="classsnp__param.html#a5e4855e2b4b0dbd944e007f71f81a362" title="only one copy, for example, XY snps">copynumber</a> = presentCopyNumber;
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 <span class="comment"></span>
<a name="l00917"></a>00917 <span class="comment">    ///@todo  Put prior determination in a function within QuantLabelZ to enforce conformity between QLZ and QLZM.  </span>
<a name="l00918"></a>00918 <span class="comment"></span>
<a name="l00919"></a>00919     <span class="comment">// The following is basically a cut and past from QuantLabelZ, but there are differences.</span>
<a name="l00920"></a>00920     <span class="comment">// The names for the priors are assumed to take the following form: marker-allele1-allele2,   </span>
<a name="l00921"></a>00921     <span class="comment">// with the addition of :1 if the copynumber is 1. If no priors can be found</span>
<a name="l00922"></a>00922     <span class="comment">// in that form we look for &quot;Generic:1&quot; in case copynumber is 1.  If CN=0 we use priors for CN=2, with </span>
<a name="l00923"></a>00923     <span class="comment">// the same name as for the priors for CN=2. </span>
<a name="l00924"></a>00924 
<a name="l00925"></a>00925     <span class="keywordtype">string</span> TmpName; 
<a name="l00926"></a>00926     TmpName = <a class="code" href="classQuantGTypeMethod.html#ab4ce64f2ef8bc3ec6d554fa0c1f13212" title="Name of current probeset.">m_ProbesetName</a> + <span class="stringliteral">&quot;-&quot;</span> + AffxString::intToString(allele1,<span class="keyword">false</span>) + <span class="stringliteral">&quot;-&quot;</span> 
<a name="l00927"></a>00927         + AffxString::intToString(allele2,<span class="keyword">false</span>);
<a name="l00928"></a>00928 
<a name="l00929"></a>00929     <span class="keywordflow">if</span> (presentCopyNumber==1)
<a name="l00930"></a>00930       TmpName = TmpName + <span class="stringliteral">&quot;:&quot;</span> +<a class="code" href="Convert_8h.html#a9e68e488e4da0371aea30596313537df" title="Little template function to make string conversion easy.">ToStr</a>(presentCopyNumber);
<a name="l00931"></a>00931 
<a name="l00932"></a>00932     <span class="comment">// Search for the prior which has the correct name.</span>
<a name="l00933"></a>00933     <a class="code" href="classsnp__labeled__distribution.html">snp_labeled_distribution</a> sDist;
<a name="l00934"></a>00934     getPrior(TmpName, presentCopyNumber, tsp, sDist);
<a name="l00935"></a>00935     <span class="comment">//  Prior determination is now complete.</span>
<a name="l00936"></a>00936 
<a name="l00937"></a>00937     <span class="comment">//  Here is where we make the final preparation for submission to bayes_label. Data structures are cleaned.</span>
<a name="l00938"></a>00938 
<a name="l00939"></a>00939     <span class="comment">// This is not used in QuantLabelZMulti, but we need the dummy input to satisfy the function signature. </span>
<a name="l00940"></a>00940     vector&lt;int&gt; GenoHint;
<a name="l00941"></a>00941     GenoHint.assign(m_numberOfSamples, <a class="code" href="namespaceaffx.html#a3886a33ccf4ba70052a915d878634c30a1cef2fc4697bd5fc67116fbd1ee2027b" title="No call, unknown genotype. The internal is value is &amp;#39;3&amp;#39;; external is &amp;#39;-1&amp;#39;,.">affx::NN</a>);
<a name="l00942"></a>00942 
<a name="l00943"></a>00943     <span class="comment">// This is not supplied in QuantLabelZMulti, but we need the dummy input to satisfy the function signature.</span>
<a name="l00944"></a>00944     <span class="comment">// These should be made compatible, because there is no reason for these capabilities not to be needed in general</span>
<a name="l00945"></a>00945     vector&lt;double&gt; SubsetInbredPenalty;
<a name="l00946"></a>00946     <span class="comment">// null vector, no need to do anything</span>
<a name="l00947"></a>00947     <span class="comment">// length zero vectors are ignored</span>
<a name="l00948"></a>00948     SubsetInbredPenalty.clear();
<a name="l00949"></a>00949 
<a name="l00950"></a>00950     <span class="comment">// We erase the input and output from the previous genotyping call.</span>
<a name="l00951"></a>00951     <span class="comment">// Output    </span>
<a name="l00952"></a>00952     tcall.erase(tcall.begin(), tcall.end());
<a name="l00953"></a>00953     tconf.erase(tconf.begin(), tconf.end());
<a name="l00954"></a>00954     tcall.resize(numberToBeGenotyped);
<a name="l00955"></a>00955     tconf.resize(numberToBeGenotyped);
<a name="l00956"></a>00956     <span class="comment">// Input</span>
<a name="l00957"></a>00957     tx.erase(tx.begin(), tx.end());
<a name="l00958"></a>00958     ty.erase(ty.begin(), ty.end());
<a name="l00959"></a>00959 
<a name="l00960"></a>00960     <span class="comment">// We transfer the strength/contrast values of the samples we are genotyping into the vectors tx, ty.  </span>
<a name="l00961"></a>00961     vector&lt;int&gt;::iterator vecIterBegin = toBeGenotypedThisTime.begin(); 
<a name="l00962"></a>00962     vector&lt;int&gt;::iterator vecIterEnd = toBeGenotypedThisTime.end(); 
<a name="l00963"></a>00963     <span class="keywordflow">for</span>(; vecIterBegin != vecIterEnd; vecIterBegin++){
<a name="l00964"></a>00964       tx.push_back(firstAlleleVector[*vecIterBegin]);       
<a name="l00965"></a>00965       ty.push_back(secondAlleleVector[*vecIterBegin]);   
<a name="l00966"></a>00966     }
<a name="l00967"></a>00967  
<a name="l00968"></a>00968     <span class="comment">// Do the genotyping call.</span>
<a name="l00969"></a>00969     <a class="code" href="snp_8label_8cpp.html#a1050ceb8ac15c0c39cffa4dbf76709b3" title="The master routine: takes data and turns it into genotypes with no seeds needed.">bayes_label</a>(tcall,tconf,tx,ty,GenoHint,SubsetInbredPenalty,tsp);
<a name="l00970"></a>00970 
<a name="l00971"></a>00971     <span class="comment">// Now amalgamate the tcall tconf and tsp values into the data structure m_CallsMulti m_Confidences and </span>
<a name="l00972"></a>00972     <span class="comment">// m_Distance for reporting. </span>
<a name="l00973"></a>00973     <span class="keywordtype">int</span> tempIndex=0; 
<a name="l00974"></a>00974     <span class="keywordtype">int</span> sampleCopyNumber=0;
<a name="l00975"></a>00975     <span class="keywordtype">int</span> brlmmpCall=0; 
<a name="l00976"></a>00976     <span class="keywordtype">int</span> call=0; 
<a name="l00977"></a>00977     vecIterBegin = toBeGenotypedThisTime.begin(); 
<a name="l00978"></a>00978     vecIterEnd = toBeGenotypedThisTime.end(); 
<a name="l00979"></a>00979     <span class="keywordflow">for</span>(; vecIterBegin!=vecIterEnd; vecIterBegin++){
<a name="l00980"></a>00980       <span class="comment">// To  translate the brlmmp output to a call we need the copy number of the sample and the </span>
<a name="l00981"></a>00981       <span class="comment">// brlmmp call itself. </span>
<a name="l00982"></a>00982       sampleCopyNumber = m_CopyNumbers[*vecIterBegin];
<a name="l00983"></a>00983       brlmmpCall = tcall[tempIndex];
<a name="l00984"></a>00984       <span class="comment">// For HET on CN=1, make it a no-call and set the confidence to 1</span>
<a name="l00985"></a>00985       <span class="keywordflow">if</span>(brlmmpCall == <a class="code" href="namespaceaffx.html#a3886a33ccf4ba70052a915d878634c30a83b51b7ed2e4a1b4e23378773929465b" title="Heterozygous, one copy of both A and B. (1).">affx::AB</a> &amp;&amp; sampleCopyNumber==1){
<a name="l00986"></a>00986           tconf[tempIndex] = 1.0;
<a name="l00987"></a>00987           brlmmpCall = affx::NN;
<a name="l00988"></a>00988       }
<a name="l00989"></a>00989       call = translateBrlmmpOutputToCall(sampleCopyNumber, brlmmpCall, allele1, allele2);  
<a name="l00990"></a>00990 
<a name="l00991"></a>00991       m_Calls[*vecIterBegin] = brlmmpCall;
<a name="l00992"></a>00992       m_CallsMulti[*vecIterBegin] = call;
<a name="l00993"></a>00993       <a class="code" href="classQuantLabelZ.html#a62471aecfb8fb5b0afb172c3413f795a" title="Our resulting confidences in those calls.">m_Confidences</a>[*vecIterBegin] = tconf[tempIndex];
<a name="l00994"></a>00994 
<a name="l00995"></a>00995       <span class="keywordflow">if</span>(brlmmpCall == <a class="code" href="namespaceaffx.html#a3886a33ccf4ba70052a915d878634c30a3e1bc1d31bc880685d5870951ffb5f17" title="Homozygous A version of allele. (0).">affx::AA</a>)
<a name="l00996"></a>00996         m_PriorObs[*vecIterBegin] = sDist.Dist.<a class="code" href="classsnp__distribution.html#a7325d44177912f9851253b1af5893ee3" title="aa allele cluster">aa</a>.<a class="code" href="classcluster__data.html#a09bcd6068f14afa7d1f52c270e3a2be7" title="strength of mean (pseudo-observations)">k</a>;
<a name="l00997"></a>00997       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(brlmmpCall == <a class="code" href="namespaceaffx.html#a3886a33ccf4ba70052a915d878634c30a83b51b7ed2e4a1b4e23378773929465b" title="Heterozygous, one copy of both A and B. (1).">affx::AB</a>)
<a name="l00998"></a>00998         m_PriorObs[*vecIterBegin] = sDist.Dist.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#a09bcd6068f14afa7d1f52c270e3a2be7" title="strength of mean (pseudo-observations)">k</a>;
<a name="l00999"></a>00999       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(brlmmpCall == <a class="code" href="namespaceaffx.html#a3886a33ccf4ba70052a915d878634c30a7c78281ed74a1b7cfe2ab49e6af25231" title="Homozygous B version of allele. (2).">affx::BB</a>)
<a name="l01000"></a>01000         m_PriorObs[*vecIterBegin] = sDist.Dist.<a class="code" href="classsnp__distribution.html#a65361a16c9c09a1870492f441ab9e299" title="bb genotype cluster">bb</a>.<a class="code" href="classcluster__data.html#a09bcd6068f14afa7d1f52c270e3a2be7" title="strength of mean (pseudo-observations)">k</a>;
<a name="l01001"></a>01001       <span class="keywordflow">else</span> 
<a name="l01002"></a>01002         m_PriorObs[*vecIterBegin] = 0;
<a name="l01003"></a>01003 
<a name="l01004"></a>01004       <a class="code" href="classQuantLabelZ.html#a7e5e595fb3d2bfe39f6e8973ab56a3e6" title="standardized distances from AA, AB, and BB cluster centers">m_Distances</a>[0][*vecIterBegin] =  abs((tsp.posterior.<a class="code" href="classsnp__distribution.html#a7325d44177912f9851253b1af5893ee3" title="aa allele cluster">aa</a>.<a class="code" href="classcluster__data.html#a6d6d0888d2b43c15e866d2beaaf63643" title="mean of cluster">m</a>-tx[tempIndex])/sqrt(tsp.posterior.<a class="code" href="classsnp__distribution.html#a7325d44177912f9851253b1af5893ee3" title="aa allele cluster">aa</a>.<a class="code" href="classcluster__data.html#ab5687aae0f32c286b69bd0cf5e0d9d37" title="variance of cluster">ss</a>));
<a name="l01005"></a>01005       <a class="code" href="classQuantLabelZ.html#a7e5e595fb3d2bfe39f6e8973ab56a3e6" title="standardized distances from AA, AB, and BB cluster centers">m_Distances</a>[1][*vecIterBegin] =  abs((tsp.posterior.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#a6d6d0888d2b43c15e866d2beaaf63643" title="mean of cluster">m</a>-tx[tempIndex])/sqrt(tsp.posterior.<a class="code" href="classsnp__distribution.html#a1cabc31d59fa37b51256698c5cae3329" title="ab genotype cluster">ab</a>.<a class="code" href="classcluster__data.html#ab5687aae0f32c286b69bd0cf5e0d9d37" title="variance of cluster">ss</a>)); 
<a name="l01006"></a>01006       <a class="code" href="classQuantLabelZ.html#a7e5e595fb3d2bfe39f6e8973ab56a3e6" title="standardized distances from AA, AB, and BB cluster centers">m_Distances</a>[2][*vecIterBegin] =  abs((tsp.posterior.<a class="code" href="classsnp__distribution.html#a65361a16c9c09a1870492f441ab9e299" title="bb genotype cluster">bb</a>.<a class="code" href="classcluster__data.html#a6d6d0888d2b43c15e866d2beaaf63643" title="mean of cluster">m</a>-tx[tempIndex])/sqrt(tsp.posterior.<a class="code" href="classsnp__distribution.html#a65361a16c9c09a1870492f441ab9e299" title="bb genotype cluster">bb</a>.<a class="code" href="classcluster__data.html#ab5687aae0f32c286b69bd0cf5e0d9d37" title="variance of cluster">ss</a>));
<a name="l01007"></a>01007 
<a name="l01008"></a>01008       tempIndex++;
<a name="l01009"></a>01009     }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011     <span class="comment">// now possible output of snp-specific posterior</span>
<a name="l01012"></a>01012     <span class="comment">// that is, now we&#39;ve updated the prior with the data</span>
<a name="l01013"></a>01013     <span class="comment">// and we want to save what we learned</span>
<a name="l01014"></a>01014     <span class="keywordflow">if</span> (m_SnpPosteriorTsv.is_open()) {
<a name="l01015"></a>01015       <span class="keywordtype">bool</span> report = <span class="keyword">true</span>;
<a name="l01016"></a>01016       <span class="keywordflow">if</span> (m_ProbeSetsToReport != NULL) {
<a name="l01017"></a>01017         <span class="keywordflow">if</span>(m_ProbeSetsToReport-&gt;find(<a class="code" href="classQuantGTypeMethod.html#ab4ce64f2ef8bc3ec6d554fa0c1f13212" title="Name of current probeset.">m_ProbesetName</a>.c_str())==m_ProbeSetsToReport-&gt;end()) {
<a name="l01018"></a>01018           report = <span class="keyword">false</span>;
<a name="l01019"></a>01019         }
<a name="l01020"></a>01020         <span class="keywordflow">if</span> (report) {
<a name="l01021"></a>01021           <a class="code" href="classQuantLabelZ.html#a35793acf2ae3d85c79930cadb62beb7a" title="Writes one specific posterior to a file along with snp name.">writeSnpPosteriorValue</a>(TmpName, tsp);
<a name="l01022"></a>01022         }
<a name="l01023"></a>01023       }
<a name="l01024"></a>01024     }
<a name="l01025"></a>01025 
<a name="l01026"></a>01026     <span class="comment">// Now increment the index of the sample we just genotyped.  If this sample has already been genotyped the continue</span>
<a name="l01027"></a>01027     <span class="comment">// statement at the beginning of the while loop will ensure we set count to the smallest ungenotyped sample if</span>
<a name="l01028"></a>01028     <span class="comment">// it exists.  If no ungenotyped sample exists the loop will exit. </span>
<a name="l01029"></a>01029     count++;
<a name="l01030"></a>01030   } <span class="comment">// end while  </span>
<a name="l01031"></a>01031  
<a name="l01032"></a>01032 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 23 2016 12:58:53 for Affymetrix Power Tools by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
